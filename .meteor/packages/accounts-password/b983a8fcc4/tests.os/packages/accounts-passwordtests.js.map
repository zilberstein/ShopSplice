{"version":3,"file":"/packages/accounts-password:tests.js","sources":["accounts-password/password_tests_setup.js","accounts-password/password_tests.js","accounts-password/email_tests_setup.js"],"names":[],"mappings":";;;;;;;;AAAA,0C;AACA,4D;AACA,uF;AACA,iD;AACA,G;;AAEA,gD;AACA,qC;AACA,sC;AACA,8C;AACA,gB;AACA,U;AACA,+B;AACA,G;AACA,G;;;AAGA,wE;AACA,uE;AACA,2C;AACA,E;AACA,gE;AACA,uE;AACA,wE;AACA,8D;AACA,yB;AACA,E;AACA,qE;AACA,6D;AACA,iB;AACA,6B;AACA,G;;;AAGA,gB;AACA,wD;AACA,wC;AACA,qB;AACA,wC;AACA,oC;AACA,6D;AACA,I;;AAEA,6B;AACA,oD;AACA,I;AACA,mC;AACA,kD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACjDA,+C;;AAEA,mC;;AAEA,oE;AACA,4B;;AAEA,uC;;AAEA,4C;AACA,2C;AACA,mC;AACA,sC;AACA,Q;AACA,I;AACA,0D;AACA,oC;AACA,mC;AACA,uD;AACA,O;AACA,I;AACA,sD;AACA,mC;AACA,sC;AACA,uB;AACA,I;;AAEA,2D;AACA,6B;AACA,c;AACA,kC;AACA,0D;AACA,iC;;AAEA,0B;AACA,8E;AACA,iD;AACA,M;AACA,6B;AACA,2C;AACA,M;AACA,e;AACA,6B;AACA,4D;AACA,wE;AACA,M;AACA,e;AACA,mE;AACA,qB;AACA,6B;AACA,4E;AACA,qB;AACA,yB;AACA,6C;AACA,kD;AACA,wB;AACA,S;AACA,+C;AACA,2B;AACA,sF;AACA,qC;AACA,6C;AACA,wE;AACA,0C;AACA,oD;AACA,qB;AACA,4B;AACA,sB;AACA,U;AACA,M;AACA,e;AACA,6B;AACA,wE;AACA,wE;AACA,M;AACA,e;AACA,6B;AACA,yD;AACA,wE;AACA,M;AACA,e;AACA,6B;AACA,kE;AACA,wE;AACA,M;AACA,c;AACA,K;;;AAGA,sD;AACA,6B;AACA,c;AACA,kC;AACA,0D;AACA,iC;;AAEA,8E;AACA,kB;AACA,gC;AACA,iC;AACA,8E;AACA,6D;AACA,S;AACA,M;AACA,e;AACA,mD;AACA,4B;AACA,wE;AACA,wE;AACA,M;AACA,e;AACA,2E;AACA,gB;AACA,6B;AACA,gC;AACA,yB;AACA,gF;AACA,+C;AACA,6B;AACA,sC;AACA,a;AACA,M;AACA,6B;AACA,gC;AACA,yB;AACA,2D;AACA,qD;AACA,6D;AACA,S;AACA,M;AACA,c;AACA,K;;;AAGA,oD;AACA,6B;AACA,c;AACA,kC;AACA,0D;AACA,iC;AACA,mC;;AAEA,0B;AACA,8E;AACA,iD;AACA,M;AACA,gE;AACA,6B;AACA,sB;AACA,gF;AACA,2B;AACA,0D;AACA,U;AACA,M;AACA,8C;AACA,6B;AACA,4D;AACA,uE;AACA,M;AACA,e;AACA,iC;AACA,6B;AACA,mF;AACA,2B;AACA,oC;AACA,U;AACA,M;AACA,4B;AACA,6B;AACA,0D;AACA,wE;AACA,M;AACA,c;AACA,K;;;AAGA,gD;AACA,6B;AACA,c;AACA,kC;AACA,0D;AACA,iC;AACA,M;AACA,oC;AACA,4B;AACA,0B;AACA,0D;AACA,+C;AACA,mC;AACA,iC;AACA,uC;AACA,6D;AACA,Y;AACA,M;AACA,e;AACA,4B;AACA,0B;AACA,0D;AACA,6D;AACA,qB;AACA,oD;AACA,iC;AACA,qB;AACA,yB;AACA,mE;AACA,Y;AACA,M;AACA,iC;AACA,4B;AACA,0B;AACA,0D;AACA,qC;AACA,iD;AACA,M;AACA,4B;AACA,oE;AACA,M;AACA,c;AACA,K;;;AAGA,+C;AACA,6B;AACA,c;AACA,kC;AACA,iC;;AAEA,0B;AACA,0D;AACA,qC;AACA,iD;AACA,M;AACA,wD;AACA,wE;AACA,2B;AACA,4B;AACA,sB;AACA,qC;AACA,mE;AACA,+C;AACA,yD;AACA,mD;AACA,+D;AACA,mC;AACA,U;AACA,M;AACA,4B;AACA,2E;AACA,gE;AACA,qC;AACA,iC;AACA,iD;AACA,U;AACA,M;AACA,e;AACA,4B;AACA,qC;AACA,mC;AACA,wC;AACA,mE;AACA,mC;AACA,iC;AACA,U;AACA,K;AACA,K;;AAEA,6C;AACA,6D;AACA,6B;AACA,uC;AACA,0B;AACA,4D;AACA,qC;AACA,sD;AACA,M;AACA,6B;AACA,yC;AACA,M;AACA,6B;AACA,mB;AACA,kC;AACA,iC;;AAEA,0B;AACA,0D;AACA,qC;AACA,iD;AACA,M;AACA,8E;AACA,wE;AACA,2B;AACA,4B;AACA,oC;AACA,uC;AACA,mD;AACA,gD;AACA,0B;AACA,uE;AACA,+B;AACA,2B;AACA,qC;AACA,2D;AACA,gE;AACA,Y;AACA,M;AACA,4B;AACA,mC;AACA,0B;AACA,0D;AACA,+B;AACA,2B;AACA,qC;AACA,Y;AACA,M;AACA,4B;AACA,gF;AACA,+B;AACA,4B;AACA,sE;AACA,S;AACA,4D;AACA,M;AACA,4B;AACA,yC;AACA,0B;AACA,qD;AACA,+B;AACA,4B;AACA,wD;AACA,Y;AACA,M;AACA,c;AACA,K;;;AAGA,wC;AACA,6B;AACA,c;AACA,kC;AACA,iC;;AAEA,0B;AACA,2D;AACA,iD;AACA,M;;AAEA,4B;AACA,+C;AACA,oD;AACA,yB;AACA,S;AACA,+C;AACA,yB;AACA,iC;AACA,uD;AACA,S;AACA,M;;AAEA,4B;AACA,sB;AACA,4E;AACA,4E;AACA,iD;AACA,0B;AACA,S;;AAEA,+E;AACA,kD;AACA,gC;AACA,6B;AACA,oC;AACA,S;AACA,M;AACA,yB;AACA,6B;AACA,+C;AACA,0B;AACA,M;AACA,6B;AACA,+E;AACA,wB;AACA,uE;AACA,yB;AACA,0C;AACA,U;AACA,M;AACA,6B;AACA,sB;;AAEA,mD;AACA,uB;AACA,6D;AACA,iE;AACA,wE;AACA,O;AACA,oE;AACA,iB;;AAEA,4E;AACA,8D;AACA,gB;AACA,iB;AACA,4C;;AAEA,oD;AACA,yB;AACA,S;AACA,4D;AACA,0B;AACA,4B;AACA,kD;AACA,S;AACA,oE;AACA,wC;AACA,0B;AACA,4E;AACA,6E;AACA,+B;AACA,mD;AACA,6E;AACA,U;AACA,4D;AACA,S;;AAEA,oF;AACA,0B;AACA,6C;AACA,6C;AACA,2B;AACA,iC;AACA,wD;AACA,uD;AACA,U;AACA,M;AACA,6E;AACA,yC;AACA,yB;AACA,6B;AACA,sB;AACA,+C;AACA,0B;AACA,8B;AACA,4B;AACA,qC;AACA,+B;AACA,2B;AACA,wC;AACA,U;AACA,Q;AACA,M;AACA,2E;AACA,c;AACA,6B;AACA,sB;AACA,4B;AACA,mC;AACA,+B;AACA,4B;AACA,uC;AACA,U;AACA,Q;AACA,M;AACA,e;AACA,6B;AACA,sB;AACA,oE;AACA,oF;AACA,0B;AACA,iD;AACA,U;AACA,M;AACA,wB;AACA,K;AACA,M;;;AAGA,mC;;AAEA,e;AACA,uD;AACA,qB;AACA,8B;AACA,8C;AACA,S;AACA,O;;;AAGA,e;AACA,mC;AACA,qB;AACA,iC;AACA,+B;AACA,8C;AACA,4E;AACA,S;;AAEA,2D;AACA,qE;;AAEA,0B;AACA,8C;AACA,2D;AACA,O;;;AAGA,e;AACA,8B;AACA,qB;AACA,iC;;AAEA,6D;;AAEA,8C;AACA,yB;AACA,oD;;AAEA,4B;AACA,mD;AACA,0C;AACA,mD;AACA,8C;;AAEA,sE;AACA,mD;AACA,0C;AACA,mD;AACA,wD;AACA,gE;AACA,gE;;AAEA,gB;AACA,kC;AACA,O;;;AAGA,uE;AACA,sD;AACA,oE;AACA,uC;AACA,6B;AACA,oB;AACA,O;AACA,K;;AAEA,mF;;AAEA,oB;AACA,0C;AACA,iC;AACA,iC;AACA,2B;AACA,2B;AACA,4B;AACA,S;;AAEA,yB;AACA,a;AACA,2C;AACA,0C;AACA,oC;AACA,oE;AACA,yB;AACA,a;AACA,iD;AACA,uC;AACA,gC;AACA,a;AACA,8B;AACA,4E;AACA,6B;AACA,0C;AACA,iC;AACA,kE;AACA,kC;AACA,U;AACA,kB;AACA,Q;AACA,K;AACA,I;AACA,M;;;;;;;;;;;;;;;;;;;ACnkBA,E;AACA,+D;AACA,iE;AACA,qD;AACA,E;AACA,qE;;AAEA,uC;AACA,sB;AACA,uC;AACA,qC;AACA,U;AACA,+B;AACA,iC;;AAEA,6C;AACA,iC;AACA,G;AACA,G;;AAEA,gB;AACA,0C;AACA,yB;AACA,oC;AACA,I;;AAEA,8C;AACA,yB;AACA,wB;AACA,yB;AACA,4D;AACA,uD;AACA,I;;AAEA,wC;AACA,yB;AACA,qD;AACA,yC;AACA,wC;AACA,G;AACA,G","sourcesContent":["Accounts.validateNewUser(function (user) {\n  if (user.profile && user.profile.invalidAndThrowException)\n    throw new Meteor.Error(403, \"An exception thrown within Accounts.validateNewUser\");\n  return !(user.profile && user.profile.invalid);\n});\n\nAccounts.onCreateUser(function (options, user) {\n  if (options.testOnCreateUserHook) {\n    user.profile = user.profile || {};\n    user.profile.touchedByOnCreateUser = true;\n    return user;\n  } else {\n    return 'TEST DEFAULT HOOK';\n  }\n});\n\n\n// Because this is global state that affects every client, we can't turn\n// it on and off during the tests. Doing so would mean two simultaneous\n// test runs could collide with each other.\n//\n// We should probably have some sort of server-isolation between\n// multiple test runs. Perhaps a separate server instance per run. This\n// problem isn't unique to this test, there are other places in the code\n// where we do various hacky things to work around the lack of\n// server-side isolation.\n//\n// For now, we just test the one configuration state. You can comment\n// out each configuration option and see that the tests fail.\nAccounts.config({\n  sendVerificationEmail: true\n});\n\n\nMeteor.methods({\n  testMeteorUser: function () { return Meteor.user(); },\n  clearUsernameAndProfile: function () {\n    if (!this.userId)\n      throw new Error(\"Not logged in!\");\n    Meteor.users.update(this.userId,\n                        {$unset: {profile: 1, username: 1}});\n  },\n\n  expireTokens: function () {\n    Accounts._expireTokens(new Date(), this.userId);\n  },\n  removeUser: function (username) {\n    Meteor.users.remove({ \"username\": username });\n  }\n});\n","Accounts._noConnectionCloseDelayForTest = true;\n\nif (Meteor.isClient) (function () {\n\n  // XXX note, only one test can do login/logout things at once! for\n  // now, that is this test.\n\n  Accounts._isolateLoginTokenForTest();\n\n  var logoutStep = function (test, expect) {\n    Meteor.logout(expect(function (error) {\n      test.equal(error, undefined);\n      test.equal(Meteor.user(), null);\n    }));\n  };\n  var loggedInAs = function (someUsername, test, expect) {\n    return expect(function (error) {\n      test.equal(error, undefined);\n      test.equal(Meteor.user().username, someUsername);\n    });\n  };\n  var waitForLoggedOutStep = function (test, expect) {\n    pollUntil(expect, function () {\n      return Meteor.userId() === null;\n    }, 10 * 1000, 100);\n  };\n\n  testAsyncMulti(\"passwords - basic login with password\", [\n    function (test, expect) {\n      // setup\n      this.username = Random.id();\n      this.email = Random.id() + '-intercept@example.com';\n      this.password = 'password';\n\n      Accounts.createUser(\n        {username: this.username, email: this.email, password: this.password},\n        loggedInAs(this.username, test, expect));\n    },\n    function (test, expect) {\n      test.notEqual(Meteor.userId(), null);\n    },\n    logoutStep,\n    function (test, expect) {\n      Meteor.loginWithPassword(this.username, this.password,\n                               loggedInAs(this.username, test, expect));\n    },\n    logoutStep,\n    // This next step tests reactive contexts which are reactive on\n    // Meteor.user().\n    function (test, expect) {\n      // Set up a reactive context that only refreshes when Meteor.user() is\n      // invalidated.\n      var loaded = false;\n      var handle = Deps.autorun(function () {\n        if (Meteor.user() && Meteor.user().emails)\n          loaded = true;\n      });\n      // At the beginning, we're not logged in.\n      test.isFalse(loaded);\n      Meteor.loginWithPassword(this.username, this.password, expect(function (error) {\n        test.equal(error, undefined);\n        test.notEqual(Meteor.userId(), null);\n        // By the time of the login callback, the user should be loaded.\n        test.isTrue(Meteor.user().emails);\n        // Flushing should get us the rerun as well.\n        Deps.flush();\n        test.isTrue(loaded);\n        handle.stop();\n      }));\n    },\n    logoutStep,\n    function (test, expect) {\n      Meteor.loginWithPassword({username: this.username}, this.password,\n                               loggedInAs(this.username, test, expect));\n    },\n    logoutStep,\n    function (test, expect) {\n      Meteor.loginWithPassword(this.email, this.password,\n                               loggedInAs(this.username, test, expect));\n    },\n    logoutStep,\n    function (test, expect) {\n      Meteor.loginWithPassword({email: this.email}, this.password,\n                               loggedInAs(this.username, test, expect));\n    },\n    logoutStep\n  ]);\n\n\n  testAsyncMulti(\"passwords - plain text passwords\", [\n    function (test, expect) {\n      // setup\n      this.username = Random.id();\n      this.email = Random.id() + '-intercept@example.com';\n      this.password = 'password';\n\n      // create user with raw password (no API, need to invoke callLoginMethod\n      // directly)\n      Accounts.callLoginMethod({\n        methodName: 'createUser',\n        methodArguments: [{username: this.username, password: this.password}],\n        userCallback: loggedInAs(this.username, test, expect)\n      });\n    },\n    logoutStep,\n    // check can login normally with this password.\n    function(test, expect) {\n      Meteor.loginWithPassword({username: this.username}, this.password,\n                               loggedInAs(this.username, test, expect));\n    },\n    logoutStep,\n    // plain text password. no API for this, have to invoke callLoginMethod\n    // directly.\n    function (test, expect) {\n      Accounts.callLoginMethod({\n        // wrong password\n        methodArguments: [{user: {username: this.username}, password: 'wrong'}],\n        userCallback: expect(function (error) {\n          test.isTrue(error);\n          test.isFalse(Meteor.user());\n        })});\n    },\n    function (test, expect) {\n      Accounts.callLoginMethod({\n        // right password\n        methodArguments: [{user: {username: this.username},\n                           password: this.password}],\n        userCallback: loggedInAs(this.username, test, expect)\n      });\n    },\n    logoutStep\n  ]);\n\n\n  testAsyncMulti(\"passwords - changing passwords\", [\n    function (test, expect) {\n      // setup\n      this.username = Random.id();\n      this.email = Random.id() + '-intercept@example.com';\n      this.password = 'password';\n      this.password2 = 'password2';\n\n      Accounts.createUser(\n        {username: this.username, email: this.email, password: this.password},\n        loggedInAs(this.username, test, expect));\n    },\n    // change password with bad old password. we stay logged in.\n    function (test, expect) {\n      var self = this;\n      Accounts.changePassword('wrong', 'doesntmatter', expect(function (error) {\n        test.isTrue(error);\n        test.equal(Meteor.user().username, self.username);\n      }));\n    },\n    // change password with good old password.\n    function (test, expect) {\n      Accounts.changePassword(this.password, this.password2,\n                              loggedInAs(this.username, test, expect));\n    },\n    logoutStep,\n    // old password, failed login\n    function (test, expect) {\n      Meteor.loginWithPassword(this.email, this.password, expect(function (error) {\n        test.isTrue(error);\n        test.isFalse(Meteor.user());\n      }));\n    },\n    // new password, success\n    function (test, expect) {\n      Meteor.loginWithPassword(this.email, this.password2,\n                               loggedInAs(this.username, test, expect));\n    },\n    logoutStep\n  ]);\n\n\n  testAsyncMulti(\"passwords - new user hooks\", [\n    function (test, expect) {\n      // setup\n      this.username = Random.id();\n      this.email = Random.id() + '-intercept@example.com';\n      this.password = 'password';\n    },\n    // test Accounts.validateNewUser\n    function(test, expect) {\n      Accounts.createUser(\n        {username: this.username, password: this.password,\n         // should fail the new user validators\n         profile: {invalid: true}},\n        expect(function (error) {\n          test.equal(error.error, 403);\n          test.equal(error.reason, \"User validation failed\");\n        }));\n    },\n    logoutStep,\n    function(test, expect) {\n      Accounts.createUser(\n        {username: this.username, password: this.password,\n         // should fail the new user validator with a special\n         // exception\n         profile: {invalidAndThrowException: true}},\n        expect(function (error) {\n          test.equal(\n            error.reason,\n            \"An exception thrown within Accounts.validateNewUser\");\n        }));\n    },\n    // test Accounts.onCreateUser\n    function(test, expect) {\n      Accounts.createUser(\n        {username: this.username, password: this.password,\n         testOnCreateUserHook: true},\n        loggedInAs(this.username, test, expect));\n    },\n    function(test, expect) {\n      test.equal(Meteor.user().profile.touchedByOnCreateUser, true);\n    },\n    logoutStep\n  ]);\n\n\n  testAsyncMulti(\"passwords - Meteor.user()\", [\n    function (test, expect) {\n      // setup\n      this.username = Random.id();\n      this.password = 'password';\n\n      Accounts.createUser(\n        {username: this.username, password: this.password,\n         testOnCreateUserHook: true},\n        loggedInAs(this.username, test, expect));\n    },\n    // test Meteor.user(). This test properly belongs in\n    // accounts-base/accounts_tests.js, but this is where the tests that\n    // actually log in are.\n    function(test, expect) {\n      var self = this;\n      var clientUser = Meteor.user();\n      Meteor.call('testMeteorUser', expect(function (err, result) {\n        test.equal(result._id, clientUser._id);\n        test.equal(result.username, clientUser.username);\n        test.equal(result.username, self.username);\n        test.equal(result.profile.touchedByOnCreateUser, true);\n        test.equal(err, undefined);\n      }));\n    },\n    function(test, expect) {\n      // Test that even with no published fields, we still have a document.\n      Meteor.call('clearUsernameAndProfile', expect(function() {\n        test.isTrue(Meteor.userId());\n        var user = Meteor.user();\n        test.equal(user, {_id: Meteor.userId()});\n      }));\n    },\n    logoutStep,\n    function(test, expect) {\n      var clientUser = Meteor.user();\n      test.equal(clientUser, null);\n      test.equal(Meteor.userId(), null);\n      Meteor.call('testMeteorUser', expect(function (err, result) {\n        test.equal(err, undefined);\n        test.equal(result, null);\n      }));\n    }\n  ]);\n\n  testAsyncMulti(\"passwords - allow rules\", [\n    // create a second user to have an id for in a later test\n    function (test, expect) {\n      this.otherUsername = Random.id();\n      Accounts.createUser(\n        {username: this.otherUsername, password: 'dontcare',\n         testOnCreateUserHook: true},\n        loggedInAs(this.otherUsername, test, expect));\n    },\n    function (test, expect) {\n      this.otherUserId = Meteor.userId();\n    },\n    function (test, expect) {\n      // real setup\n      this.username = Random.id();\n      this.password = 'password';\n\n      Accounts.createUser(\n        {username: this.username, password: this.password,\n         testOnCreateUserHook: true},\n        loggedInAs(this.username, test, expect));\n    },\n    // test the default Meteor.users allow rule. This test properly belongs in\n    // accounts-base/accounts_tests.js, but this is where the tests that\n    // actually log in are.\n    function(test, expect) {\n      this.userId = Meteor.userId();\n      test.notEqual(this.userId, null);\n      test.notEqual(this.userId, this.otherUserId);\n      // Can't update fields other than profile.\n      Meteor.users.update(\n        this.userId, {$set: {disallowed: true, 'profile.updated': 42}},\n        expect(function (err) {\n          test.isTrue(err);\n          test.equal(err.error, 403);\n          test.isFalse(_.has(Meteor.user(), 'disallowed'));\n          test.isFalse(_.has(Meteor.user().profile, 'updated'));\n        }));\n    },\n    function(test, expect) {\n      // Can't update another user.\n      Meteor.users.update(\n        this.otherUserId, {$set: {'profile.updated': 42}},\n        expect(function (err) {\n          test.isTrue(err);\n          test.equal(err.error, 403);\n        }));\n    },\n    function(test, expect) {\n      // Can't update using a non-ID selector. (This one is thrown client-side.)\n      test.throws(function () {\n        Meteor.users.update(\n          {username: this.username}, {$set: {'profile.updated': 42}});\n      });\n      test.isFalse(_.has(Meteor.user().profile, 'updated'));\n    },\n    function(test, expect) {\n      // Can update own profile using ID.\n      Meteor.users.update(\n        this.userId, {$set: {'profile.updated': 42}},\n        expect(function (err) {\n          test.isFalse(err);\n          test.equal(42, Meteor.user().profile.updated);\n        }));\n    },\n    logoutStep\n  ]);\n\n\n  testAsyncMulti(\"passwords - tokens\", [\n    function (test, expect) {\n      // setup\n      this.username = Random.id();\n      this.password = 'password';\n\n      Accounts.createUser(\n        {username: this.username, password: this.password},\n        loggedInAs(this.username, test, expect));\n    },\n\n    function(test, expect) {\n      // test logging out invalidates our token\n      var expectLoginError = expect(function (err) {\n        test.isTrue(err);\n      });\n      var token = Accounts._storedLoginToken();\n      test.isTrue(token);\n      Meteor.logout(function () {\n        Meteor.loginWithToken(token, expectLoginError);\n      });\n    },\n\n    function(test, expect) {\n      var self = this;\n      // Test that login tokens get expired. We should get logged out when a\n      // token expires, and not be able to log in again with the same token.\n      var expectNoError = expect(function (err) {\n        test.isFalse(err);\n      });\n\n      Meteor.loginWithPassword(this.username, this.password, function (error) {\n        self.token = Accounts._storedLoginToken();\n        test.isTrue(self.token);\n        expectNoError(error);\n        Meteor.call(\"expireTokens\");\n      });\n    },\n    waitForLoggedOutStep,\n    function (test, expect) {\n      var token = Accounts._storedLoginToken();\n      test.isFalse(token);\n    },\n    function (test, expect) {\n      // Test that once expireTokens is finished, we can't login again with our\n      // previous token.\n      Meteor.loginWithToken(this.token, expect(function (err, result) {\n        test.isTrue(err);\n        test.equal(Meteor.userId(), null);\n      }));\n    },\n    function (test, expect) {\n      var self = this;\n\n      // copied from livedata/client_convenience.js\n      var ddpUrl = '/';\n      if (typeof __meteor_runtime_config__ !== \"undefined\") {\n        if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)\n          ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n      }\n      // XXX can we get the url from the existing connection somehow\n      // instead?\n\n      // Test that Meteor.logoutOtherClients logs out a second authenticated\n      // connection while leaving Meteor.connection logged in.\n      var token;\n      var userId;\n      self.secondConn = DDP.connect(ddpUrl);\n\n      var expectLoginError = expect(function (err) {\n        test.isTrue(err);\n      });\n      var expectValidToken = expect(function (err, result) {\n        test.isFalse(err);\n        test.isTrue(result);\n        self.tokenFromLogoutOthers = result.token;\n      });\n      var expectSecondConnLoggedIn = expect(function (err, result) {\n        test.equal(result.token, token);\n        test.isFalse(err);\n        // This test will fail if an unrelated reconnect triggers before the\n        // connection is logged out. In general our tests aren't resilient to\n        // mid-test reconnects.\n        self.secondConn.onReconnect = function () {\n          self.secondConn.call(\"login\", { resume: token }, expectLoginError);\n        };\n        Meteor.call(\"logoutOtherClients\", expectValidToken);\n      });\n\n      Meteor.loginWithPassword(this.username, this.password, expect(function (err) {\n        test.isFalse(err);\n        token = Accounts._storedLoginToken();\n        self.beforeLogoutOthersToken = token;\n        test.isTrue(token);\n        userId = Meteor.userId();\n        self.secondConn.call(\"login\", { resume: token },\n                             expectSecondConnLoggedIn);\n      }));\n    },\n    // Test that logoutOtherClients logged out Meteor.connection and that the\n    // previous token is no longer valid.\n    waitForLoggedOutStep,\n    function (test, expect) {\n      var self = this;\n      var token = Accounts._storedLoginToken();\n      test.isFalse(token);\n      this.secondConn.close();\n      Meteor.loginWithToken(\n        self.beforeLogoutOthersToken,\n        expect(function (err) {\n          test.isTrue(err);\n          test.isFalse(Meteor.userId());\n        })\n      );\n    },\n    // Test that logoutOtherClients returned a new token that we can use to\n    // log in.\n    function (test, expect) {\n      var self = this;\n      Meteor.loginWithToken(\n        self.tokenFromLogoutOthers,\n        expect(function (err) {\n          test.isFalse(err);\n          test.isTrue(Meteor.userId());\n        })\n      );\n    },\n    logoutStep,\n    function (test, expect) {\n      var self = this;\n      // Test that deleting a user logs out that user's connections.\n      Meteor.loginWithPassword(this.username, this.password, expect(function (err) {\n        test.isFalse(err);\n        Meteor.call(\"removeUser\", self.username);\n      }));\n    },\n    waitForLoggedOutStep\n  ]);\n}) ();\n\n\nif (Meteor.isServer) (function () {\n\n  Tinytest.add(\n    'passwords - setup more than one onCreateUserHook',\n    function (test) {\n      test.throws(function() {\n        Accounts.onCreateUser(function () {});\n      });\n    });\n\n\n  Tinytest.add(\n    'passwords - createUser hooks',\n    function (test) {\n      var username = Random.id();\n      test.throws(function () {\n        // should fail the new user validators\n        Accounts.createUser({username: username, profile: {invalid: true}});\n      });\n\n      var userId = Accounts.createUser({username: username,\n                                        testOnCreateUserHook: true});\n\n      test.isTrue(userId);\n      var user = Meteor.users.findOne(userId);\n      test.equal(user.profile.touchedByOnCreateUser, true);\n    });\n\n\n  Tinytest.add(\n    'passwords - setPassword',\n    function (test) {\n      var username = Random.id();\n\n      var userId = Accounts.createUser({username: username});\n\n      var user = Meteor.users.findOne(userId);\n      // no services yet.\n      test.equal(user.services.password, undefined);\n\n      // set a new password.\n      Accounts.setPassword(userId, 'new password');\n      user = Meteor.users.findOne(userId);\n      var oldVerifier = user.services.password.srp;\n      test.isTrue(user.services.password.srp);\n\n      // reset with the same password, see we get a different verifier\n      Accounts.setPassword(userId, 'new password');\n      user = Meteor.users.findOne(userId);\n      var newVerifier = user.services.password.srp;\n      test.notEqual(oldVerifier.salt, newVerifier.salt);\n      test.notEqual(oldVerifier.identity, newVerifier.identity);\n      test.notEqual(oldVerifier.verifier, newVerifier.verifier);\n\n      // cleanup\n      Meteor.users.remove(userId);\n    });\n\n\n  // This test properly belongs in accounts-base/accounts_tests.js, but\n  // this is where the tests that actually log in are.\n  Tinytest.add('accounts - user() out of context', function (test) {\n    // basic server context, no method.\n    test.throws(function () {\n      Meteor.user();\n    });\n  });\n\n  // XXX would be nice to test Accounts.config({forbidClientAccountCreation: true})\n\n  Tinytest.addAsync(\n    'passwords - login tokens cleaned up',\n    function (test, onComplete) {\n      var username = Random.id();\n      Accounts.createUser({\n        username: username,\n        password: 'password'\n      });\n\n      makeTestConnection(\n        test,\n        function (clientConn, serverConn) {\n          serverConn.onClose(function () {\n            test.isFalse(_.contains(\n              Accounts._getTokenConnections(token), serverConn.id));\n            onComplete();\n          });\n          var result = clientConn.call('login', {\n            user: {username: username},\n            password: 'password'\n          });\n          test.isTrue(result);\n          var token = Accounts._getAccountData(serverConn.id, 'loginToken');\n          test.isTrue(token);\n          test.equal(result.token, token);\n          test.isTrue(_.contains(\n            Accounts._getTokenConnections(token), serverConn.id));\n          clientConn.disconnect();\n        },\n        onComplete\n      );\n    }\n  );\n}) ();\n","//\n// a mechanism to intercept emails sent to addressing including\n// the string \"intercept\", storing them in an array that can then\n// be retrieved using the getInterceptedEmails method\n//\nvar interceptedEmails = {}; // (email address) -> (array of contents)\n\nEmailTest.hookSend(function (options) {\n  var to = options.to;\n  if (to.indexOf('intercept') === -1) {\n    return true; // go ahead and send\n  } else {\n    if (!interceptedEmails[to])\n      interceptedEmails[to] = [];\n\n    interceptedEmails[to].push(options.text);\n    return false; // skip sending\n  }\n});\n\nMeteor.methods({\n  getInterceptedEmails: function (email) {\n    check(email, String);\n    return interceptedEmails[email];\n  },\n\n  addEmailForTestAndVerify: function (email) {\n    check(email, String);\n    Meteor.users.update(\n      {_id: this.userId},\n      {$push: {emails: {address: email, verified: false}}});\n    Accounts.sendVerificationEmail(this.userId, email);\n  },\n\n  createUserOnServer: function (email) {\n    check(email, String);\n    var userId = Accounts.createUser({email: email});\n    Accounts.sendEnrollmentEmail(userId);\n    return Meteor.users.findOne(userId);\n  }\n});\n"]}