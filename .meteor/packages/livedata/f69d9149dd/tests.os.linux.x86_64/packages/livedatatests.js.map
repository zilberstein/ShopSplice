{"version":3,"file":"/packages/livedata:tests.js","sources":["livedata/stub_stream.js","livedata/livedata_server_tests.js","livedata/livedata_connection_tests.js","livedata/livedata_tests.js","livedata/livedata_test_service.js","livedata/session_view_tests.js","livedata/crossbar_tests.js","livedata/stream_client_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,0B;AACA,kB;;AAEA,iB;AACA,sB;AACA,E;;;AAGA,gC;AACA,wB;AACA,iC;AACA,oB;;AAEA,8B;AACA,wC;AACA,Q;AACA,0C;AACA,I;;AAEA,yB;AACA,oB;AACA,yB;AACA,I;;AAEA,uB;AACA,6C;AACA,I;;AAEA,0B;AACA,Y;AACA,I;;;AAGA,sB;AACA,4B;AACA,oB;;AAEA,mC;AACA,mC;AACA,K;;AAEA,qD;AACA,e;AACA,O;AACA,I;;AAEA,sB;AACA,oB;AACA,mD;AACA,W;AACA,O;AACA,G;;;AAGA,G;;;;;;;;;;;;;;;;;;;ACtDA,kC;;;AAGA,kB;AACA,iD;AACA,+B;AACA,uB;AACA,W;AACA,yC;AACA,oE;AACA,wC;AACA,4B;AACA,8D;AACA,uC;AACA,0C;AACA,yB;AACA,a;AACA,W;AACA,gD;AACA,gC;AACA,Q;AACA,gB;AACA,M;AACA,G;AACA,E;;;AAGA,kB;AACA,+C;AACA,+B;AACA,uB;AACA,W;AACA,yC;AACA,qE;AACA,mB;AACA,uB;AACA,mD;AACA,Y;AACA,qB;AACA,uB;AACA,4F;AACA,yB;AACA,W;AACA,U;;AAEA,gD;AACA,2B;AACA,Q;AACA,gB;AACA,M;AACA,G;AACA,E;;;AAGA,e;AACA,oE;AACA,4B;AACA,0B;AACA,+B;AACA,2D;AACA,yB;AACA,yB;AACA,uB;AACA,wE;AACA,iC;AACA,yC;AACA,O;AACA,2D;AACA,8B;AACA,O;;AAEA,2B;AACA,oC;AACA,uB;AACA,W;AACA,yC;AACA,gD;AACA,gC;AACA,2B;AACA,Q;AACA,sB;AACA,M;AACA,I;AACA,E;;;AAGA,gB;AACA,2C;AACA,8B;AACA,I;;AAEA,2C;AACA,qD;AACA,G;AACA,G;;;AAGA,kB;AACA,sD;AACA,+B;AACA,uB;AACA,W;AACA,yC;AACA,gE;AACA,uC;AACA,gC;AACA,qB;AACA,Q;AACA,gB;AACA,M;AACA,G;AACA,E;;;AAGA,kB;AACA,6D;AACA,+B;AACA,uB;AACA,W;AACA,yC;AACA,gE;AACA,uC;AACA,gC;AACA,qB;AACA,Q;AACA,gB;AACA,M;AACA,G;AACA,E;;;AAGA,2B;AACA,wB;;AAEA,oE;AACA,8C;AACA,e;AACA,mB;AACA,c;AACA,G;;;AAGA,kB;AACA,qD;AACA,+B;AACA,uB;AACA,W;AACA,yC;AACA,iE;AACA,+C;AACA,gE;AACA,kC;AACA,uB;AACA,U;AACA,wE;AACA,O;AACA,M;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC9JA,uC;AACA,qE;AACA,0E;AACA,Y;AACA,4E;AACA,E;;AAEA,6C;AACA,a;AACA,mB;AACA,oD;AACA,gD;AACA,I;;AAEA,c;AACA,0B;AACA,a;AACA,C;;AAEA,wD;AACA,yB;;AAEA,iC;AACA,kE;AACA,kB;AACA,G;;AAEA,gC;;AAEA,8D;AACA,0B;;AAEA,2E;AACA,2E;AACA,c;AACA,qC;AACA,gC;AACA,sC;AACA,oB;AACA,mC;AACA,O;AACA,6C;AACA,2B;AACA,O;AACA,0C;AACA,0C;AACA,Y;AACA,uD;AACA,sB;AACA,S;AACA,K;AACA,G;;AAEA,4B;AACA,gB;AACA,E;;AAEA,8C;AACA,8C;;AAEA,qD;AACA,8B;;AAEA,0D;AACA,8B;AACA,E;;AAEA,sB;;AAEA,8D;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,0C;AACA,8B;AACA,kE;AACA,mC;AACA,yD;AACA,2D;;AAEA,+E;AACA,mB;AACA,oD;;AAEA,6C;AACA,6D;AACA,yD;;AAEA,gD;AACA,oE;AACA,kC;AACA,yD;AACA,6D;AACA,G;;AAEA,2D;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,c;AACA,6B;AACA,mD;AACA,0B;AACA,K;AACA,+B;;AAEA,8B;AACA,gD;AACA,sB;AACA,oB;AACA,iE;;AAEA,8B;AACA,gD;AACA,kC;AACA,K;AACA,gC;;AAEA,2C;AACA,+C;AACA,8B;AACA,e;AACA,+B;AACA,uB;;AAEA,iB;AACA,a;AACA,8B;AACA,4C;AACA,8C;;AAEA,iB;AACA,4B;AACA,8B;AACA,4C;AACA,uB;AACA,yB;AACA,oB;AACA,iE;AACA,G;;;AAGA,oE;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,qC;AACA,qC;;AAEA,wB;AACA,gC;AACA,wB;AACA,mC;AACA,4B;AACA,U;AACA,8B;AACA,M;AACA,I;;AAEA,4B;AACA,oB;AACA,gD;AACA,2D;AACA,2D;AACA,sD;AACA,kE;AACA,K;;AAEA,sE;AACA,8B;AACA,gD;AACA,0B;AACA,oB;AACA,mE;;AAEA,4C;AACA,0B;AACA,oB;AACA,mE;;AAEA,4C;AACA,+B;AACA,oB;AACA,mE;;AAEA,4C;AACA,6B;AACA,oB;AACA,iE;;AAEA,6B;AACA,+B;;AAEA,0D;AACA,wD;AACA,2C;AACA,8B;;AAEA,oB;AACA,uB;AACA,8B;AACA,4C;AACA,qD;;AAEA,2C;;AAEA,wE;AACA,kF;AACA,gF;AACA,6E;AACA,wE;AACA,mB;AACA,e;AACA,8B;;AAEA,4C;AACA,0B;AACA,oB;AACA,mE;;AAEA,4C;AACA,kC;AACA,oB;AACA,iE;;AAEA,4C;AACA,kD;;AAEA,2C;;AAEA,4E;AACA,+E;AACA,6E;AACA,yE;AACA,+E;AACA,kB;AACA,mE;AACA,gE;;AAEA,+E;AACA,U;AACA,uB;AACA,e;;AAEA,8B;AACA,+C;AACA,qD;AACA,yB;AACA,iE;AACA,+C;AACA,kE;AACA,mB;AACA,qB;AACA,qC;AACA,G;;;AAGA,sD;AACA,gC;AACA,mC;;AAEA,gC;AACA,uC;AACA,mC;AACA,wC;AACA,M;;AAEA,+B;AACA,qC;AACA,uC;AACA,gD;AACA,0D;AACA,mD;AACA,8B;;AAEA,8D;AACA,4D;;AAEA,G;;AAEA,sB;AACA,2D;AACA,kC;AACA,qC;;AAEA,kC;;AAEA,+B;AACA,mE;;AAEA,mB;AACA,8C;AACA,8B;AACA,Q;;AAEA,sB;AACA,8D;AACA,uC;AACA,oD;AACA,wD;AACA,wD;AACA,mD;AACA,S;;;AAGA,wC;AACA,+B;AACA,8D;AACA,4B;AACA,8B;AACA,4B;AACA,O;AACA,iC;;AAEA,oC;AACA,qE;;AAEA,+B;AACA,kD;AACA,+D;AACA,8D;;AAEA,yC;AACA,yD;AACA,qD;;AAEA,mE;AACA,a;AACA,mE;AACA,iC;;AAEA,yC;AACA,yC;AACA,yD;AACA,qE;;AAEA,sD;AACA,gG;AACA,iD;AACA,yC;AACA,yD;AACA,qE;;AAEA,+C;AACA,+B;AACA,kE;AACA,4B;AACA,O;AACA,iC;AACA,iC;;AAEA,oD;AACA,mD;AACA,qE;AACA,gE;;AAEA,iF;AACA,iF;AACA,0C;AACA,8D;AACA,gC;AACA,iC;;AAEA,yC;AACA,yD;AACA,qE;;AAEA,oB;AACA,qE;AACA,iC;;AAEA,wD;AACA,+D;AACA,gC;;AAEA,yC;AACA,qE;AACA,qE;;AAEA,kB;AACA,K;AACA,C;;AAEA,sE;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,4C;AACA,iB;AACA,M;;AAEA,iD;;AAEA,gE;AACA,gD;AACA,2D;AACA,6D;AACA,8B;AACA,G;;AAEA,6C;AACA,4D;AACA,uC;AACA,8B;AACA,kD;AACA,sD;AACA,sD;AACA,iD;AACA,O;AACA,U;AACA,sC;AACA,uC;AACA,2C;AACA,qC;AACA,S;AACA,yC;AACA,K;AACA,I;AACA,E;;AAEA,2D;AACA,sB;AACA,2E;AACA,kC;AACA,qC;;AAEA,kC;;AAEA,gC;AACA,oE;;AAEA,oB;AACA,kB;AACA,iC;AACA,uC;AACA,Q;AACA,sC;AACA,4B;AACA,O;AACA,O;;AAEA,6C;;AAEA,mB;AACA,0C;;AAEA,iD;AACA,kD;AACA,+D;AACA,qD;AACA,gC;;AAEA,qC;AACA,kC;AACA,uC;AACA,mC;AACA,mD;;AAEA,yB;AACA,kE;;AAEA,kF;AACA,6B;AACA,iG;AACA,iD;AACA,wB;AACA,wD;AACA,sE;AACA,6C;AACA,kC;AACA,wD;AACA,8C;AACA,wB;AACA,wD;;AAEA,6E;AACA,4B;AACA,8D;AACA,oC;AACA,oE;AACA,0E;;AAEA,a;AACA,K;AACA,C;AACA,4E;AACA,8B;AACA,mC;;AAEA,0B;AACA,kD;AACA,gC;AACA,K;AACA,iC;;AAEA,oD;AACA,yB;;AAEA,iB;AACA,iB;;AAEA,qD;AACA,oE;AACA,sD;AACA,G;;AAEA,2D;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,6B;AACA,iE;;AAEA,2C;;AAEA,c;AACA,+B;AACA,mD;AACA,4B;AACA,K;AACA,iC;;AAEA,mD;AACA,kE;AACA,8C;;AAEA,gC;AACA,qD;AACA,8C;;AAEA,uC;AACA,gC;AACA,iC;;AAEA,uD;AACA,8C;AACA,+B;AACA,sD;AACA,oB;AACA,gC;AACA,0E;;AAEA,+C;AACA,kC;;AAEA,iB;AACA,kC;AACA,yC;AACA,+B;AACA,K;;AAEA,gE;AACA,mD;;AAEA,oC;;AAEA,8D;AACA,sD;AACA,mE;AACA,+D;AACA,oC;;AAEA,+E;AACA,uD;AACA,8C;AACA,oE;AACA,kC;;AAEA,6E;AACA,2C;AACA,iB;;AAEA,+D;AACA,8C;AACA,2C;;AAEA,wC;AACA,8D;;AAEA,iE;AACA,qD;AACA,8D;AACA,qD;AACA,+C;AACA,oE;AACA,qC;AACA,sB;;AAEA,kC;AACA,iC;AACA,gD;AACA,oC;AACA,wE;AACA,+E;AACA,+B;AACA,oC;AACA,oC;;AAEA,qB;AACA,oE;AACA,qC;AACA,sB;;AAEA,mB;AACA,wD;;AAEA,8E;AACA,4C;AACA,mC;AACA,iC;AACA,0E;AACA,wD;AACA,4C;;AAEA,0D;AACA,4E;AACA,wE;AACA,oC;AACA,8E;AACA,oC;AACA,oE;;AAEA,wD;AACA,oC;AACA,2D;AACA,8E;AACA,0E;;AAEA,W;AACA,G;;;AAGA,sB;AACA,0F;AACA,gC;AACA,qC;AACA,kC;;AAEA,+B;AACA,mE;AACA,6C;;AAEA,+C;AACA,mB;AACA,gC;AACA,Q;;AAEA,mD;;AAEA,8E;AACA,4B;AACA,oC;AACA,oC;AACA,0D;AACA,qD;AACA,kB;AACA,uC;AACA,6C;AACA,kB;AACA,6B;AACA,mD;AACA,uD;AACA,kC;AACA,2B;AACA,mC;AACA,2C;AACA,mB;AACA,kC;AACA,6D;AACA,2C;AACA,sC;;AAEA,qB;AACA,uD;AACA,yF;AACA,8B;AACA,uC;AACA,8E;AACA,wB;;AAEA,sB;AACA,iE;AACA,uB;AACA,uC;AACA,8E;AACA,wB;AACA,oD;AACA,mC;AACA,gD;;AAEA,8E;AACA,kF;AACA,+D;AACA,mB;AACA,iE;AACA,6E;AACA,uC;AACA,8E;AACA,wB;AACA,mC;;AAEA,4E;AACA,4D;AACA,gE;AACA,uC;AACA,oC;AACA,wC;AACA,gD;AACA,uD;AACA,yF;AACA,2E;AACA,kC;;;;;AAKA,iF;AACA,6E;AACA,mD;AACA,oC;AACA,0D;AACA,qD;AACA,kB;AACA,uC;AACA,6C;AACA,kB;AACA,6B;AACA,mD;AACA,wD;AACA,kC;AACA,2B;AACA,wC;AACA,gD;AACA,mB;AACA,mC;AACA,6D;AACA,2C;AACA,sC;;AAEA,qB;AACA,uD;AACA,0F;AACA,8B;AACA,uC;AACA,gF;AACA,wB;;AAEA,sB;AACA,mE;AACA,uB;AACA,uC;AACA,gF;AACA,wB;AACA,oD;AACA,wC;AACA,wD;AACA,oC;AACA,sD;AACA,oC;AACA,S;AACA,M;;AAEA,kF;AACA,8E;AACA,8B;AACA,mB;AACA,qE;AACA,sC;AACA,mB;AACA,kE;AACA,6E;AACA,uC;AACA,gF;AACA,wB;AACA,wC;;AAEA,gF;AACA,gE;AACA,uC;AACA,gF;AACA,wB;AACA,wC;;AAEA,kE;AACA,uD;AACA,6F;AACA,wB;;AAEA,8E;AACA,gF;AACA,8E;AACA,oE;AACA,8D;AACA,uC;AACA,gF;AACA,oC;AACA,gD;;AAEA,sC;AACA,sE;AACA,wB;AACA,wD;;AAEA,a;AACA,K;AACA,C;AACA,sF;AACA,8B;AACA,mC;AACA,gC;;AAEA,6B;AACA,iE;AACA,2C;;AAEA,6E;AACA,e;AACA,0B;AACA,kC;AACA,4B;AACA,wD;AACA,mD;AACA,gB;AACA,qC;AACA,2C;AACA,gB;AACA,0B;AACA,iC;AACA,yC;AACA,iB;AACA,gC;AACA,qD;AACA,yC;AACA,oC;;AAEA,mB;AACA,qD;AACA,mD;AACA,kE;AACA,qC;AACA,6D;AACA,gC;;AAEA,+B;AACA,wD;AACA,qB;AACA,qC;AACA,6D;AACA,sB;AACA,oD;AACA,iC;AACA,yC;;AAEA,0E;AACA,gB;AACA,iB;AACA,+D;AACA,iB;AACA,qD;AACA,8C;AACA,2E;AACA,qC;AACA,6D;AACA,sB;AACA,iC;AACA,yC;;AAEA,iE;AACA,8D;AACA,qC;AACA,6D;AACA,sB;AACA,iC;AACA,yC;;AAEA,4E;AACA,2E;AACA,2B;AACA,+D;AACA,iC;AACA,8C;;AAEA,sE;AACA,wD;AACA,qC;AACA,kC;AACA,sC;AACA,8C;;AAEA,W;AACA,G;AACA,sB;AACA,2E;AACA,gC;AACA,qC;AACA,kC;;AAEA,+B;AACA,mE;AACA,6C;;AAEA,kB;AACA,oC;AACA,qB;AACA,kC;AACA,Q;AACA,+B;AACA,2C;AACA,O;AACA,O;;AAEA,uC;;AAEA,8B;AACA,6C;AACA,6B;AACA,mD;AACA,uD;AACA,kC;AACA,mB;AACA,wC;AACA,8D;AACA,2C;AACA,sC;;AAEA,0B;AACA,qD;AACA,sC;AACA,uC;AACA,2C;AACA,0D;AACA,oC;AACA,mB;AACA,wC;AACA,uD;AACA,wD;AACA,sC;;AAEA,8D;AACA,uD;AACA,0G;AACA,qF;AACA,8B;AACA,uC;AACA,2C;AACA,0D;AACA,wB;;AAEA,6E;AACA,uD;AACA,gE;AACA,uC;AACA,2C;AACA,0D;AACA,wB;;AAEA,gE;AACA,yD;AACA,6G;AACA,uC;AACA,2C;AACA,0D;AACA,wB;;AAEA,sD;AACA,gE;AACA,uC;AACA,2C;AACA,+D;AACA,0B;AACA,oC;;AAEA,a;AACA,K;AACA,C;;AAEA,sB;AACA,yF;AACA,mE;;AAEA,gC;AACA,qC;AACA,kC;;AAEA,+B;AACA,mE;;AAEA,kB;AACA,oC;AACA,qB;AACA,kC;AACA,O;AACA,O;;AAEA,uC;;AAEA,mC;AACA,mC;AACA,yB;AACA,sD;AACA,6C;AACA,6C;;;AAGA,6B;AACA,mD;AACA,uD;;AAEA,wB;AACA,uC;AACA,oD;AACA,2C;AACA,sC;;AAEA,2B;AACA,+D;AACA,uD;;AAEA,wB;AACA,sC;AACA,oD;AACA,2C;AACA,sC;;AAEA,0B;AACA,8D;AACA,sD;;AAEA,0B;AACA,wC;AACA,8D;AACA,2C;AACA,sC;;AAEA,4B;AACA,gE;AACA,wD;;AAEA,2B;AACA,mD;;AAEA,K;AACA,C;AACA,gE;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,uB;AACA,kC;AACA,4D;AACA,gD;AACA,wC;AACA,4B;AACA,8D;AACA,uD;AACA,mC;AACA,O;AACA,O;AACA,I;;AAEA,oC;AACA,mB;;AAEA,Y;AACA,wC;AACA,sC;AACA,6C;AACA,kD;AACA,O;AACA,K;;AAEA,iB;AACA,0B;;AAEA,wD;AACA,+C;AACA,kB;AACA,iC;AACA,e;AACA,kC;AACA,iB;AACA,0B;;AAEA,2D;AACA,qB;AACA,iC;AACA,e;AACA,kC;AACA,iB;AACA,0B;;AAEA,wD;AACA,sD;AACA,a;AACA,qB;AACA,iC;AACA,e;AACA,kC;AACA,iB;AACA,0B;;AAEA,4D;AACA,kB;AACA,e;AACA,iB;AACA,0B;AACA,G;;;;AAIA,uE;AACA,gC;AACA,mC;;AAEA,kC;AACA,uB;AACA,kC;AACA,G;;AAEA,wE;AACA,gC;AACA,mC;AACA,gC;;AAEA,6B;AACA,iE;;AAEA,iB;AACA,gD;;AAEA,qB;AACA,8E;AACA,oD;AACA,2C;;AAEA,iE;AACA,0B;AACA,K;AACA,uD;AACA,oC;;AAEA,qD;AACA,4B;AACA,K;AACA,oD;AACA,2B;AACA,K;;AAEA,kE;AACA,2B;AACA,K;;AAEA,8E;;AAEA,+E;AACA,Y;AACA,oC;;AAEA,gF;AACA,8B;AACA,qC;AACA,qD;AACA,8C;AACA,qC;AACA,sD;;AAEA,wE;AACA,sD;AACA,4B;AACA,8D;AACA,iC;;AAEA,+B;AACA,oD;AACA,2C;;AAEA,qC;AACA,oC;;AAEA,+E;AACA,S;AACA,uD;AACA,8C;AACA,qC;AACA,sD;;AAEA,8E;AACA,8D;AACA,iC;AACA,oC;AACA,6D;AACA,qC;AACA,4D;AACA,sD;AACA,wC;;AAEA,kE;AACA,oC;AACA,oC;AACA,sD;AACA,+C;AACA,qD;AACA,6C;;AAEA,sD;AACA,wD;AACA,uD;AACA,+D;AACA,gD;AACA,oC;;AAEA,0B;AACA,gE;AACA,yD;;AAEA,6D;AACA,oC;AACA,qD;AACA,6C;AACA,yD;;AAEA,qB;AACA,uD;AACA,+D;AACA,iE;;AAEA,oD;AACA,2C;AACA,G;;AAEA,iH;AACA,gC;AACA,mC;AACA,gC;;AAEA,iB;AACA,gD;;AAEA,iC;AACA,+D;AACA,8D;AACA,4E;AACA,gE;AACA,I;;AAEA,kD;AACA,gE;AACA,oD;;AAEA,c;AACA,mB;AACA,iB;AACA,wE;;AAEA,mE;AACA,oE;AACA,6C;AACA,+C;AACA,qC;AACA,2C;;AAEA,oB;AACA,oE;AACA,gE;AACA,uC;AACA,Q;AACA,O;AACA,iD;AACA,8B;AACA,wC;AACA,oB;AACA,sB;AACA,K;AACA,G;;AAEA,wC;AACA,wB;AACA,8C;AACA,U;AACA,gC;AACA,G;AACA,E;;AAEA,sB;AACA,kB;AACA,6B;AACA,oE;AACA,yD;AACA,K;AACA,K;AACA,C;;AAEA,yE;AACA,2B;AACA,oB;AACA,kD;AACA,mC;AACA,0C;AACA,oF;AACA,I;AACA,2B;AACA,oB;AACA,+C;AACA,sB;AACA,mE;AACA,+B;AACA,U;AACA,K;AACA,I;AACA,2B;AACA,oB;AACA,sB;AACA,yD;AACA,mE;AACA,qC;AACA,U;AACA,K;AACA,G;AACA,G;;AAEA,qF;AACA,+C;AACA,wE;AACA,gC;AACA,8E;AACA,+E;AACA,8B;AACA,8E;AACA,wD;AACA,mB;AACA,K;AACA,K;AACA,G;;AAEA,oE;AACA,+C;AACA,wE;AACA,gC;AACA,sD;AACA,iD;AACA,uD;AACA,iF;AACA,kD;AACA,mB;AACA,M;AACA,8B;AACA,kB;AACA,mB;AACA,K;AACA,K;AACA,G;;AAEA,oH;AACA,gC;AACA,mC;AACA,gC;;AAEA,iB;AACA,gD;;AAEA,iC;AACA,8D;AACA,8D;AACA,gE;AACA,I;;AAEA,kD;AACA,gE;AACA,kE;AACA,mD;;AAEA,c;AACA,mB;AACA,iB;AACA,wE;;AAEA,mE;AACA,oE;AACA,6C;AACA,+C;AACA,qC;AACA,oE;;AAEA,oB;AACA,oE;AACA,gE;AACA,uC;AACA,Q;AACA,O;AACA,0E;AACA,oB;AACA,sB;AACA,qB;AACA,K;AACA,G;;AAEA,qF;AACA,gC;AACA,mC;AACA,gC;;AAEA,iB;AACA,gD;;AAEA,iC;AACA,oE;AACA,I;;AAEA,kD;;AAEA,oB;AACA,mB;AACA,iB;AACA,iB;AACA,2D;;AAEA,8C;AACA,+B;AACA,yD;AACA,gD;;AAEA,gB;AACA,2D;AACA,8B;;AAEA,wC;AACA,8D;AACA,8B;;AAEA,6C;AACA,uD;;AAEA,iB;AACA,yD;AACA,8C;AACA,G;;;;AAIA,8E;AACA,8B;AACA,mC;AACA,gC;;AAEA,kB;AACA,kC;AACA,4E;AACA,+B;AACA,O;AACA,I;;AAEA,wE;AACA,2B;AACA,K;;AAEA,yB;AACA,iB;AACA,iC;AACA,0D;AACA,yC;AACA,oC;;AAEA,sD;AACA,gE;AACA,yB;AACA,yB;;AAEA,+E;AACA,+D;AACA,iB;AACA,+D;AACA,mC;AACA,4D;AACA,yC;AACA,8B;AACA,wE;AACA,yB;;AAEA,iE;AACA,qB;AACA,8D;AACA,yB;;AAEA,4E;AACA,8E;AACA,Y;AACA,2D;AACA,wC;AACA,yB;;AAEA,uD;AACA,kE;AACA,0C;AACA,yB;;AAEA,uE;AACA,8E;AACA,4E;AACA,sC;AACA,8B;AACA,6E;AACA,G;;AAEA,kE;AACA,gC;AACA,mC;;AAEA,gC;;AAEA,c;AACA,2B;AACA,sB;AACA,0C;AACA,0B;AACA,0B;AACA,M;AACA,+B;AACA,uB;AACA,K;AACA,K;AACA,6B;AACA,6B;;AAEA,mD;AACA,qE;AACA,8C;;AAEA,oB;AACA,kD;AACA,2E;AACA,6B;AACA,0C;AACA,kC;AACA,wD;;AAEA,6B;AACA,iB;AACA,uB;AACA,+D;AACA,qE;AACA,8B;AACA,6B;AACA,G;;AAEA,sB;AACA,0E;AACA,kC;AACA,qC;;AAEA,+B;AACA,mE;;AAEA,qE;AACA,gD;;AAEA,uD;AACA,gC;;AAEA,2D;AACA,mD;AACA,uC;AACA,sD;AACA,wC;AACA,wD;AACA,iF;AACA,+D;AACA,sD;AACA,gC;;AAEA,iE;AACA,qC;AACA,4D;AACA,gC;AACA,uC;;AAEA,+E;AACA,c;AACA,kE;AACA,gC;AACA,uC;AACA,K;AACA,C;AACA,iB;AACA,oC;AACA,2B;AACA,oB;AACA,gE;;;;;;;;;;;;;;;;;;;AC9jDA,+B;AACA,6C;AACA,mC;AACA,kC;AACA,oD;AACA,6C;AACA,qC;AACA,6C;AACA,8C;AACA,mD;AACA,mE;AACA,kE;AACA,c;AACA,uC;AACA,sC;AACA,wC;AACA,O;AACA,K;AACA,I;AACA,E;;AAEA,yD;AACA,0D;AACA,uC;AACA,gC;AACA,+B;AACA,sC;AACA,uC;AACA,G;;AAEA,sB;AACA,kE;AACA,4E;AACA,iB;AACA,sE;AACA,kB;AACA,M;;AAEA,wD;AACA,mD;AACA,mD;AACA,8D;AACA,K;AACA,C;;AAEA,yE;AACA,sB;AACA,a;AACA,wB;AACA,oB;;AAEA,2B;AACA,sB;AACA,K;AACA,G;;AAEA,gC;AACA,kC;AACA,0B;AACA,oD;AACA,qD;AACA,K;AACA,wB;AACA,uD;;AAEA,gF;AACA,iF;AACA,I;AACA,E;;AAEA,sD;AACA,oB;AACA,2B;AACA,0B;AACA,sD;AACA,W;AACA,gD;AACA,mB;AACA,iC;AACA,yB;AACA,O;AACA,yB;AACA,iC;AACA,K;;AAEA,0B;AACA,4D;AACA,8C;AACA,iC;AACA,K;;AAEA,wE;AACA,2C;AACA,0E;AACA,+B;AACA,I;;AAEA,2B;AACA,qE;AACA,oE;AACA,qB;AACA,wB;AACA,oD;AACA,wB;AACA,oD;;AAEA,gF;AACA,I;;AAEA,2B;AACA,wB;AACA,0C;AACA,wB;AACA,iD;;AAEA,sE;AACA,I;;AAEA,uB;AACA,4C;AACA,sC;AACA,6C;AACA,kD;AACA,mC;AACA,oC;AACA,e;AACA,qB;AACA,sB;;AAEA,2B;AACA,wB;AACA,kE;AACA,wB;AACA,8D;;AAEA,+C;AACA,yE;AACA,I;;AAEA,yC;AACA,2B;AACA,0B;AACA,2B;AACA,8B;AACA,mB;AACA,0E;AACA,iC;AACA,Y;AACA,qE;AACA,K;AACA,I;;AAEA,wC;AACA,0B;AACA,0B;AACA,8B;AACA,mB;AACA,yE;AACA,gC;AACA,Y;AACA,qE;AACA,K;AACA,I;;AAEA,2B;AACA,kB;;AAEA,0B;AACA,+B;AACA,yC;AACA,S;AACA,+B;AACA,2C;AACA,S;AACA,6D;AACA,gE;AACA,K;;AAEA,0B;AACA,gE;AACA,mE;AACA,yB;AACA,8D;AACA,gE;AACA,gE;AACA,K;;AAEA,oB;;AAEA,0B;AACA,iB;AACA,wC;AACA,yE;AACA,mB;AACA,iB;AACA,0C;AACA,yE;AACA,mB;AACA,gE;AACA,K;;AAEA,0B;AACA,iB;AACA,wC;AACA,gF;AACA,mB;AACA,iB;AACA,0C;AACA,gF;AACA,mB;AACA,gE;AACA,K;AACA,I;;AAEA,2B;AACA,0B;AACA,wB;AACA,W;AACA,2D;AACA,mB;AACA,qB;AACA,iC;AACA,8D;AACA,O;AACA,yB;AACA,oB;AACA,W;AACA,yD;AACA,qE;AACA,mB;AACA,qB;AACA,iC;AACA,8D;AACA,O;AACA,yB;AACA,K;;AAEA,0B;AACA,iB;AACA,0D;AACA,6C;AACA,sE;AACA,mB;AACA,iB;AACA,4D;AACA,6C;AACA,sE;AACA,mB;AACA,iB;AACA,2D;AACA,sE;AACA,6C;AACA,sE;AACA,mB;AACA,K;AACA,G;AACA,G;;;;;AAKA,2C;AACA,mE;AACA,+D;AACA,+B;AACA,6B;AACA,E;;AAEA,sE;AACA,kE;AACA,+C;AACA,2B;AACA,wB;AACA,yD;;AAEA,qE;AACA,0C;AACA,kE;AACA,0C;AACA,I;AACA,2B;AACA,oE;AACA,8C;AACA,6C;AACA,gD;AACA,8C;AACA,oB;AACA,gC;AACA,I;AACA,2B;AACA,2E;AACA,+C;AACA,kD;AACA,mE;AACA,8C;AACA,oB;;AAEA,wB;AACA,oE;AACA,iB;AACA,oC;AACA,Q;AACA,kC;AACA,G;AACA,G;;AAEA,qE;AACA,kE;AACA,iD;AACA,E;AACA,oE;AACA,kE;AACA,yD;AACA,iE;AACA,iC;AACA,6D;;AAEA,mE;AACA,qE;AACA,4B;AACA,I;AACA,oE;AACA,yB;AACA,sD;AACA,+D;AACA,yB;AACA,K;AACA,2B;AACA,I;;AAEA,qB;AACA,2D;AACA,I;AACA,E;;AAEA,sB;AACA,uG;AACA,4B;AACA,wB;AACA,gD;AACA,yD;;AAEA,6D;AACA,uE;AACA,+B;AACA,8D;AACA,gE;AACA,gE;AACA,wC;AACA,0C;AACA,yC;AACA,kC;AACA,sC;AACA,yC;AACA,wC;AACA,c;AACA,yD;AACA,W;AACA,uE;AACA,2E;AACA,yC;AACA,+E;AACA,mC;AACA,8C;AACA,4E;AACA,Q;;AAEA,sE;AACA,0B;AACA,8E;;AAEA,8D;AACA,gD;AACA,4E;AACA,U;;AAEA,mD;AACA,8B;AACA,6B;AACA,iC;AACA,mC;AACA,6E;AACA,S;;AAEA,oD;AACA,8B;AACA,iC;AACA,iC;AACA,6B;AACA,+B;AACA,4E;AACA,S;;AAEA,mD;AACA,iE;AACA,6D;AACA,8B;AACA,iC;AACA,iC;AACA,6B;AACA,+B;AACA,wB;AACA,S;AACA,+B;AACA,4B;AACA,kD;AACA,+E;AACA,+E;AACA,2E;AACA,0B;AACA,kC;AACA,U;AACA,iB;AACA,8E;AACA,K;AACA,K;AACA,C;;AAEA,mF;AACA,wB;AACA,uE;AACA,yE;AACA,G;AACA,G;;;AAGA,sB;AACA,sB;AACA,E;AACA,gB;AACA,oC;AACA,sB;AACA,0B;AACA,0B;AACA,6C;AACA,mC;AACA,qB;AACA,S;AACA,6C;AACA,mC;AACA,qB;AACA,S;;AAEA,K;AACA,I;AACA,qC;AACA,sB;AACA,0B;;AAEA,6E;AACA,e;AACA,K;AACA,a;AACA,I;AACA,qC;AACA,sB;AACA,0B;AACA,8E;AACA,e;AACA,K;AACA,a;AACA,G;AACA,G;;AAEA,sB;AACA,gB;AACA,iB;AACA,yB;AACA,gE;AACA,+B;AACA,kE;AACA,Q;AACA,+B;AACA,oE;AACA,uE;AACA,uE;AACA,Q;AACA,+B;AACA,8F;AACA,Q;AACA,+B;AACA,mE;AACA,Q;AACA,+B;AACA,8F;AACA,Q;AACA,+B;AACA,4E;AACA,O;AACA,O;AACA,O;AACA,E;;AAEA,sB;AACA,2D;AACA,6B;AACA,mE;AACA,8B;AACA,wC;AACA,uE;AACA,0B;AACA,yC;AACA,U;AACA,K;AACA,K;;AAEA,+D;AACA,6B;AACA,6D;AACA,8B;AACA,wC;AACA,+E;AACA,0B;AACA,yC;AACA,U;AACA,K;AACA,K;;AAEA,2D;AACA,6B;AACA,0E;AACA,0B;AACA,4B;AACA,U;AACA,K;AACA,K;;AAEA,8D;AACA,sE;AACA,oC;AACA,+C;AACA,2E;AACA,+B;AACA,mE;AACA,uB;AACA,oC;AACA,Y;AACA,+B;AACA,+C;AACA,gE;AACA,8B;AACA,4B;AACA,2B;AACA,wD;AACA,qE;AACA,gE;AACA,a;AACA,U;AACA,6C;AACA,kE;AACA,6C;AACA,kE;AACA,yC;AACA,8D;AACA,Q;AACA,+B;AACA,2C;AACA,sE;;AAEA,yC;AACA,8D;AACA,4B;AACA,qC;AACA,mC;AACA,W;AACA,W;AACA,Q;AACA,+B;AACA,6E;AACA,2C;AACA,qC;AACA,sE;AACA,4D;AACA,Q;AACA,+B;AACA,0E;AACA,iD;AACA,2C;AACA,oC;AACA,sD;AACA,8C;AACA,4D;AACA,sE;;AAEA,4E;AACA,6D;AACA,W;AACA,8E;AACA,4E;AACA,wC;AACA,mD;AACA,Q;AACA,+B;AACA,2C;AACA,0C;AACA,0C;AACA,sE;AACA,oD;AACA,O;AACA,Y;;AAEA,2D;AACA,+B;AACA,uD;AACA,uC;AACA,8C;AACA,8C;AACA,a;AACA,4B;AACA,W;AACA,Q;AACA,+B;AACA,oD;AACA,6B;AACA,sE;AACA,W;AACA,Q;AACA,+B;AACA,0D;AACA,6B;AACA,sE;AACA,W;AACA,O;AACA,O;AACA,C;;AAEA,6B;AACA,kE;;AAEA,sB;AACA,kB;AACA,2B;AACA,yB;AACA,0B;AACA,K;AACA,K;AACA,C;AACA,c;AACA,0E;AACA,6B;AACA,sB;AACA,uC;AACA,qC;AACA,4C;AACA,gB;AACA,M;;AAEA,6B;AACA,sB;AACA,yC;AACA,iE;AACA,kB;AACA,sB;AACA,qC;AACA,Y;AACA,O;AACA,K;AACA,K;AACA,K;;AAEA,sB;AACA,gB;AACA,8E;AACA,+B;AACA,wB;AACA,yC;AACA,uC;AACA,8C;AACA,kB;AACA,Q;;AAEA,+B;AACA,wB;AACA,2C;AACA,8D;AACA,S;AACA,O;AACA,O;AACA,O;AACA,C;;AAEA,c;AACA,+D;AACA,6B;AACA,sB;AACA,6C;AACA,4C;AACA,oE;AACA,e;AACA,K;AACA,K;AACA,K;;;AAGA,6C;AACA,6B;AACA,Y;AACA,uD;AACA,4C;AACA,iC;AACA,oD;AACA,0B;AACA,mC;AACA,sE;AACA,6C;AACA,e;AACA,oD;AACA,sE;AACA,uB;;;;;;;;;;;;;;;;;;;ACpsBA,gB;AACA,wB;AACA,kD;AACA,I;AACA,oC;AACA,kC;AACA,gC;AACA,I;AACA,qC;AACA,kC;AACA,wB;AACA,I;AACA,wC;AACA,yB;AACA,mC;AACA,wC;AACA,iD;AACA,Q;AACA,4B;AACA,qB;AACA,gD;AACA,gD;AACA,uB;;AAEA,sB;AACA,Y;AACA,2B;AACA,mE;AACA,U;AACA,2D;AACA,wB;;AAEA,0E;AACA,sB;AACA,0D;AACA,kD;AACA,2B;AACA,sB;AACA,qB;AACA,O;AACA,c;AACA,K;AACA,I;AACA,+B;AACA,6C;AACA,2B;AACA,G;AACA,G;;AAEA,+E;AACA,+E;AACA,+E;AACA,+E;AACA,mD;AACA,sB;AACA,gF;AACA,W;AACA,mB;;AAEA,iC;AACA,0D;;AAEA,2D;AACA,0E;AACA,gC;AACA,gB;AACA,a;AACA,0B;AACA,yC;AACA,I;;AAEA,kB;AACA,kC;AACA,2B;AACA,qC;AACA,6B;AACA,6C;AACA,2C;AACA,gB;AACA,Q;;AAEA,qB;AACA,kC;AACA,M;AACA,4D;AACA,2B;AACA,kC;AACA,kB;AACA,8D;AACA,iC;AACA,wC;AACA,K;AACA,K;AACA,C;;AAEA,O;;AAEA,yC;AACA,c;AACA,sC;AACA,sC;AACA,sC;AACA,W;AACA,G;;AAEA,4B;AACA,sB;AACA,iE;AACA,G;;AAEA,oB;AACA,6C;AACA,yB;AACA,uC;AACA,K;;AAEA,gB;AACA,0E;AACA,yB;AACA,6B;AACA,2B;AACA,0B;AACA,0C;AACA,+D;AACA,2D;;AAEA,wB;AACA,oB;;AAEA,c;AACA,iC;AACA,8E;;AAEA,Y;AACA,iC;AACA,4E;;AAEA,wC;AACA,wD;;AAEA,wD;AACA,qD;AACA,G;AACA,G;;AAEA,O;;AAEA,oE;;AAEA,6D;;AAEA,sB;AACA,8B;AACA,yE;AACA,2E;AACA,oF;AACA,oF;AACA,2E;AACA,2E;;AAEA,iD;AACA,6D;AACA,8D;AACA,K;;AAEA,gB;AACA,+B;AACA,yD;AACA,yB;AACA,sB;AACA,8B;AACA,6C;AACA,S;AACA,O;;AAEA,oB;AACA,yC;AACA,2B;AACA,sC;AACA,O;AACA,O;AACA,O;AACA,C;;AAEA,O;;AAEA,iE;;AAEA,sB;AACA,6B;AACA,2D;AACA,S;AACA,uC;AACA,iB;AACA,0D;AACA,K;AACA,K;AACA,C;;AAEA,sD;;AAEA,sB;AACA,kB;AACA,wC;AACA,qB;AACA,wB;AACA,uC;AACA,W;AACA,gF;AACA,mB;AACA,+C;AACA,mB;AACA,qB;AACA,O;AACA,qD;AACA,K;AACA,K;AACA,C;;AAEA,O;;AAEA,sD;;AAEA,sB;AACA,c;AACA,8C;AACA,wC;;AAEA,qC;AACA,wC;AACA,uB;AACA,8C;AACA,gC;AACA,kD;AACA,8C;AACA,W;AACA,S;AACA,O;;AAEA,oB;AACA,6C;AACA,6B;AACA,wD;AACA,yC;AACA,W;AACA,wD;AACA,yC;AACA,W;AACA,wD;AACA,uC;AACA,W;AACA,O;AACA,O;AACA,O;AACA,C;;AAEA,0D;;AAEA,sB;AACA,kB;AACA,mD;AACA,2B;AACA,wC;AACA,oD;AACA,S;AACA,K;AACA,K;AACA,C;;AAEA,4C;;AAEA,sB;AACA,kE;AACA,4B;AACA,kD;AACA,2B;AACA,mB;;AAEA,gF;AACA,gF;AACA,gF;AACA,gD;AACA,gB;;AAEA,gC;AACA,iB;AACA,a;AACA,K;;AAEA,c;AACA,gC;AACA,kC;AACA,0C;AACA,Y;AACA,sD;AACA,K;AACA,iC;AACA,kB;AACA,wC;AACA,uB;AACA,4C;AACA,qB;AACA,oB;AACA,oC;AACA,gC;AACA,yB;AACA,S;AACA,K;AACA,K;AACA,C;;;AAGA,O;;AAEA,qD;AACA,6C;AACA,6C;;AAEA,sB;AACA,iB;AACA,+B;AACA,+B;;AAEA,iB;AACA,+B;AACA,+B;AACA,+B;;AAEA,qD;AACA,kD;AACA,2B;AACA,yB;AACA,c;AACA,mB;AACA,kB;AACA,Q;AACA,6B;AACA,yD;AACA,8B;AACA,c;AACA,mB;AACA,kF;AACA,kB;AACA,Q;AACA,mC;AACA,yD;AACA,8B;AACA,c;AACA,mB;AACA,uB;AACA,kB;AACA,Q;AACA,U;AACA,iC;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACnWA,8B;AACA,mB;AACA,6D;AACA,8C;AACA,2D;AACA,M;AACA,iD;AACA,6B;AACA,e;AACA,+D;AACA,M;AACA,wC;AACA,6C;AACA,K;AACA,K;AACA,W;AACA,e;AACA,oB;AACA,I;AACA,yD;AACA,mC;AACA,K;AACA,sC;AACA,wC;AACA,I;AACA,kC;AACA,4B;AACA,I;AACA,wB;AACA,sB;AACA,iB;AACA,e;AACA,I;AACA,W;AACA,E;;AAEA,wE;AACA,wB;;AAEA,yB;AACA,uD;AACA,qB;;AAEA,yB;AACA,qB;;AAEA,uB;AACA,qB;;AAEA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,8F;AACA,wB;;AAEA,iC;AACA,+D;AACA,qB;;AAEA,2C;AACA,oE;;AAEA,uB;AACA,qB;;AAEA,uB;AACA,6C;AACA,qB;AACA,G;;;AAGA,uE;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,oC;AACA,uB;AACA,oE;AACA,qB;AACA,2E;AACA,4C;;AAEA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,uE;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,yC;AACA,oE;AACA,qB;;AAEA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,sE;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,yC;AACA,wE;AACA,qB;;AAEA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,mF;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,qC;AACA,qE;AACA,qB;AACA,G;;AAEA,2E;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,uB;AACA,6C;AACA,qB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,G;;AAEA,6E;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;;AAGA,oC;AACA,yC;AACA,oE;AACA,qB;;AAEA,uB;AACA,qB;AACA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,uG;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;;AAGA,oC;AACA,oB;AACA,+B;AACA,iC;AACA,6D;AACA,0C;AACA,iC;AACA,mF;AACA,kB;AACA,G;AACA,qC;AACA,qB;;AAEA,uB;AACA,qB;AACA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,0G;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;;AAGA,0B;;AAEA,qC;AACA,qB;;AAEA,uB;AACA,qB;AACA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,qF;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,oC;AACA,oC;AACA,yC;AACA,yC;AACA,yC;AACA,wE;AACA,qB;;AAEA,uB;AACA,qB;AACA,uB;AACA,qB;AACA,G;;AAEA,uF;AACA,wB;;AAEA,oC;AACA,iE;AACA,qB;;AAEA,oC;AACA,oC;AACA,qC;AACA,qC;AACA,qC;AACA,oE;AACA,qB;;AAEA,uB;AACA,qB;AACA,uB;AACA,qB;AACA,G;;AAEA,kG;AACA,wB;;AAEA,iD;AACA,8E;AACA,qB;;;AAGA,oC;AACA,yE;AACA,oG;AACA,qB;;AAEA,uB;AACA,0E;AACA,qB;AACA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,iF;AACA,wB;;AAEA,iD;AACA,8E;AACA,qB;;;AAGA,mC;AACA,iE;AACA,yE;AACA,wG;AACA,qB;;AAEA,uB;AACA,6C;AACA,qB;AACA,uB;AACA,6C;AACA,qB;;AAEA,G;;AAEA,gF;AACA,wB;;AAEA,iD;AACA,8E;AACA,qB;;;AAGA,mC;AACA,iE;AACA,qB;;AAEA,uB;AACA,6C;AACA,uB;AACA,6C;AACA,qB;AACA,G;;;AAGA,+E;AACA,wB;;AAEA,iD;AACA,8E;AACA,qB;;AAEA,oC;AACA,kE;;AAEA,oC;AACA,yE;AACA,oG;AACA,qB;;AAEA,uB;AACA,uB;AACA,0E;AACA,6C;AACA,qB;AACA,uB;AACA,6C;AACA,qB;AACA,G;;AAEA,gF;AACA,wB;;AAEA,oC;AACA,iE;;AAEA,qC;AACA,qE;;AAEA,uB;AACA,wE;;AAEA,uB;AACA,6C;AACA,G;;AAEA,0E;AACA,wB;;AAEA,0B;AACA,uD;;AAEA,8C;AACA,4E;AACA,G;;AAEA,gF;AACA,wB;;AAEA,uC;AACA,qE;AACA,qB;;AAEA,2C;AACA,0E;AACA,qB;;AAEA,2C;AACA,qB;;AAEA,G;;;;;;;;;;;;;;;;;;;ACxYA,8D;AACA,qE;AACA,oE;AACA,mE;AACA,mE;AACA,uE;AACA,yC;AACA,qD;AACA,yC;AACA,kD;AACA,oD;AACA,2D;AACA,oD;AACA,kD;AACA,6D;AACA,2D;AACA,oD;;AAEA,4D;AACA,8D;AACA,G;;;;;;;;;;;;;;;;;;;ACpBA,kC;;AAEA,2F;AACA,yC;AACA,yB;AACA,K;AACA,iC;AACA,mC;AACA,qB;AACA,O;AACA,K;AACA,I;AACA,kC;AACA,+B;AACA,wB;AACA,K;AACA,G","sourcesContent":["StubStream = function () {\n  var self = this;\n\n  self.sent = [];\n  self.callbacks = {};\n};\n\n\n_.extend(StubStream.prototype, {\n  // Methods from Stream\n  on: function (name, callback) {\n    var self = this;\n\n    if (!self.callbacks[name])\n      self.callbacks[name] = [callback];\n    else\n      self.callbacks[name].push(callback);\n  },\n\n  send: function (data) {\n    var self = this;\n    self.sent.push(data);\n  },\n\n  status: function () {\n    return {status: \"connected\", fake: true};\n  },\n\n  reconnect: function () {\n    // no-op\n  },\n\n\n  // Methods for tests\n  receive: function (data) {\n    var self = this;\n\n    if (typeof data === 'object') {\n      data = EJSON.stringify(data);\n    }\n\n    _.each(self.callbacks['message'], function (cb) {\n      cb(data);\n    });\n  },\n\n  reset: function () {\n    var self = this;\n    _.each(self.callbacks['reset'], function (cb) {\n      cb();\n    });\n  }\n\n\n});\n","var Fiber = Npm.require('fibers');\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.onClose()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // On the server side, wait for the connection to be closed.\n        serverConn.onClose(function () {\n          test.isTrue(true);\n          // Add a new onClose after the connection is already\n          // closed. See that it fires.\n          serverConn.onClose(function () {\n            onComplete();\n          });\n        });\n        // Close the connection from the client.\n        clientConn.disconnect();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.close()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Wait for the connection to be closed from the server side.\n        simplePoll(\n          function () {\n            return ! clientConn.status().connected;\n          },\n          onComplete,\n          function () {\n            test.fail(\"timeout waiting for the connection to be closed on the server side\");\n            onComplete();\n          }\n        );\n\n        // Close the connection from the server.\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\n\ntestAsyncMulti(\n  \"livedata server - onConnection doesn't get callback after stop.\",\n  [function (test, expect) {\n    var afterStop = false;\n    var expectStop1 = expect();\n    var stopHandle1 = Meteor.onConnection(function (conn) {\n      stopHandle2.stop();\n      stopHandle1.stop();\n      afterStop = true;\n      // yield to the event loop for a moment to see that no other calls\n      // to listener2 are called.\n      Meteor.setTimeout(expectStop1, 10);\n    });\n    var stopHandle2 = Meteor.onConnection(function (conn) {\n      test.isFalse(afterStop);\n    });\n\n    // trigger a connection\n    var expectConnection = expect();\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Close the connection from the client.\n        clientConn.disconnect();\n        expectConnection();\n      },\n      expectConnection\n    );\n  }]\n);\n\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_inner');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in nested method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_outer');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback)\n    callback(this);\n  this.stop();\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (subscription) {\n          delete onSubscription[serverConn.id];\n          test.equal(subscription.connection.id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n      }\n    );\n  }\n);\n","var newConnection = function (stream) {\n  // Some of these tests leave outstanding methods with no result yet\n  // returned. This should not block us from re-running tests when sources\n  // change.\n  return new LivedataTest.Connection(stream, {reloadWithOutstanding: true});\n};\n\nvar makeConnectMessage = function (session) {\n  var msg = {\n    msg: 'connect',\n    version: LivedataTest.SUPPORTED_DDP_VERSIONS[0],\n    support: LivedataTest.SUPPORTED_DDP_VERSIONS\n  };\n\n  if (session)\n    msg.session = session;\n  return msg;\n}\n\nvar testGotMessage = function (test, stream, expected) {\n  var retVal = undefined;\n\n  if (stream.sent.length === 0) {\n    test.fail({error: 'no message received', expected: expected});\n    return retVal;\n  }\n\n  var got = stream.sent.shift();\n\n  if (typeof got === 'string' && typeof expected === 'object')\n    got = JSON.parse(got);\n\n  // An expected value of '*' matches any value, and the matching value (or\n  // array of matching values, if there are multiple) is returned from this\n  // function.\n  if (typeof expected === 'object') {\n    var keysWithStarValues = [];\n    _.each(expected, function (v, k) {\n      if (v === '*')\n        keysWithStarValues.push(k);\n    });\n    _.each(keysWithStarValues, function (k) {\n      expected[k] = got[k];\n    });\n    if (keysWithStarValues.length === 1) {\n      retVal = got[keysWithStarValues[0]];\n    } else {\n      retVal = _.map(keysWithStarValues, function (k) {\n        return got[k];\n      });\n    }\n  }\n\n  test.equal(got, expected);\n  return retVal;\n};\n\nvar startAndConnect = function(test, stream) {\n  stream.reset(); // initial connection start.\n\n  testGotMessage(test, stream, makeConnectMessage());\n  test.length(stream.sent, 0);\n\n  stream.receive({msg: 'connected', session: SESSION_ID});\n  test.length(stream.sent, 0);\n};\n\nvar SESSION_ID = '17';\n\nTinytest.add(\"livedata stub - receive data\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // data comes in for unknown collection.\n  var coll_name = Random.id();\n  stream.receive({msg: 'added', collection: coll_name, id: '1234',\n                  fields: {a: 1}});\n  // break throught the black box and test internal state\n  test.length(conn._updatesForUnknownStores[coll_name], 1);\n\n  // XXX: Test that the old signature of passing manager directly instead of in\n  // options works.\n  var coll = new Meteor.Collection(coll_name, conn);\n\n  // queue has been emptied and doc is in db.\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n  test.equal(coll.find({}).fetch(), [{_id:'1234', a:1}]);\n\n  // second message. applied directly to the db.\n  stream.receive({msg: 'changed', collection: coll_name, id: '1234',\n                  fields: {a:2}});\n  test.equal(coll.find({}).fetch(), [{_id:'1234', a:2}]);\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n});\n\nTinytest.add(\"livedata stub - subscribe\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var callback_fired = false;\n  var sub = conn.subscribe('my_data', function () {\n    callback_fired = true;\n  });\n  test.isFalse(callback_fired);\n\n  test.length(stream.sent, 1);\n  var message = JSON.parse(stream.sent.shift());\n  var id = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'my_data', params: []});\n\n  var reactivelyReady = false;\n  var autorunHandle = Deps.autorun(function () {\n    reactivelyReady = sub.ready();\n  });\n  test.isFalse(reactivelyReady);\n\n  // get the sub satisfied. callback fires.\n  stream.receive({msg: 'ready', 'subs': [id]});\n  test.isTrue(callback_fired);\n  Deps.flush();\n  test.isTrue(reactivelyReady);\n  autorunHandle.stop();\n\n  // Unsubscribe.\n  sub.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: id});\n\n  // Resubscribe.\n  conn.subscribe('my_data');\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  var id2 = message.id;\n  test.notEqual(id, id2);\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'my_data', params: []});\n});\n\n\nTinytest.add(\"livedata stub - reactive subscribe\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var rFoo = new ReactiveVar('foo1');\n  var rBar = new ReactiveVar('bar1');\n\n  var onReadyCount = {};\n  var onReady = function (tag) {\n    return function () {\n      if (_.has(onReadyCount, tag))\n        ++onReadyCount[tag];\n      else\n        onReadyCount[tag] = 1;\n    };\n  };\n\n  // Subscribe to some subs.\n  var stopperHandle;\n  var autorunHandle = Deps.autorun(function () {\n    conn.subscribe(\"foo\", rFoo.get(), onReady(rFoo.get()));\n    conn.subscribe(\"bar\", rBar.get(), onReady(rBar.get()));\n    conn.subscribe(\"completer\", onReady(\"completer\"));\n    stopperHandle = conn.subscribe(\"stopper\", onReady(\"stopper\"));\n  });\n\n  // Check sub messages. (Assume they are sent in the order executed.)\n  test.length(stream.sent, 4);\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo1']});\n\n  message = JSON.parse(stream.sent.shift());\n  var idBar1 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'bar', params: ['bar1']});\n\n  message = JSON.parse(stream.sent.shift());\n  var idCompleter = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'completer', params: []});\n\n  message = JSON.parse(stream.sent.shift());\n  var idStopper = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'stopper', params: []});\n\n  // Haven't hit onReady yet.\n  test.equal(onReadyCount, {});\n\n  // \"completer\" gets ready now. its callback should fire.\n  stream.receive({msg: 'ready', 'subs': [idCompleter]});\n  test.equal(onReadyCount, {completer: 1});\n  test.length(stream.sent, 0);\n\n  // Stop 'stopper'.\n  stopperHandle.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: idStopper});\n\n  test.equal(onReadyCount, {completer: 1});\n\n  // Change the foo subscription and flush. We should sub to the new foo\n  // subscription, re-sub to the stopper subscription, and then unsub from the old\n  // foo subscription.  The bar subscription should be unaffected. The completer\n  // subscription should *NOT* call its new onReady callback, because we only\n  // call at most one onReady for a given reactively-saved subscription.\n  rFoo.set(\"foo2\");\n  Deps.flush();\n  test.length(stream.sent, 3);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo2']});\n\n  message = JSON.parse(stream.sent.shift());\n  var idStopperAgain = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'stopper', params: []});\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: idFoo1});\n\n  test.equal(onReadyCount, {completer: 1});\n\n  // Ready the stopper and bar subs. Completing stopper should call only the\n  // onReady from the new subscription because they were separate subscriptions\n  // started at different times and the first one was explicitly torn down by\n  // the client; completing bar should call only the onReady from the new\n  // subscription because we only call at most one onReady per reactively-saved\n  // subscription.\n  stream.receive({msg: 'ready', 'subs': [idStopperAgain, idBar1]});\n  test.equal(onReadyCount, {completer: 1, bar1: 1, stopper: 1});\n\n  // Shut down the autorun. This should unsub us from all current subs at flush\n  // time.\n  autorunHandle.stop();\n  Deps.flush();\n\n  test.length(stream.sent, 4);\n  // The order of unsubs here is not important.\n  var unsubMessages = _.map(stream.sent, JSON.parse);\n  stream.sent.length = 0;\n  test.equal(_.unique(_.pluck(unsubMessages, 'msg')), ['unsub']);\n  var actualIds = _.pluck(unsubMessages, 'id');\n  var expectedIds = [idFoo2, idBar1, idCompleter, idStopperAgain];\n  actualIds.sort();\n  expectedIds.sort();\n  test.equal(actualIds, expectedIds);\n});\n\n\nTinytest.add(\"livedata stub - this\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n  conn.methods({test_this: function() {\n    test.isTrue(this.isSimulation);\n    this.unblock(); // should be a no-op\n  }});\n\n  // should throw no exceptions\n  conn.call('test_this', _.identity);\n  // satisfy method, quiesce connection\n  var message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'method', method: 'test_this',\n                       params: [], id:message.id});\n  test.length(stream.sent, 0);\n\n  stream.receive({msg: 'result', id:message.id, result:null});\n  stream.receive({msg: 'updated', 'methods': [message.id]});\n\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - methods\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Meteor.Collection(collName, {connection: conn});\n\n    // setup method\n    conn.methods({do_something: function (x) {\n      coll.insert({value: x});\n    }});\n\n    // setup observers\n    var counts = {added: 0, removed: 0, changed: 0, moved: 0};\n    var handle = coll.find({}).observe(\n      { addedAt: function () { counts.added += 1; },\n        removedAt: function () { counts.removed += 1; },\n        changedAt: function () { counts.changed += 1; },\n        movedTo: function () { counts.moved += 1; }\n      });\n\n\n    // call method with results callback\n    var callback1Fired = false;\n    conn.call('do_something', 'friday!', function (err, res) {\n      test.isUndefined(err);\n      test.equal(res, '1234');\n      callback1Fired = true;\n    });\n    test.isFalse(callback1Fired);\n\n    // observers saw the method run.\n    test.equal(counts, {added: 1, removed: 0, changed: 0, moved: 0});\n\n    // get response from server\n    var message = JSON.parse(stream.sent.shift());\n    test.equal(message, {msg: 'method', method: 'do_something',\n                         params: ['friday!'], id:message.id});\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'friday!'}).count(), 1);\n    var docId = coll.findOne({value: 'friday!'})._id;\n\n    // results does not yet result in callback, because data is not\n    // ready.\n    stream.receive({msg: 'result', id:message.id, result: \"1234\"});\n    test.isFalse(callback1Fired);\n\n    // result message doesn't affect data\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'friday!'}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 0, moved: 0});\n\n    // data methods do not show up (not quiescent yet)\n    stream.receive({msg: 'added', collection: collName, id: LocalCollection._idStringify(docId),\n                    fields: {value: 'tuesday'}});\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'friday!'}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 0, moved: 0});\n\n    // send another methods (unknown on client)\n    var callback2Fired = false;\n    conn.call('do_something_else', 'monday', function (err, res) {\n      callback2Fired = true;\n    });\n    test.isFalse(callback1Fired);\n    test.isFalse(callback2Fired);\n\n    // test we still send a method request to server\n    var message2 = JSON.parse(stream.sent.shift());\n    test.equal(message2, {msg: 'method', method: 'do_something_else',\n                          params: ['monday'], id: message2.id});\n\n    // get the first data satisfied message. changes are applied to database even\n    // though another method is outstanding, because the other method didn't have\n    // a stub. and its callback is called.\n    stream.receive({msg: 'updated', 'methods': [message.id]});\n    test.isTrue(callback1Fired);\n    test.isFalse(callback2Fired);\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'tuesday'}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 1, moved: 0});\n\n    // second result\n    stream.receive({msg: 'result', id:message2.id, result:\"bupkis\"});\n    test.isFalse(callback2Fired);\n\n    // get second satisfied; no new changes are applied.\n    stream.receive({msg: 'updated', 'methods': [message2.id]});\n    test.isTrue(callback2Fired);\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'tuesday', _id: docId}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 1, moved: 0});\n\n    handle.stop();\n  });\n}\n\nTinytest.add(\"livedata stub - mutating method args\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  conn.methods({mutateArgs: function (arg) {\n    arg.foo = 42;\n  }});\n\n  conn.call('mutateArgs', {foo: 50}, _.identity);\n\n  // Method should be called with original arg, not mutated arg.\n  var message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'method', method: 'mutateArgs',\n                       params: [{foo: 50}], id: message.id});\n  test.length(stream.sent, 0);\n});\n\nvar observeCursor = function (test, cursor) {\n  var counts = {added: 0, removed: 0, changed: 0, moved: 0};\n  var expectedCounts = _.clone(counts);\n  var handle = cursor.observe(\n    { addedAt: function () { counts.added += 1; },\n      removedAt: function () { counts.removed += 1; },\n      changedAt: function () { counts.changed += 1; },\n      movedTo: function () { counts.moved += 1; }\n    });\n  return {\n    stop: _.bind(handle.stop, handle),\n    expectCallbacks: function (delta) {\n      _.each(delta, function (mod, field) {\n        expectedCounts[field] += mod;\n      });\n      test.equal(counts, expectedCounts);\n    }\n  };\n};\n\n// method calls another method in simulation. see not sent.\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - methods calling methods\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var coll_name = Random.id();\n    var coll = new Meteor.Collection(coll_name, {connection: conn});\n\n    // setup methods\n    conn.methods({\n      do_something: function () {\n        conn.call('do_something_else');\n      },\n      do_something_else: function () {\n        coll.insert({a: 1});\n      }\n    });\n\n    var o = observeCursor(test, coll.find());\n\n    // call method.\n    conn.call('do_something', _.identity);\n\n    // see we only send message for outer methods\n    var message = JSON.parse(stream.sent.shift());\n    test.equal(message, {msg: 'method', method: 'do_something',\n                         params: [], id:message.id});\n    test.length(stream.sent, 0);\n\n    // but inner method runs locally.\n    o.expectCallbacks({added: 1});\n    test.equal(coll.find().count(), 1);\n    var docId = coll.findOne()._id;\n    test.equal(coll.findOne(), {_id: docId, a: 1});\n\n    // we get the results\n    stream.receive({msg: 'result', id:message.id, result:\"1234\"});\n\n    // get data from the method. data from this doc does not show up yet, but data\n    // from another doc does.\n    stream.receive({msg: 'added', collection: coll_name, id: LocalCollection._idStringify(docId),\n                    fields: {value: 'tuesday'}});\n    o.expectCallbacks();\n    test.equal(coll.findOne(docId), {_id: docId, a: 1});\n    stream.receive({msg: 'added', collection: coll_name, id: 'monkey',\n                    fields: {value: 'bla'}});\n    o.expectCallbacks({added: 1});\n    test.equal(coll.findOne(docId), {_id: docId, a: 1});\n    var newDoc = coll.findOne({value: 'bla'});\n    test.isTrue(newDoc);\n    test.equal(newDoc, {_id: newDoc._id, value: 'bla'});\n\n    // get method satisfied. all data shows up. the 'a' field is reverted and\n    // 'value' field is set.\n    stream.receive({msg: 'updated', 'methods': [message.id]});\n    o.expectCallbacks({changed: 1});\n    test.equal(coll.findOne(docId), {_id: docId, value: 'tuesday'});\n    test.equal(coll.findOne(newDoc._id), {_id: newDoc._id, value: 'bla'});\n\n    o.stop();\n  });\n}\nTinytest.add(\"livedata stub - method call before connect\", function (test) {\n  var stream = new StubStream;\n  var conn = newConnection(stream);\n\n  var callbackOutput = [];\n  conn.call('someMethod', function (err, result) {\n    callbackOutput.push(result);\n  });\n  test.equal(callbackOutput, []);\n\n  // the real stream drops all output pre-connection\n  stream.sent.length = 0;\n\n  // Now connect.\n  stream.reset();\n\n  testGotMessage(test, stream, makeConnectMessage());\n  testGotMessage(test, stream, {msg: 'method', method: 'someMethod',\n                                params: [], id: '*'});\n});\n\nTinytest.add(\"livedata stub - reconnect\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Meteor.Collection(collName, {connection: conn});\n\n  var o = observeCursor(test, coll.find());\n\n  // subscribe\n  var subCallbackFired = false;\n  var sub = conn.subscribe('my_data', function () {\n    subCallbackFired = true;\n  });\n  test.isFalse(subCallbackFired);\n\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {msg: 'sub', name: 'my_data', params: [],\n                          id: subMessage.id});\n\n  // get some data. it shows up.\n  stream.receive({msg: 'added', collection: collName,\n                  id: '1234', fields: {a:1}});\n\n  test.equal(coll.find({}).count(), 1);\n  o.expectCallbacks({added: 1});\n  test.isFalse(subCallbackFired);\n\n  stream.receive({msg: 'changed', collection: collName,\n                  id: '1234', fields: {b:2}});\n  stream.receive({msg: 'ready',\n                  subs: [subMessage.id] // satisfy sub\n                 });\n  test.isTrue(subCallbackFired);\n  subCallbackFired = false; // re-arm for test that it doesn't fire again.\n\n  test.equal(coll.find({a:1, b:2}).count(), 1);\n  o.expectCallbacks({changed: 1});\n\n  // call method.\n  var methodCallbackFired = false;\n  conn.call('do_something', function () {\n    methodCallbackFired = true;\n  });\n\n  conn.apply('do_something_else', [], {wait: true}, _.identity);\n  conn.apply('do_something_later', [], _.identity);\n\n  test.isFalse(methodCallbackFired);\n\n  // The non-wait method should send, but not the wait method.\n  var methodMessage = JSON.parse(stream.sent.shift());\n  test.equal(methodMessage, {msg: 'method', method: 'do_something',\n                             params: [], id:methodMessage.id});\n  test.equal(stream.sent.length, 0);\n\n  // more data. shows up immediately because there was no relevant method stub.\n  stream.receive({msg: 'changed', collection: collName,\n                  id: '1234', fields: {c:3}});\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3});\n  o.expectCallbacks({changed: 1});\n\n  // stream reset. reconnect!  we send a connect, our pending method, and our\n  // sub. The wait method still is blocked.\n  stream.reset();\n\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, methodMessage);\n  testGotMessage(test, stream, subMessage);\n\n  // reconnect with different session id\n  stream.receive({msg: 'connected', session: SESSION_ID + 1});\n\n  // resend data. doesn't show up: we're in reconnect quiescence.\n  stream.receive({msg: 'added', collection: collName,\n                  id: '1234', fields: {a:1, b:2, c:3, d: 4}});\n  stream.receive({msg: 'added', collection: collName,\n                  id: '2345', fields: {e: 5}});\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3});\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks();\n\n  // satisfy and return the method\n  stream.receive({msg: 'updated',\n                  methods: [methodMessage.id]});\n  test.isFalse(methodCallbackFired);\n  stream.receive({msg: 'result', id:methodMessage.id, result:\"bupkis\"});\n  // The callback still doesn't fire (and we don't send the wait method): we're\n  // still in global quiescence\n  test.isFalse(methodCallbackFired);\n  test.equal(stream.sent.length, 0);\n\n  // still no update.\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3});\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks();\n\n  // re-satisfy sub\n  stream.receive({msg: 'ready', subs: [subMessage.id]});\n\n  // now the doc changes and method callback is called, and the wait method is\n  // sent. the sub callback isn't re-called.\n  test.isTrue(methodCallbackFired);\n  test.isFalse(subCallbackFired);\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3, d: 4});\n  test.equal(coll.findOne('2345'), {_id: '2345', e: 5});\n  o.expectCallbacks({added: 1, changed: 1});\n\n  var waitMethodMessage = JSON.parse(stream.sent.shift());\n  test.equal(waitMethodMessage, {msg: 'method', method: 'do_something_else',\n                                 params: [], id: waitMethodMessage.id});\n  test.equal(stream.sent.length, 0);\n  stream.receive({msg: 'result', id: waitMethodMessage.id, result: \"bupkis\"});\n  test.equal(stream.sent.length, 0);\n  stream.receive({msg: 'updated', methods: [waitMethodMessage.id]});\n\n  // wait method done means we can send the third method\n  test.equal(stream.sent.length, 1);\n  var laterMethodMessage = JSON.parse(stream.sent.shift());\n  test.equal(laterMethodMessage, {msg: 'method', method: 'do_something_later',\n                                  params: [], id: laterMethodMessage.id});\n\n  o.stop();\n});\n\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - reconnect method which only got result\", function (test) {\n    var stream = new StubStream;\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Meteor.Collection(collName, {connection: conn});\n    var o = observeCursor(test, coll.find());\n\n    conn.methods({writeSomething: function () {\n      // stub write\n      coll.insert({foo: 'bar'});\n    }});\n\n    test.equal(coll.find({foo: 'bar'}).count(), 0);\n\n    // Call a method. We'll get the result but not data-done before reconnect.\n    var callbackOutput = [];\n    var onResultReceivedOutput = [];\n    conn.apply('writeSomething', [],\n               {onResultReceived: function (err, result) {\n                 onResultReceivedOutput.push(result);\n               }},\n               function (err, result) {\n                 callbackOutput.push(result);\n               });\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId = coll.findOne({foo: 'bar'})._id;\n    o.expectCallbacks({added: 1});\n    // Callback not called.\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, []);\n    // Method sent.\n    var methodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'writeSomething',\n                     params: [], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // Get some data.\n    stream.receive({msg: 'added', collection: collName,\n                    id: LocalCollection._idStringify(stubWrittenId), fields: {baz: 42}});\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, foo: 'bar'});\n    o.expectCallbacks();\n\n    // Get the result.\n    stream.receive({msg: 'result', id: methodId, result: 'bla'});\n    // Data unaffected.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, foo: 'bar'});\n    o.expectCallbacks();\n    // Callback not called, but onResultReceived is.\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, ['bla']);\n\n    // Reset stream. Method does NOT get resent, because its result is already\n    // in. Reconnect quiescence happens as soon as 'connected' is received because\n    // there are no pending methods or subs in need of revival.\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    // Still holding out hope for session resumption, so nothing updated yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, foo: 'bar'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, []);\n\n    // Receive 'connected': time for reconnect quiescence! Data gets updated\n    // locally (ie, data is reset) and callback gets called.\n    stream.receive({msg: 'connected', session: SESSION_ID + 1});\n    test.equal(coll.find().count(), 0);\n    o.expectCallbacks({removed: 1});\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']);\n    stream.receive({msg: 'added', collection: collName,\n                    id: LocalCollection._idStringify(stubWrittenId), fields: {baz: 42}});\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, baz: 42});\n    o.expectCallbacks({added: 1});\n\n\n\n\n    // Run method again. We're going to do the same thing this time, except we're\n    // also going to use an onReconnect to insert another method at reconnect\n    // time, which will delay reconnect quiescence.\n    conn.apply('writeSomething', [],\n               {onResultReceived: function (err, result) {\n                 onResultReceivedOutput.push(result);\n               }},\n               function (err, result) {\n                 callbackOutput.push(result);\n               });\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId2 = coll.findOne({foo: 'bar'})._id;\n    o.expectCallbacks({added: 1});\n    // Callback not called.\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']);\n    // Method sent.\n    var methodId2 = testGotMessage(\n      test, stream, {msg: 'method', method: 'writeSomething',\n                     params: [], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // Get some data.\n    stream.receive({msg: 'added', collection: collName,\n                    id: LocalCollection._idStringify(stubWrittenId2), fields: {baz: 42}});\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n\n    // Get the result.\n    stream.receive({msg: 'result', id: methodId2, result: 'blab'});\n    // Data unaffected.\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n    // Callback not called, but onResultReceived is.\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla', 'blab']);\n    conn.onReconnect = function () {\n      conn.call('slowMethod', function (err, result) {\n        callbackOutput.push(result);\n      });\n    };\n\n    // Reset stream. Method does NOT get resent, because its result is already in,\n    // but slowMethod gets called via onReconnect. Reconnect quiescence is now\n    // blocking on slowMethod.\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID + 1));\n    var slowMethodId = testGotMessage(\n      test, stream,\n      {msg: 'method', method: 'slowMethod', params: [], id: '*'});\n    // Still holding out hope for session resumption, so nothing updated yet.\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']);\n\n    // Receive 'connected'... but no reconnect quiescence yet due to slowMethod.\n    stream.receive({msg: 'connected', session: SESSION_ID + 2});\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']);\n\n    // Receive data matching our stub. It doesn't take effect yet.\n    stream.receive({msg: 'added', collection: collName,\n                    id: LocalCollection._idStringify(stubWrittenId2), fields: {foo: 'bar'}});\n    o.expectCallbacks();\n\n    // slowMethod is done writing, so we get full reconnect quiescence (but no\n    // slowMethod callback)... ie, a reset followed by applying the data we just\n    // got, as well as calling the callback from the method that half-finished\n    // before reset. The net effect is deleting doc 'stubWrittenId'.\n    stream.receive({msg: 'updated', methods: [slowMethodId]});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks({removed: 1});\n    test.equal(callbackOutput, ['bla', 'blab']);\n\n    // slowMethod returns a value now.\n    stream.receive({msg: 'result', id: slowMethodId, result: 'slow'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla', 'blab', 'slow']);\n\n    o.stop();\n  });\n}\nTinytest.add(\"livedata stub - reconnect method which only got data\", function (test) {\n  var stream = new StubStream;\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Meteor.Collection(collName, {connection: conn});\n  var o = observeCursor(test, coll.find());\n\n  // Call a method. We'll get the data-done message but not the result before\n  // reconnect.\n  var callbackOutput = [];\n  var onResultReceivedOutput = [];\n  conn.apply('doLittle', [],\n             {onResultReceived: function (err, result) {\n               onResultReceivedOutput.push(result);\n             }},\n             function (err, result) {\n               callbackOutput.push(result);\n             });\n  // Callbacks not called.\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n  // Method sent.\n  var methodId = testGotMessage(\n    test, stream, {msg: 'method', method: 'doLittle',\n                   params: [], id: '*'});\n  test.equal(stream.sent.length, 0);\n\n  // Get some data.\n  stream.receive({msg: 'added', collection: collName,\n                  id: 'photo', fields: {baz: 42}});\n  // It shows up instantly because the stub didn't write anything.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks({added: 1});\n\n  // Get the data-done message.\n  stream.receive({msg: 'updated', methods: [methodId]});\n  // Data still here.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks();\n  // Method callback not called yet (no result yet).\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Reset stream. Method gets resent (with same ID), and blocks reconnect\n  // quiescence.\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(\n    test, stream, {msg: 'method', method: 'doLittle',\n                   params: [], id: methodId});\n  // Still holding out hope for session resumption, so nothing updated yet.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Receive 'connected'. Still blocking on reconnect quiescence.\n  stream.receive({msg: 'connected', session: SESSION_ID + 1});\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Receive method result. onResultReceived is called but the main callback\n  // isn't (ie, we don't get confused by the fact that we got data-done the\n  // *FIRST* time through).\n  stream.receive({msg: 'result', id: methodId, result: 'res'});\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, ['res']);\n\n  // Now we get data-done. Collection is reset and callback is called.\n  stream.receive({msg: 'updated', methods: [methodId]});\n  test.equal(coll.find().count(), 0);\n  o.expectCallbacks({removed: 1});\n  test.equal(callbackOutput, ['res']);\n  test.equal(onResultReceivedOutput, ['res']);\n\n  o.stop();\n});\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - multiple stubs same doc\", function (test) {\n    var stream = new StubStream;\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Meteor.Collection(collName, {connection: conn});\n    var o = observeCursor(test, coll.find());\n\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({foo: 'bar'});\n      },\n      updateIt: function (id) {\n        coll.update(id, {$set: {baz: 42}});\n      }\n    });\n\n    test.equal(coll.find().count(), 0);\n\n    // Call the insert method.\n    conn.call('insertSomething', _.identity);\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId = coll.findOne({foo: 'bar'})._id;\n    o.expectCallbacks({added: 1});\n    // Method sent.\n    var insertMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'insertSomething',\n                     params: [], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // Call update method.\n    conn.call('updateIt', stubWrittenId, _.identity);\n    // This stub write is visible too.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks({changed: 1});\n    // Method sent.\n    var updateMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'updateIt',\n                     params: [stubWrittenId], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // Get some data... slightly different than what we wrote.\n    stream.receive({msg: 'added', collection: collName,\n                    id: LocalCollection._idStringify(stubWrittenId), fields: {foo: 'barb', other: 'field',\n                                                                    other2: 'bla'}});\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks();\n\n    // And get the first method-done. Still no updates to minimongo: we can't\n    // quiesce the doc until the second method is done.\n    stream.receive({msg: 'updated', methods: [insertMethodId]});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks();\n\n    // More data. Not quite what we wrote. Also ignored for now.\n    stream.receive({msg: 'changed', collection: collName,\n                    id: LocalCollection._idStringify(stubWrittenId), fields: {baz: 43}, cleared: ['other']});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks();\n\n    // Second data-ready. Now everything takes effect!\n    stream.receive({msg: 'updated', methods: [updateMethodId]});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'barb', other2: 'bla',\n                baz: 43});\n    o.expectCallbacks({changed: 1});\n\n    o.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - unsent methods don't block quiescence\", function (test) {\n    // This test is for https://github.com/meteor/meteor/issues/555\n\n    var stream = new StubStream;\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Meteor.Collection(collName, {connection: conn});\n\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({foo: 'bar'});\n      }\n    });\n\n    test.equal(coll.find().count(), 0);\n\n    // Call a random method (no-op)\n    conn.call('no-op', _.identity);\n    // Call a wait method\n    conn.apply('no-op', [], {wait: true}, _.identity);\n    // Call a method with a stub that writes.\n    conn.call('insertSomething', _.identity);\n\n\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId = coll.findOne({foo: 'bar'})._id;\n\n    // first method sent\n    var firstMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'no-op',\n                     params: [], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // ack the first method\n    stream.receive({msg: 'updated', methods: [firstMethodId]});\n    stream.receive({msg: 'result', id: firstMethodId});\n\n    // Wait method sent.\n    var waitMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'no-op',\n                     params: [], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // ack the wait method\n    stream.receive({msg: 'updated', methods: [waitMethodId]});\n    stream.receive({msg: 'result', id: waitMethodId});\n\n    // insert method sent.\n    var insertMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'insertSomething',\n                     params: [], id: '*'});\n    test.equal(stream.sent.length, 0);\n\n    // ack the insert method\n    stream.receive({msg: 'updated', methods: [insertMethodId]});\n    stream.receive({msg: 'result', id: insertMethodId});\n\n    // simulation reverted.\n    test.equal(coll.find({foo: 'bar'}).count(), 0);\n\n  });\n}\nTinytest.add(\"livedata stub - reactive resub\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var readiedSubs = {};\n  var markAllReady = function () {\n    // synthesize a \"ready\" message in response to any \"sub\"\n    // message with an id we haven't seen before\n    _.each(stream.sent, function (msg) {\n      msg = JSON.parse(msg);\n      if (msg.msg === 'sub' && ! _.has(readiedSubs, msg.id)) {\n        stream.receive({msg: 'ready', subs: [msg.id]});\n        readiedSubs[msg.id] = true;\n      }\n    });\n  };\n\n  var fooArg = new ReactiveVar('A');\n  var fooReady = 0;\n\n  var inner;\n  var outer = Deps.autorun(function () {\n    inner = Deps.autorun(function () {\n      conn.subscribe(\"foo-sub\", fooArg.get(),\n                     function () { fooReady++; });\n    });\n  });\n\n  markAllReady();\n  test.equal(fooReady, 1);\n\n  // Rerun the inner autorun with different subscription\n  // arguments.  Detect the re-sub via onReady.\n  fooArg.set('B');\n  test.isTrue(inner.invalidated);\n  Deps.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.equal(fooReady, 2);\n\n  // Rerun inner again with same args; should be no re-sub.\n  inner.invalidate();\n  test.isTrue(inner.invalidated);\n  Deps.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.equal(fooReady, 2);\n\n  // Rerun outer!  Should still be no re-sub even though\n  // the inner computation is stopped and a new one is\n  // started.\n  outer.invalidate();\n  test.isTrue(inner.invalidated);\n  Deps.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.equal(fooReady, 2);\n\n  // Change the subscription.  Now we should get an onReady.\n  fooArg.set('C');\n  Deps.flush();\n  markAllReady();\n  test.equal(fooReady, 3);\n});\n\n\n\nTinytest.add(\"livedata connection - reactive userId\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  test.equal(conn.userId(), null);\n  conn.setUserId(1337);\n  test.equal(conn.userId(), 1337);\n});\n\nTinytest.add(\"livedata connection - two wait methods\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Meteor.Collection(collName, {connection: conn});\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  var responses = [];\n  conn.apply('do_something', ['one!'], function() { responses.push('one'); });\n  var one_message = JSON.parse(stream.sent.shift());\n  test.equal(one_message.params, ['one!']);\n\n  conn.apply('do_something', ['two!'], {wait: true}, function() {\n    responses.push('two');\n  });\n  // 'two!' isn't sent yet, because it's a wait method.\n  test.equal(stream.sent.length, 0);\n\n  conn.apply('do_something', ['three!'], function() {\n    responses.push('three');\n  });\n  conn.apply('do_something', ['four!'], function() {\n    responses.push('four');\n  });\n\n  conn.apply('do_something', ['five!'], {wait: true}, function() {\n    responses.push('five');\n  });\n\n  conn.apply('do_something', ['six!'], function() { responses.push('six'); });\n\n  // Verify that we did not send any more methods since we are still waiting on\n  // 'one!'.\n  test.equal(stream.sent.length, 0);\n\n  // Receive some data. \"one\" is not a wait method and there are no stubs, so it\n  // gets applied immediately.\n  test.equal(coll.find().count(), 0);\n  stream.receive({msg: 'added', collection: collName,\n                  id: 'foo', fields: {x: 1}});\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {_id: 'foo', x: 1});\n\n  // Let \"one!\" finish. Both messages are required to fire the callback.\n  stream.receive({msg: 'result', id: one_message.id});\n  test.equal(responses, []);\n  stream.receive({msg: 'updated', methods: [one_message.id]});\n  test.equal(responses, ['one']);\n\n  // Now we've send out \"two!\".\n  var two_message = JSON.parse(stream.sent.shift());\n  test.equal(two_message.params, ['two!']);\n\n  // But still haven't sent \"three!\".\n  test.equal(stream.sent.length, 0);\n\n  // Receive more data. \"two\" is a wait method, so the data doesn't get applied\n  // yet.\n  stream.receive({msg: 'changed', collection: collName,\n                  id: 'foo', fields: {y: 3}});\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {_id: 'foo', x: 1});\n\n  // Let \"two!\" finish, with its end messages in the opposite order to \"one!\".\n  stream.receive({msg: 'updated', methods: [two_message.id]});\n  test.equal(responses, ['one']);\n  test.equal(stream.sent.length, 0);\n  // data-done message is enough to allow data to be written.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {_id: 'foo', x: 1, y: 3});\n  stream.receive({msg: 'result', id: two_message.id});\n  test.equal(responses, ['one', 'two']);\n\n  // Verify that we just sent \"three!\" and \"four!\" now that we got\n  // responses for \"one!\" and \"two!\"\n  test.equal(stream.sent.length, 2);\n  var three_message = JSON.parse(stream.sent.shift());\n  test.equal(three_message.params, ['three!']);\n  var four_message = JSON.parse(stream.sent.shift());\n  test.equal(four_message.params, ['four!']);\n\n  // Out of order response is OK for non-wait methods.\n  stream.receive({msg: 'result', id: three_message.id});\n  stream.receive({msg: 'result', id: four_message.id});\n  stream.receive({msg: 'updated', methods: [four_message.id]});\n  test.equal(responses, ['one', 'two', 'four']);\n  test.equal(stream.sent.length, 0);\n\n  // Let three finish too.\n  stream.receive({msg: 'updated', methods: [three_message.id]});\n  test.equal(responses, ['one', 'two', 'four', 'three']);\n\n  // Verify that we just sent \"five!\" (the next wait method).\n  test.equal(stream.sent.length, 1);\n  var five_message = JSON.parse(stream.sent.shift());\n  test.equal(five_message.params, ['five!']);\n  test.equal(responses, ['one', 'two', 'four', 'three']);\n\n  // Let five finish.\n  stream.receive({msg: 'result', id: five_message.id});\n  stream.receive({msg: 'updated', methods: [five_message.id]});\n  test.equal(responses, ['one', 'two', 'four', 'three', 'five']);\n\n  var six_message = JSON.parse(stream.sent.shift());\n  test.equal(six_message.params, ['six!']);\n});\n\nTinytest.add(\"livedata connection - onReconnect prepends messages correctly with a wait method\", function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  conn.onReconnect = function() {\n    conn.apply('do_something', ['reconnect zero'], _.identity);\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], {wait: true}, _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  };\n\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {wait: true}, _.identity);\n  conn.apply('do_something', ['three'], _.identity);\n\n  // reconnect\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n  // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n  test.equal(_.map(stream.sent, function(msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect zero', 'reconnect one']);\n\n  // white-box test:\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [\n    [false, ['reconnect zero', 'reconnect one']],\n    [true, ['reconnect two']],\n    [false, ['reconnect three', 'one']],\n    [true, ['two']],\n    [false, ['three']]\n  ]);\n});\n\nvar getSelfConnectionUrl = function () {\n  if (Meteor.isClient) {\n    return Meteor._relativeToSiteRootUrl(\"/\");\n  } else {\n    return Meteor.absoluteUrl();\n  }\n};\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    reverse: function (arg) {\n      // Return something notably different from reverse.meteor.com.\n      return arg.split(\"\").reverse().join(\"\") + \" LOCAL\";\n    }\n  });\n}\n\ntestAsyncMulti(\"livedata connection - reconnect to a different server\", [\n  function (test, expect) {\n    var self = this;\n    self.conn = DDP.connect(\"reverse.meteor.com\");\n    pollUntil(expect, function () {\n      return self.conn.status().connected;\n    }, 5000, 100, true); // poll until connected, but don't fail if we don't connect\n  },\n  function (test, expect) {\n    var self = this;\n    self.doTest = self.conn.status().connected;\n    if (self.doTest) {\n      self.conn.call(\"reverse\", \"foo\", expect(function (err, res) {\n        test.equal(res, \"oof\");\n      }));\n    }\n  },\n  function (test, expect) {\n    var self = this;\n    if (self.doTest) {\n      self.conn.reconnect({url: getSelfConnectionUrl()});\n      self.conn.call(\"reverse\", \"bar\", expect(function (err, res) {\n        test.equal(res, \"rab LOCAL\");\n      }));\n    }\n  }\n]);\n\nTinytest.addAsync(\"livedata connection - version negotiation requires renegotiating\",\n                  function (test, onComplete) {\n  var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: [\"garbled\", LivedataTest.SUPPORTED_DDP_VERSIONS[0]],\n    onDDPVersionNegotiationFailure: function () { test.fail(); onComplete(); },\n    onConnected: function () {\n      test.equal(connection._version, LivedataTest.SUPPORTED_DDP_VERSIONS[0]);\n      connection._stream.disconnect({_permanent: true});\n      onComplete();\n    }\n  });\n});\n\nTinytest.addAsync(\"livedata connection - version negotiation error\",\n                  function (test, onComplete) {\n  var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: [\"garbled\", \"more garbled\"],\n    onDDPVersionNegotiationFailure: function () {\n      test.equal(connection.status().status, \"failed\");\n      test.matches(connection.status().reason, /DDP version negotiation failed/);\n      test.isFalse(connection.status().connected);\n      onComplete();\n    },\n    onConnected: function () {\n      test.fail();\n      onComplete();\n    }\n  });\n});\n\nTinytest.add(\"livedata connection - onReconnect prepends messages correctly without a wait method\", function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  conn.onReconnect = function() {\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  };\n\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {wait: true}, _.identity);\n  conn.apply('do_something', ['three'], {wait: true}, _.identity);\n  conn.apply('do_something', ['four'], _.identity);\n\n  // reconnect\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n  // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n  test.equal(_.map(stream.sent, function(msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect one', 'reconnect two', 'reconnect three', 'one']);\n\n  // white-box test:\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [\n    [false, ['reconnect one', 'reconnect two', 'reconnect three', 'one']],\n    [true, ['two']],\n    [true, ['three']],\n    [false, ['four']]\n  ]);\n});\n\nTinytest.add(\"livedata connection - onReconnect with sent messages\", function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  conn.onReconnect = function() {\n    conn.apply('do_something', ['login'], {wait: true}, _.identity);\n  };\n\n  conn.apply('do_something', ['one'], _.identity);\n\n  // initial connect\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(\n    test, stream, makeConnectMessage(conn._lastSessionId));\n\n  // Test that we sent just the login message.\n  var loginId = testGotMessage(\n    test, stream, {msg: 'method', method: 'do_something',\n                   params: ['login'], id: '*'});\n\n  // we connect.\n  stream.receive({msg: 'connected', session: Random.id()});\n  test.length(stream.sent, 0);\n\n  // login got result (but not yet data)\n  stream.receive({msg: 'result', id: loginId, result: 'foo'});\n  test.length(stream.sent, 0);\n\n  // login got data. now we send next method.\n  stream.receive({msg: 'updated', methods: [loginId]});\n\n  testGotMessage(\n    test, stream, {msg: 'method', method: 'do_something',\n                   params: ['one'], id: '*'});\n});\n\n\n\nTinytest.add(\"livedata stub - reconnect double wait method\", function (test) {\n  var stream = new StubStream;\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var output = [];\n  conn.onReconnect = function () {\n    conn.apply('reconnectMethod', [], {wait: true}, function (err, result) {\n      output.push('reconnect');\n    });\n  };\n\n  conn.apply('halfwayMethod', [], {wait: true}, function (err, result) {\n    output.push('halfway');\n  });\n\n  test.equal(output, []);\n  // Method sent.\n  var halfwayId = testGotMessage(\n    test, stream, {msg: 'method', method: 'halfwayMethod',\n                   params: [], id: '*'});\n  test.equal(stream.sent.length, 0);\n\n  // Get the result. This means it will not be resent.\n  stream.receive({msg: 'result', id: halfwayId, result: 'bla'});\n  // Callback not called.\n  test.equal(output, []);\n\n  // Reset stream. halfwayMethod does NOT get resent, but reconnectMethod does!\n  // Reconnect quiescence happens when reconnectMethod is done.\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  var reconnectId = testGotMessage(\n    test, stream, {msg: 'method', method: 'reconnectMethod',\n                   params: [], id: '*'});\n  test.length(stream.sent, 0);\n  // Still holding out hope for session resumption, so no callbacks yet.\n  test.equal(output, []);\n\n  // Receive 'connected', but reconnect quiescence is blocking on\n  // reconnectMethod.\n  stream.receive({msg: 'connected', session: SESSION_ID + 1});\n  test.equal(output, []);\n\n  // Data-done for reconnectMethod. This gets us to reconnect quiescence, so\n  // halfwayMethod's callback fires. reconnectMethod's is still waiting on its\n  // result.\n  stream.receive({msg: 'updated', methods: [reconnectId]});\n  test.equal(output.shift(), 'halfway');\n  test.equal(output, []);\n\n  // Get result of reconnectMethod. Its callback fires.\n  stream.receive({msg: 'result', id: reconnectId, result: 'foo'});\n  test.equal(output.shift(), 'reconnect');\n  test.equal(output, []);\n\n  // Call another method. It should be delivered immediately. This is a\n  // regression test for a case where it never got delivered because there was\n  // an empty block in _outstandingMethodBlocks blocking it from being sent.\n  conn.call('lastMethod', _.identity);\n  testGotMessage(test, stream,\n                 {msg: 'method', method: 'lastMethod', params: [], id: '*'});\n});\n\nTinytest.add(\"livedata stub - subscribe errors\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var onReadyFired = false;\n  var subError = null;\n  var sub = conn.subscribe('unknownSub', {\n    onReady: function () {\n      onReadyFired = true;\n    },\n    onError: function (error) {\n      subError = error;\n    }\n  });\n  test.isFalse(onReadyFired);\n  test.equal(subError, null);\n\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {msg: 'sub', name: 'unknownSub', params: [],\n                          id: subMessage.id});\n\n  // Reject the sub.\n  stream.receive({msg: 'nosub', id: subMessage.id,\n                  error: new Meteor.Error(404, \"Subscription not found\")});\n  test.isFalse(onReadyFired);\n  test.instanceOf(subError, Meteor.Error);\n  test.equal(subError.error, 404);\n  test.equal(subError.reason, \"Subscription not found\");\n\n  // stream reset: reconnect!\n  stream.reset();\n  // We send a connect.\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  // We should NOT re-sub to the sub, because we processed the error.\n  test.length(stream.sent, 0);\n  test.isFalse(onReadyFired);\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - stubs before connected\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    var collName = Random.id();\n    var coll = new Meteor.Collection(collName, {connection: conn});\n\n    // Start and send \"connect\", but DON'T get 'connected' quite yet.\n    stream.reset(); // initial connection start.\n\n    testGotMessage(test, stream, makeConnectMessage());\n    test.length(stream.sent, 0);\n\n    // Insert a document. The stub updates \"conn\" directly.\n    coll.insert({_id: \"foo\", bar: 42}, _.identity);\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(), {_id: \"foo\", bar: 42});\n    // It also sends the method message.\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {msg: 'method', method: '/' + collName + '/insert',\n                               params: [{_id: \"foo\", bar: 42}],\n                               id: methodMessage.id});\n    test.length(stream.sent, 0);\n\n    // Now receive a connected message. This should not clear the\n    // _documentsWrittenByStub state!\n    stream.receive({msg: 'connected', session: SESSION_ID});\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 1);\n\n    // Now receive the \"updated\" message for the method. This should revert the\n    // insert.\n    stream.receive({msg: 'updated', methods: [methodMessage.id]});\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 0);\n  });\n}\n// XXX also test:\n// - reconnect, with session resume.\n// - restart on update flag\n// - on_update event\n// - reloading when the app changes, including session migration\n","// XXX should check error codes\nvar failure = function (test, code, reason) {\n  return function (error, result) {\n    test.equal(result, undefined);\n    test.isTrue(error && typeof error === \"object\");\n    if (error && typeof error === \"object\") {\n      if (typeof code === \"number\") {\n        test.instanceOf(error, Meteor.Error);\n        code && test.equal(error.error, code);\n        reason && test.equal(error.reason, reason);\n        // XXX should check that other keys aren't present.. should\n        // probably use something like the Matcher we used to have\n      } else {\n        // for normal Javascript errors\n        test.instanceOf(error, Error);\n        test.equal(error.message, code);\n      }\n    }\n  };\n};\n\nTinytest.add(\"livedata - Meteor.Error\", function (test) {\n  var error = new Meteor.Error(123, \"kittens\", \"puppies\");\n  test.instanceOf(error, Meteor.Error);\n  test.instanceOf(error, Error);\n  test.equal(error.error, 123);\n  test.equal(error.reason, \"kittens\");\n  test.equal(error.details, \"puppies\");\n});\n\nif (Meteor.isServer) {\n  Tinytest.add(\"livedata - version negotiation\", function (test) {\n    var versionCheck = function (clientVersions, serverVersions, expected) {\n      test.equal(\n        LivedataTest.calculateVersion(clientVersions, serverVersions),\n        expected);\n    };\n\n    versionCheck([\"A\", \"B\", \"C\"], [\"A\", \"B\", \"C\"], \"A\");\n    versionCheck([\"B\", \"C\"], [\"A\", \"B\", \"C\"], \"B\");\n    versionCheck([\"A\", \"B\", \"C\"], [\"B\", \"C\"], \"B\");\n    versionCheck([\"foo\", \"bar\", \"baz\"], [\"A\", \"B\", \"C\"], \"A\");\n  });\n}\n\nTinytest.add(\"livedata - methods with colliding names\", function (test) {\n  var x = Random.id();\n  var m = {};\n  m[x] = function () {};\n  Meteor.methods(m);\n\n  test.throws(function () {\n    Meteor.methods(m);\n  });\n});\n\nvar echoTest = function (item) {\n  return function (test, expect) {\n    if (Meteor.isServer) {\n      test.equal(Meteor.call(\"echo\", item), [item]);\n      test.equal(Meteor.call(\"echoOne\", item), item);\n    }\n    if (Meteor.isClient)\n      test.equal(Meteor.call(\"echo\", item), undefined);\n\n    test.equal(Meteor.call(\"echo\", item, expect(undefined, [item])), undefined);\n    test.equal(Meteor.call(\"echoOne\", item, expect(undefined, item)), undefined);\n  };\n};\n\ntestAsyncMulti(\"livedata - basic method invocation\", [\n  // Unknown methods\n  function (test, expect) {\n    if (Meteor.isServer) {\n      // On server, with no callback, throws exception\n      try {\n        var ret = Meteor.call(\"unknown method\");\n      } catch (e) {\n        test.equal(e.error, 404);\n        var threw = true;\n      }\n      test.isTrue(threw);\n      test.equal(ret, undefined);\n    }\n\n    if (Meteor.isClient) {\n      // On client, with no callback, just returns undefined\n      var ret = Meteor.call(\"unknown method\");\n      test.equal(ret, undefined);\n    }\n\n    // On either, with a callback, calls the callback and does not throw\n    var ret = Meteor.call(\"unknown method\",\n                          expect(failure(test, 404, \"Method not found\")));\n    test.equal(ret, undefined);\n  },\n\n  function (test, expect) {\n    // make sure 'undefined' is preserved as such, instead of turning\n    // into null (JSON does not have 'undefined' so there is special\n    // code for this)\n    if (Meteor.isServer)\n      test.equal(Meteor.call(\"nothing\"), undefined);\n    if (Meteor.isClient)\n      test.equal(Meteor.call(\"nothing\"), undefined);\n\n    test.equal(Meteor.call(\"nothing\", expect(undefined, undefined)), undefined);\n  },\n\n  function (test, expect) {\n    if (Meteor.isServer)\n      test.equal(Meteor.call(\"echo\"), []);\n    if (Meteor.isClient)\n      test.equal(Meteor.call(\"echo\"), undefined);\n\n    test.equal(Meteor.call(\"echo\", expect(undefined, [])), undefined);\n  },\n\n  echoTest(new Date()),\n  echoTest({d: new Date(), s: \"foobarbaz\"}),\n  echoTest([new Date(), \"foobarbaz\"]),\n  echoTest(new Meteor.Collection.ObjectID()),\n  echoTest({o: new Meteor.Collection.ObjectID()}),\n  echoTest({$date: 30}), // literal\n  echoTest({$literal: {$date: 30}}),\n  echoTest(12),\n  echoTest(Infinity),\n  echoTest(-Infinity),\n\n  function (test, expect) {\n    if (Meteor.isServer)\n      test.equal(Meteor.call(\"echo\", 12, {x: 13}), [12, {x: 13}]);\n    if (Meteor.isClient)\n      test.equal(Meteor.call(\"echo\", 12, {x: 13}), undefined);\n\n    test.equal(Meteor.call(\"echo\", 12, {x: 13},\n                           expect(undefined, [12, {x: 13}])), undefined);\n  },\n\n  // test that `wait: false` is respected\n  function (test, expect) {\n    if (Meteor.isClient) {\n      // For test isolation\n      var token = Random.id();\n      Meteor.apply(\n        \"delayedTrue\", [token], {wait: false}, expect(function(err, res) {\n          test.equal(res, false);\n        }));\n      Meteor.apply(\"makeDelayedTrueImmediatelyReturnFalse\", [token]);\n    }\n  },\n\n  // test that `wait: true` is respected\n  function(test, expect) {\n    if (Meteor.isClient) {\n      var token = Random.id();\n      Meteor.apply(\n        \"delayedTrue\", [token], {wait: true}, expect(function(err, res) {\n          test.equal(res, true);\n        }));\n      Meteor.apply(\"makeDelayedTrueImmediatelyReturnFalse\", [token]);\n    }\n  },\n\n  function (test, expect) {\n    // No callback\n\n    if (Meteor.isServer) {\n      test.throws(function () {\n        Meteor.call(\"exception\", \"both\");\n      });\n      test.throws(function () {\n        Meteor.call(\"exception\", \"server\");\n      });\n      // No exception, because no code will run on the client\n      test.equal(Meteor.call(\"exception\", \"client\"), undefined);\n    }\n\n    if (Meteor.isClient) {\n      // The client exception is thrown away because it's in the\n      // stub. The server exception is throw away because we didn't\n      // give a callback.\n      test.equal(Meteor.call(\"exception\", \"both\"), undefined);\n      test.equal(Meteor.call(\"exception\", \"server\"), undefined);\n      test.equal(Meteor.call(\"exception\", \"client\"), undefined);\n    }\n\n    // With callback\n\n    if (Meteor.isClient) {\n      test.equal(\n        Meteor.call(\"exception\", \"both\",\n                    expect(failure(test, 500, \"Internal server error\"))),\n        undefined);\n      test.equal(\n        Meteor.call(\"exception\", \"server\",\n                    expect(failure(test, 500, \"Internal server error\"))),\n        undefined);\n      test.equal(Meteor.call(\"exception\", \"client\"), undefined);\n    }\n\n    if (Meteor.isServer) {\n      test.equal(\n        Meteor.call(\"exception\", \"both\",\n                    expect(failure(test, \"Test method throwing an exception\"))),\n        undefined);\n      test.equal(\n        Meteor.call(\"exception\", \"server\",\n                    expect(failure(test, \"Test method throwing an exception\"))),\n        undefined);\n      test.equal(Meteor.call(\"exception\", \"client\"), undefined);\n    }\n  },\n\n  function (test, expect) {\n    if (Meteor.isServer) {\n      var threw = false;\n      try {\n        Meteor.call(\"exception\", \"both\", {intended: true});\n      } catch (e) {\n        threw = true;\n        test.equal(e.error, 999);\n        test.equal(e.reason, \"Client-visible test exception\");\n      }\n      test.isTrue(threw);\n      threw = false;\n      try {\n        Meteor.call(\"exception\", \"both\", {intended: true,\n                                          throwThroughFuture: true});\n      } catch (e) {\n        threw = true;\n        test.equal(e.error, 999);\n        test.equal(e.reason, \"Client-visible test exception\");\n      }\n      test.isTrue(threw);\n    }\n\n    if (Meteor.isClient) {\n      test.equal(\n        Meteor.call(\"exception\", \"both\", {intended: true},\n                    expect(failure(test, 999,\n                                   \"Client-visible test exception\"))),\n        undefined);\n      test.equal(\n        Meteor.call(\"exception\", \"server\", {intended: true},\n                    expect(failure(test, 999,\n                                   \"Client-visible test exception\"))),\n        undefined);\n      test.equal(\n        Meteor.call(\"exception\", \"server\", {intended: true,\n                                            throwThroughFuture: true},\n                    expect(failure(test, 999,\n                                   \"Client-visible test exception\"))),\n        undefined);\n    }\n  }\n]);\n\n\n\n\nvar checkBalances = function (test, a, b) {\n  var alice = Ledger.findOne({name: \"alice\", world: test.runId()});\n  var bob = Ledger.findOne({name: \"bob\", world: test.runId()});\n  test.equal(alice.balance, a);\n  test.equal(bob.balance, b);\n};\n\n// would be nice to have a database-aware test harness of some kind --\n// this is a big hack (and XXX pollutes the global test namespace)\ntestAsyncMulti(\"livedata - compound methods\", [\n  function (test, expect) {\n    if (Meteor.isClient)\n      Meteor.subscribe(\"ledger\", test.runId(), expect());\n\n    Ledger.insert({name: \"alice\", balance: 100, world: test.runId()},\n                  expect(function () {}));\n    Ledger.insert({name: \"bob\", balance: 50, world: test.runId()},\n                  expect(function () {}));\n  },\n  function (test, expect) {\n    Meteor.call('ledger/transfer', test.runId(), \"alice\", \"bob\", 10,\n                expect(function(err, result) {\n                  test.equal(err, undefined);\n                  test.equal(result, undefined);\n                  checkBalances(test, 90, 60);\n                }));\n    checkBalances(test, 90, 60);\n  },\n  function (test, expect) {\n    Meteor.call('ledger/transfer', test.runId(), \"alice\", \"bob\", 100, true,\n                expect(function (err, result) {\n                  failure(test, 409)(err, result);\n                  // Balances are reverted back to pre-stub values.\n                  checkBalances(test, 90, 60);\n                }));\n\n    if (Meteor.isClient)\n      // client can fool itself by cheating, but only until the sync\n      // finishes\n      checkBalances(test, -10, 160);\n    else\n      checkBalances(test, 90, 60);\n  }\n]);\n\n// Replaces the Connection's `_livedata_data` method to push incoming\n// messages on a given collection to an array. This can be used to\n// verify that the right data is sent on the wire\n//\n// @param messages {Array} The array to which to append the messages\n// @return {Function} A function to call to undo the eavesdropping\nvar eavesdropOnCollection = function(livedata_connection,\n                                     collection_name, messages) {\n  var old_livedata_data = _.bind(\n    livedata_connection._livedata_data, livedata_connection);\n\n  // Kind of gross since all tests past this one will run with this\n  // hook set up. That's probably fine since we only check a specific\n  // collection but still...\n  //\n  // Should we consider having a separate connection per Tinytest or\n  // some similar scheme?\n  livedata_connection._livedata_data = function(msg) {\n    if (msg.collection && msg.collection === collection_name) {\n      messages.push(msg);\n    }\n    old_livedata_data(msg);\n  };\n\n  return function() {\n    livedata_connection._livedata_data = old_livedata_data;\n  };\n};\n\nif (Meteor.isClient) {\n  testAsyncMulti(\"livedata - changing userid reruns subscriptions without flapping data on the wire\", [\n    function(test, expect) {\n      var messages = [];\n      var undoEavesdrop = eavesdropOnCollection(\n        Meteor.connection, \"objectsWithUsers\", messages);\n\n      // A helper for testing incoming set and unset messages\n      // XXX should this be extracted as a general helper together with\n      // eavesdropOnCollection?\n      var expectMessages = function(expectedAddedMessageCount,\n                                    expectedRemovedMessageCount,\n                                    expectedNamesInCollection) {\n        var actualAddedMessageCount = 0;\n        var actualRemovedMessageCount = 0;\n        _.each(messages, function (msg) {\n          if (msg.msg === 'added')\n            ++actualAddedMessageCount;\n          else if (msg.msg === 'removed')\n            ++actualRemovedMessageCount;\n          else\n            test.fail({unexpected: JSON.stringify(msg)});\n        });\n        test.equal(actualAddedMessageCount, expectedAddedMessageCount);\n        test.equal(actualRemovedMessageCount, expectedRemovedMessageCount);\n        expectedNamesInCollection.sort();\n        test.equal(_.pluck(objectsWithUsers.find({}, {sort: ['name']}).fetch(),\n                           'name'),\n                   expectedNamesInCollection);\n        messages.length = 0; // clear messages without creating a new object\n      };\n\n      // make sure we're not already logged in. can happen if accounts\n      // tests fail oddly.\n      Meteor.apply(\"setUserId\", [null], {wait: true}, expect(function () {}));\n\n      Meteor.subscribe(\"objectsWithUsers\", expect(function() {\n        expectMessages(1, 0, [\"owned by none\"]);\n        Meteor.apply(\"setUserId\", [\"1\"], {wait: true}, afterFirstSetUserId);\n      }));\n\n      var afterFirstSetUserId = expect(function() {\n        expectMessages(3, 1, [\n          \"owned by one - a\",\n          \"owned by one/two - a\",\n          \"owned by one/two - b\"]);\n        Meteor.apply(\"setUserId\", [\"2\"], {wait: true}, afterSecondSetUserId);\n      });\n\n      var afterSecondSetUserId = expect(function() {\n        expectMessages(2, 1, [\n          \"owned by one/two - a\",\n          \"owned by one/two - b\",\n          \"owned by two - a\",\n          \"owned by two - b\"]);\n        Meteor.apply(\"setUserId\", [\"2\"], {wait: true}, afterThirdSetUserId);\n      });\n\n      var afterThirdSetUserId = expect(function() {\n        // Nothing should have been sent since the results of the\n        // query are the same (\"don't flap data on the wire\")\n        expectMessages(0, 0, [\n          \"owned by one/two - a\",\n          \"owned by one/two - b\",\n          \"owned by two - a\",\n          \"owned by two - b\"]);\n        undoEavesdrop();\n      });\n    }, function(test, expect) {\n      var key = Random.id();\n      Meteor.subscribe(\"recordUserIdOnStop\", key);\n      Meteor.apply(\"setUserId\", [\"100\"], {wait: true}, expect(function () {}));\n      Meteor.apply(\"setUserId\", [\"101\"], {wait: true}, expect(function () {}));\n      Meteor.call(\"userIdWhenStopped\", key, expect(function (err, result) {\n        test.isFalse(err);\n        test.equal(result, \"100\");\n      }));\n      // clean up\n      Meteor.apply(\"setUserId\", [null], {wait: true}, expect(function () {}));\n    }\n  ]);\n}\n\nTinytest.add(\"livedata - setUserId error when called from server\", function(test) {\n  if (Meteor.isServer) {\n    test.equal(errorThrownWhenCallingSetUserIdDirectlyOnServer.message,\n               \"Can't call setUserId on a server initiated method call\");\n  }\n});\n\n\nif (Meteor.isServer) {\n  var pubHandles = {};\n};\nMeteor.methods({\n  \"livedata/setup\" : function (id) {\n    check(id, String);\n    if (Meteor.isServer) {\n      pubHandles[id] = {};\n      Meteor.publish(\"pub1\"+id, function () {\n        pubHandles[id].pub1 = this;\n        this.ready();\n      });\n      Meteor.publish(\"pub2\"+id, function () {\n        pubHandles[id].pub2 = this;\n        this.ready();\n      });\n\n    }\n  },\n  \"livedata/pub1go\" : function (id) {\n    check(id, String);\n    if (Meteor.isServer) {\n\n      pubHandles[id].pub1.added(\"MultiPubCollection\" + id, \"foo\", {a: \"aa\"});\n      return 1;\n    }\n    return 0;\n  },\n  \"livedata/pub2go\" : function (id) {\n    check(id, String);\n    if (Meteor.isServer) {\n      pubHandles[id].pub2.added(\"MultiPubCollection\" + id , \"foo\", {b: \"bb\"});\n      return 2;\n    }\n    return 0;\n  }\n});\n\nif (Meteor.isClient) {\n  (function () {\n    var MultiPub;\n    var id = Random.id();\n    testAsyncMulti(\"livedata - added from two different subs\", [\n      function (test, expect) {\n        Meteor.call('livedata/setup', id, expect(function () {}));\n      },\n      function (test, expect) {\n        MultiPub = new Meteor.Collection(\"MultiPubCollection\" + id);\n        var sub1 = Meteor.subscribe(\"pub1\"+id, expect(function () {}));\n        var sub2 = Meteor.subscribe(\"pub2\"+id, expect(function () {}));\n      },\n      function (test, expect) {\n        Meteor.call(\"livedata/pub1go\", id, expect(function (err, res) {test.equal(res, 1);}));\n      },\n      function (test, expect) {\n        test.equal(MultiPub.findOne(\"foo\"), {_id: \"foo\", a: \"aa\"});\n      },\n      function (test, expect) {\n        Meteor.call(\"livedata/pub2go\", id, expect(function (err, res) {test.equal(res, 2);}));\n      },\n      function (test, expect) {\n        test.equal(MultiPub.findOne(\"foo\"), {_id: \"foo\", a: \"aa\", b: \"bb\"});\n      }\n    ]);\n  })();\n};\n\nif (Meteor.isClient) {\n  testAsyncMulti(\"livedata - overlapping universal subs\", [\n    function (test, expect) {\n      var coll = new Meteor.Collection(\"overlappingUniversalSubs\");\n      var token = Random.id();\n      test.isFalse(coll.findOne(token));\n      Meteor.call(\"testOverlappingSubs\", token, expect(function (err) {\n        test.isFalse(err);\n        test.isTrue(coll.findOne(token));\n      }));\n    }\n  ]);\n\n  testAsyncMulti(\"livedata - runtime universal sub creation\", [\n    function (test, expect) {\n      var coll = new Meteor.Collection(\"runtimeSubCreation\");\n      var token = Random.id();\n      test.isFalse(coll.findOne(token));\n      Meteor.call(\"runtimeUniversalSubCreation\", token, expect(function (err) {\n        test.isFalse(err);\n        test.isTrue(coll.findOne(token));\n      }));\n    }\n  ]);\n\n  testAsyncMulti(\"livedata - no setUserId after unblock\", [\n    function (test, expect) {\n      Meteor.call(\"setUserIdAfterUnblock\", expect(function (err, result) {\n        test.isFalse(err);\n        test.isTrue(result);\n      }));\n    }\n  ]);\n\n  testAsyncMulti(\"livedata - publisher errors\", (function () {\n    // Use a separate connection so that we can safely check to see if\n    // conn._subscriptions is empty.\n    var conn = new LivedataTest.Connection('/',\n                                            {reloadWithOutstanding: true});\n    var collName = Random.id();\n    var coll = new Meteor.Collection(collName, {connection: conn});\n    var errorFromRerun;\n    var gotErrorFromStopper = false;\n    return [\n      function (test, expect) {\n        var testSubError = function (options) {\n          conn.subscribe(\"publisherErrors\", collName, options, {\n            onReady: expect(),\n            onError: expect(\n              failure(test,\n                      options.internalError ? 500 : 412,\n                      options.internalError ? \"Internal server error\"\n                                            : \"Explicit error\"))\n          });\n        };\n        testSubError({throwInHandler: true});\n        testSubError({throwInHandler: true, internalError: true});\n        testSubError({errorInHandler: true});\n        testSubError({errorInHandler: true, internalError: true});\n        testSubError({errorLater: true});\n        testSubError({errorLater: true, internalError: true});\n      },\n      function (test, expect) {\n        test.equal(coll.find().count(), 0);\n        test.equal(_.size(conn._subscriptions), 0);  // white-box test\n\n        conn.subscribe(\"publisherErrors\",\n                       collName, {throwWhenUserIdSet: true}, {\n          onReady: expect(),\n          onError: function (error) {\n            errorFromRerun = error;\n          }\n        });\n      },\n      function (test, expect) {\n        // Because the last subscription is ready, we should have a document.\n        test.equal(coll.find().count(), 1);\n        test.isFalse(errorFromRerun);\n        test.equal(_.size(conn._subscriptions), 1);  // white-box test\n        conn.call('setUserId', 'bla', expect(function(){}));\n      },\n      function (test, expect) {\n        // Now that we've re-run, we should have stopped the subscription,\n        // gotten a error, and lost the document.\n        test.equal(coll.find().count(), 0);\n        test.isTrue(errorFromRerun);\n        test.instanceOf(errorFromRerun, Meteor.Error);\n        test.equal(errorFromRerun.error, 412);\n        test.equal(errorFromRerun.reason, \"Explicit error\");\n        test.equal(_.size(conn._subscriptions), 0);  // white-box test\n\n        conn.subscribe(\"publisherErrors\", collName, {stopInHandler: true}, {\n          onError: function() { gotErrorFromStopper = true; }\n        });\n        // Call a method. This method won't be processed until the publisher's\n        // function returns, so blocking on it being done ensures that we've\n        // gotten the removed/nosub/etc.\n        conn.call('nothing', expect(function(){}));\n      },\n      function (test, expect) {\n        test.equal(coll.find().count(), 0);\n        // sub.stop does NOT call onError.\n        test.isFalse(gotErrorFromStopper);\n        test.equal(_.size(conn._subscriptions), 0);  // white-box test\n        conn._stream.disconnect({_permanent: true});\n      }\n    ];})());\n\n    testAsyncMulti(\"livedata - publish multiple cursors\", [\n      function (test, expect) {\n        Meteor.subscribe(\"multiPublish\", {normal: 1}, {\n          onReady: expect(function () {\n            test.equal(One.find().count(), 2);\n            test.equal(Two.find().count(), 3);\n          }),\n          onError: failure()\n        });\n      },\n      function (test, expect) {\n        Meteor.subscribe(\"multiPublish\", {dup: 1}, {\n          onReady: failure(),\n          onError: expect(failure(test, 500, \"Internal server error\"))\n        });\n      },\n      function (test, expect) {\n        Meteor.subscribe(\"multiPublish\", {notCursor: 1}, {\n          onReady: failure(),\n          onError: expect(failure(test, 500, \"Internal server error\"))\n        });\n      }\n    ]);\n}\n\nvar selfUrl = Meteor.isServer\n      ? Meteor.absoluteUrl() : Meteor._relativeToSiteRootUrl('/');\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    \"s2s\": function (arg) {\n      check(arg, String);\n      return \"s2s \" + arg;\n    }\n  });\n}\n(function () {\n  testAsyncMulti(\"livedata - connect works from both client and server\", [\n    function (test, expect) {\n      var self = this;\n      self.conn = DDP.connect(selfUrl);\n      pollUntil(expect, function () {\n        return self.conn.status().connected;\n      }, 10000);\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (self.conn.status().connected) {\n        self.conn.call('s2s', 'foo', expect(function (err, res) {\n          if (err)\n            throw err;\n          test.equal(res, \"s2s foo\");\n        }));\n      }\n    }\n  ]);\n})();\n\nif (Meteor.isServer) {\n  (function () {\n    testAsyncMulti(\"livedata - method call on server blocks in a fiber way\", [\n      function (test, expect) {\n        var self = this;\n        self.conn = DDP.connect(selfUrl);\n        pollUntil(expect, function () {\n          return self.conn.status().connected;\n        }, 10000);\n      },\n\n      function (test, expect) {\n        var self = this;\n        if (self.conn.status().connected) {\n          test.equal(self.conn.call('s2s', 'foo'), \"s2s foo\");\n        }\n      }\n    ]);\n  })();\n}\n\n(function () {\n  testAsyncMulti(\"livedata - connect fails to unknown place\", [\n    function (test, expect) {\n      var self = this;\n      self.conn = DDP.connect(\"example.com\");\n      Meteor.setTimeout(expect(function () {\n        test.isFalse(self.conn.status().connected, \"Not connected\");\n      }), 500);\n    }\n  ]);\n})();\n\n\n// XXX some things to test in greater detail:\n// staying in simulation mode\n// time warp\n// serialization / beginAsync(true) / beginAsync(false)\n// malformed messages (need raw wire access)\n// method completion/satisfaction\n// subscriptions (multiple APIs, including autorun?)\n// subscription completion\n// subscription attribute shadowing\n// server method calling methods on other server (eg, should simulate)\n// subscriptions and methods being idempotent\n// reconnection\n// reconnection not resulting in method re-execution\n// reconnection tolerating all kinds of lost messages (including data)\n// [probably lots more]\n","Meteor.methods({\n  nothing: function () {\n    // No need to check if there are no arguments.\n  },\n  echo: function (/* arguments */) {\n    check(arguments, [Match.Any]);\n    return _.toArray(arguments);\n  },\n  echoOne: function (/*arguments*/) {\n    check(arguments, [Match.Any]);\n    return arguments[0];\n  },\n  exception: function (where, options) {\n    check(where, String);\n    check(options, Match.Optional({\n      intended: Match.Optional(Boolean),\n      throwThroughFuture: Match.Optional(Boolean)\n    }));\n    options = options || {};\n    var shouldThrow =\n      (Meteor.isServer && where === \"server\") ||\n      (Meteor.isClient && where === \"client\") ||\n      where === \"both\";\n\n    if (shouldThrow) {\n      var e;\n      if (options.intended)\n        e = new Meteor.Error(999, \"Client-visible test exception\");\n      else\n        e = new Error(\"Test method throwing an exception\");\n      e.expected = true;\n\n      // We used to improperly serialize errors that were thrown through a\n      // future first.\n      if (Meteor.isServer && options.throwThroughFuture) {\n        var Future = Npm.require('fibers/future');\n        var f = new Future;\n        f['throw'](e);\n        e = f.wait();\n      }\n      throw e;\n    }\n  },\n  setUserId: function(userId) {\n    check(userId, Match.OneOf(String, null));\n    this.setUserId(userId);\n  }\n});\n\n// Methods to help test applying methods with `wait: true`: delayedTrue returns\n// true 1s after being run unless makeDelayedTrueImmediatelyReturnFalse was run\n// in the meanwhile. Increasing the timeout makes the \"wait: true\" test slower;\n// decreasing the timeout makes the \"wait: false\" test flakier (ie, the timeout\n// could fire before processing the second method).\nif (Meteor.isServer) {\n  // Keys are random tokens, used to isolate multiple test invocations from each\n  // other.\n  var waiters = {};\n\n  var path = Npm.require('path');\n  var Future = Npm.require(path.join('fibers', 'future'));\n\n  var returnThroughFuture = function (token, returnValue) {\n    // Make sure that when we call return, the fields are already cleared.\n    var record = waiters[token];\n    if (!record)\n      return;\n    delete waiters[token];\n    record.future['return'](returnValue);\n  };\n\n  Meteor.methods({\n    delayedTrue: function(token) {\n      check(token, String);\n      var record = waiters[token] = {\n        future: new Future(),\n        timer: Meteor.setTimeout(function() {\n          returnThroughFuture(token, true);\n        }, 1000)\n      };\n\n      this.unblock();\n      return record.future.wait();\n    },\n    makeDelayedTrueImmediatelyReturnFalse: function(token) {\n      check(token, String);\n      var record = waiters[token];\n      if (!record)\n        return; // since delayedTrue's timeout had already run\n      clearTimeout(record.timer);\n      returnThroughFuture(token, false);\n    }\n  });\n}\n\n/*****/\n\nLedger = new Meteor.Collection(\"ledger\");\nLedger.allow({\n  insert: function() { return true; },\n  update: function() { return true; },\n  remove: function() { return true; },\n  fetch: []\n});\n\nMeteor.startup(function () {\n  if (Meteor.isServer)\n    Ledger.remove({}); // XXX can this please be Ledger.remove()?\n});\n\nif (Meteor.isServer)\n  Meteor.publish('ledger', function (world) {\n    check(world, String);\n    return Ledger.find({world: world});\n  });\n\nMeteor.methods({\n  'ledger/transfer': function (world, from_name, to_name, amount, cheat) {\n    check(world, String);\n    check(from_name, String);\n    check(to_name, String);\n    check(amount, Number);\n    check(cheat, Match.Optional(Boolean));\n    var from = Ledger.findOne({name: from_name, world: world});\n    var to = Ledger.findOne({name: to_name, world: world});\n\n    if (Meteor.isServer)\n      cheat = false;\n\n    if (!from)\n      throw new Meteor.Error(404,\n                             \"No such account \" + from_name + \" in \" + world);\n\n    if (!to)\n      throw new Meteor.Error(404,\n                             \"No such account \" + to_name + \" in \" + world);\n\n    if (from.balance < amount && !cheat)\n      throw new Meteor.Error(409, \"Insufficient funds\");\n\n    Ledger.update(from._id, {$inc: {balance: -amount}});\n    Ledger.update(to._id, {$inc: {balance: amount}});\n  }\n});\n\n/*****/\n\n/// Helpers for \"livedata - changing userid reruns subscriptions...\"\n\nobjectsWithUsers = new Meteor.Collection(\"objectsWithUsers\");\n\nif (Meteor.isServer) {\n  objectsWithUsers.remove({});\n  objectsWithUsers.insert({name: \"owned by none\", ownerUserIds: [null]});\n  objectsWithUsers.insert({name: \"owned by one - a\", ownerUserIds: [\"1\"]});\n  objectsWithUsers.insert({name: \"owned by one/two - a\", ownerUserIds: [\"1\", \"2\"]});\n  objectsWithUsers.insert({name: \"owned by one/two - b\", ownerUserIds: [\"1\", \"2\"]});\n  objectsWithUsers.insert({name: \"owned by two - a\", ownerUserIds: [\"2\"]});\n  objectsWithUsers.insert({name: \"owned by two - b\", ownerUserIds: [\"2\"]});\n\n  Meteor.publish(\"objectsWithUsers\", function() {\n    return objectsWithUsers.find({ownerUserIds: this.userId},\n                                 {fields: {ownerUserIds: 0}});\n  });\n\n  (function () {\n    var userIdWhenStopped = {};\n    Meteor.publish(\"recordUserIdOnStop\", function (key) {\n      check(key, String);\n      var self = this;\n      self.onStop(function() {\n        userIdWhenStopped[key] = self.userId;\n      });\n    });\n\n    Meteor.methods({\n      userIdWhenStopped: function (key) {\n        check(key, String);\n        return userIdWhenStopped[key];\n      }\n    });\n  })();\n}\n\n/*****/\n\n/// Helper for \"livedata - setUserId fails when called on server\"\n\nif (Meteor.isServer) {\n  Meteor.startup(function() {\n    errorThrownWhenCallingSetUserIdDirectlyOnServer = null;\n    try {\n      Meteor.call(\"setUserId\", \"1000\");\n    } catch (e) {\n      errorThrownWhenCallingSetUserIdDirectlyOnServer = e;\n    }\n  });\n}\n\n/// Helper for \"livedata - no setUserId after unblock\"\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    setUserIdAfterUnblock: function () {\n      this.unblock();\n      var threw = false;\n      var originalUserId = this.userId;\n      try {\n        // Calling setUserId after unblock should throw an error (and not mutate\n        // userId).\n        this.setUserId(originalUserId + \"bla\");\n      } catch (e) {\n        threw = true;\n      }\n      return threw && this.userId === originalUserId;\n    }\n  });\n}\n\n/*****/\n\n/// Helper for \"livedata - overlapping universal subs\"\n\nif (Meteor.isServer) {\n  (function(){\n    var collName = \"overlappingUniversalSubs\";\n    var universalSubscribers = [[], []];\n\n    _.each([0, 1], function (index) {\n      Meteor.publish(null, function () {\n        var sub = this;\n        universalSubscribers[index].push(sub);\n        sub.onStop(function () {\n          universalSubscribers[index] = _.without(\n            universalSubscribers[index], sub);\n        });\n      });\n    });\n\n    Meteor.methods({\n      testOverlappingSubs: function (token) {\n        check(token, String);\n        _.each(universalSubscribers[0], function (sub) {\n          sub.added(collName, token, {});\n        });\n        _.each(universalSubscribers[1], function (sub) {\n          sub.added(collName, token, {});\n        });\n        _.each(universalSubscribers[0], function (sub) {\n          sub.removed(collName, token);\n        });\n      }\n    });\n  })();\n}\n\n/// Helper for \"livedata - runtime universal sub creation\"\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    runtimeUniversalSubCreation: function (token) {\n      check(token, String);\n      Meteor.publish(null, function () {\n        this.added(\"runtimeSubCreation\", token, {});\n      });\n    }\n  });\n}\n\n/// Helper for \"livedata - publisher errors\"\n\nif (Meteor.isServer) {\n  Meteor.publish(\"publisherErrors\", function (collName, options) {\n    check(collName, String);\n    // See below to see what options are accepted.\n    check(options, Object);\n    var sub = this;\n\n    // First add a random item, which should be cleaned up. We use ready/onReady\n    // to make sure that the second test block is only called after the added is\n    // processed, so that there's any chance of the coll.find().count() failing.\n    sub.added(collName, Random.id(), {foo: 42});\n    sub.ready();\n\n    if (options.stopInHandler) {\n      sub.stop();\n      return;\n    }\n\n    var error;\n    if (options.internalError) {\n      error = new Error(\"Egads!\");\n      error.expected = true;  // don't log\n    } else {\n      error = new Meteor.Error(412, \"Explicit error\");\n    }\n    if (options.throwInHandler) {\n      throw error;\n    } else if (options.errorInHandler) {\n      sub.error(error);\n    } else if (options.throwWhenUserIdSet) {\n      if (sub.userId)\n        throw error;\n    } else if (options.errorLater) {\n      Meteor.defer(function () {\n        sub.error(error);\n      });\n    }\n  });\n}\n\n\n/*****/\n\n/// Helpers for \"livedata - publish multiple cursors\"\nOne = new Meteor.Collection(\"collectionOne\");\nTwo = new Meteor.Collection(\"collectionTwo\");\n\nif (Meteor.isServer) {\n  One.remove({});\n  One.insert({name: \"value1\"});\n  One.insert({name: \"value2\"});\n\n  Two.remove({});\n  Two.insert({name: \"value3\"});\n  Two.insert({name: \"value4\"});\n  Two.insert({name: \"value5\"});\n\n  Meteor.publish(\"multiPublish\", function (options) {\n    // See below to see what options are accepted.\n    check(options, Object);\n    if (options.normal) {\n      return [\n        One.find(),\n        Two.find()\n      ];\n    } else if (options.dup) {\n      // Suppress the log of the expected internal error.\n      Meteor._suppress_log(1);\n      return [\n        One.find(),\n        One.find({name: \"value2\"}), // multiple cursors for one collection - error\n        Two.find()\n      ];\n    } else if (options.notCursor) {\n      // Suppress the log of the expected internal error.\n      Meteor._suppress_log(1);\n      return [\n        One.find(),\n        \"not a cursor\",\n        Two.find()\n      ];\n    } else\n      throw \"unexpected options\";\n  });\n}\n","var newView = function(test) {\n  var results = [];\n  var view = new LivedataTest.SessionCollectionView('test', {\n    added: function (collection, id, fields) {\n      results.push({fun: 'added', id: id, fields: fields});\n    },\n    changed: function (collection, id, changed) {\n      if (_.isEmpty(changed))\n        return;\n      results.push({fun: 'changed', id: id, changed: changed});\n    },\n    removed: function (collection, id) {\n      results.push({fun: 'removed', id: id});\n    }\n  });\n  var v = {\n    view: view,\n    results: results\n  };\n  _.each([\"added\", \"changed\", \"removed\"], function (it) {\n    v[it] = _.bind(view[it], view);\n  });\n  v.expectResult = function (result) {\n    test.equal(results.shift(), result);\n  };\n  v.expectNoResult = function () {\n    test.equal(results, []);\n  };\n  v.drain = function() {\n    var ret = results;\n    results = [];\n    return ret;\n  };\n  return v;\n};\n\nTinytest.add('livedata - sessionview - exists reveal', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\", \"A1\", {});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {}});\n  v.expectNoResult();\n\n  v.added(\"B\", \"A1\", {});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - added a second field in another sub', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\", \"A1\", {a: \"foo\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {a: \"foo\"}});\n  v.expectNoResult();\n\n  v.added(\"B\", \"A1\", {a: \"foo\", b: \"bar\"});\n  v.expectResult({fun: 'changed', 'id': \"A1\", changed: {b: \"bar\"}});\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\n\nTinytest.add('livedata - sessionview - field reveal', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.added(\"B\",  \"A1\", {foo: \"baz\"});\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: \"baz\"}});\n  v.expectNoResult();\n  // Somewhere in here we must have changed foo to baz. Legal either on the\n  // added or on the removed, but only once.\n\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - field change', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.changed(\"A\", \"A1\", {foo: \"baz\"}, []);\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: \"baz\"}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - field clear', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.changed(\"A\", \"A1\", {foo: undefined});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: undefined}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - change makes a new field', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.changed(\"A\", \"A1\", {baz:\"quux\"});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {baz: \"quux\"}});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - add, remove, add', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n});\n\nTinytest.add('livedata - sessionview - field clear reveal', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n\n  v.added(\"B\",  \"A1\", {foo: \"baz\"});\n  v.changed(\"A\", \"A1\", {foo: undefined});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: \"baz\"}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - change to canonical value produces no change', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n\n  v.added(\"B\",  \"A1\", {foo: \"baz\"});\n  var canon = \"bar\";\n  var maybeResults = v.drain();\n  if (!_.isEmpty(maybeResults)) {\n    // if something happened, it was a change message to baz.\n    // if nothing did, canon is still bar.\n    test.length(maybeResults, 1);\n    test.equal(maybeResults[0], {fun: 'changed', id: \"A1\", changed: {foo: \"baz\"}});\n    canon = \"baz\";\n  }\n  v.changed(\"B\", \"A1\", {foo: canon});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - new field of canonical value produces no change', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n\n  v.added(\"B\",  \"A1\", {});\n\n  v.changed(\"B\", \"A1\", {foo: \"bar\"});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - clear all clears only once', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.added(\"B\",  \"A1\", {foo: \"bar\"});\n  v.added(\"C\",  \"A1\", {foo: \"bar\"});\n  v.changed(\"A\", \"A1\", {foo: undefined});\n  v.changed(\"B\", \"A1\", {foo: undefined});\n  v.changed(\"C\", \"A1\", {foo: undefined});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: undefined}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - change all changes only once', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\"}});\n  v.expectNoResult();\n\n  v.added(\"B\",  \"A1\", {foo: \"bar\"});\n  v.added(\"C\",  \"A1\", {foo: \"bar\"});\n  v.changed(\"B\", \"A1\", {foo: \"baz\"});\n  v.changed(\"A\", \"A1\", {foo: \"baz\"});\n  v.changed(\"C\", \"A1\", {foo: \"baz\"});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: \"baz\"}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - multiple operations at once in a change', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\", baz: \"quux\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\", baz: \"quux\"}});\n  v.expectNoResult();\n\n\n  v.added(\"B\",  \"A1\", {foo: \"baz\"});\n  v.changed(\"A\", \"A1\", {thing: \"stuff\", foo: undefined, baz: undefined});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: \"baz\", thing: \"stuff\", baz: undefined}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {thing: undefined}});\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - more than one document', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\", baz: \"quux\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\", baz: \"quux\"}});\n  v.expectNoResult();\n\n\n  v.added(\"A\", \"A2\", {foo: \"baz\"});\n  v.expectResult({fun: 'added', id: \"A2\", fields: {foo: \"baz\"}});\n  v.changed(\"A\", \"A1\", {thing: \"stuff\", foo: undefined, baz: undefined});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {thing: \"stuff\", foo: undefined, baz: undefined}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n  v.removed(\"A\", \"A2\");\n  v.expectResult({fun: 'removed', id: \"A2\"});\n  v.expectNoResult();\n\n});\n\nTinytest.add('livedata - sessionview - multiple docs removed', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\", baz: \"quux\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\", baz: \"quux\"}});\n  v.expectNoResult();\n\n\n  v.added(\"A\", \"A2\", {foo: \"baz\"});\n  v.expectResult({fun: 'added', id: \"A2\", fields: {foo: \"baz\"}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.removed(\"A\", \"A2\");\n  v.expectResult({fun: 'removed', id: \"A2\"});\n  v.expectNoResult();\n});\n\n\nTinytest.add('livedata - sessionview - complicated sequence', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\",  \"A1\", {foo: \"bar\", baz: \"quux\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: \"bar\", baz: \"quux\"}});\n  v.expectNoResult();\n\n  v.added(\"A\", \"A2\", {foo: \"eats\"});\n  v.expectResult({fun: 'added', id: \"A2\", fields: {foo: \"eats\"}});\n\n  v.added(\"B\",  \"A1\", {foo: \"baz\"});\n  v.changed(\"A\", \"A1\", {thing: \"stuff\", foo: undefined, baz: undefined});\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {foo: \"baz\", thing: \"stuff\", baz: undefined}});\n  v.expectNoResult();\n\n  v.removed(\"A\", \"A1\");\n  v.removed(\"A\", \"A2\");\n  v.expectResult({fun: 'changed', id: \"A1\", changed: {thing: undefined}});\n  v.expectResult({fun: 'removed', id: \"A2\"});\n  v.expectNoResult();\n  v.removed(\"B\", \"A1\");\n  v.expectResult({fun: 'removed', id: \"A1\"});\n  v.expectNoResult();\n});\n\nTinytest.add('livedata - sessionview - added becomes changed', function (test) {\n  var v = newView(test);\n\n  v.added('A',  \"A1\", {foo: 'bar'});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {foo: 'bar'}});\n\n  v.added('B',  \"A1\", {hi: 'there'});\n  v.expectResult({fun: 'changed', id: 'A1', changed: {hi: 'there'}});\n\n  v.removed('A', 'A1');\n  v.expectResult({fun: 'changed', id: 'A1', changed: {foo: undefined}});\n\n  v.removed('B', 'A1');\n  v.expectResult({fun: 'removed', id: 'A1'});\n});\n\nTinytest.add('livedata - sessionview - weird key names', function (test) {\n  var v = newView(test);\n\n  v.added('A',  \"A1\", {});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {}});\n\n  v.changed('A',  \"A1\", {constructor: 'bla'});\n  v.expectResult({fun: 'changed', id: 'A1', changed: {constructor: 'bla'}});\n});\n\nTinytest.add('livedata - sessionview - clear undefined value', function (test) {\n  var v = newView(test);\n\n  v.added(\"A\", \"A1\", {field: \"value\"});\n  v.expectResult({fun: 'added', id: \"A1\", fields: {field: \"value\"}});\n  v.expectNoResult();\n\n  v.changed(\"A\", \"A1\", {field: undefined});\n  v.expectResult({fun: 'changed', id: 'A1', changed: {field: undefined}});\n  v.expectNoResult();\n\n  v.changed(\"A\", \"A1\", {field: undefined});\n  v.expectNoResult();\n\n});\n","// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar;\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\", id: \"X\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n\n  test.isFalse(crossbar._matches({collection: \"C\", id: \"X\"},\n                                 {collection: \"C\", id: \"Y\"}));\n});\n","var Fiber = Npm.require('fibers');\n\nTinytest.addAsync(\"stream client - callbacks run in a fiber\", function (test, onComplete) {\n  stream = new LivedataTest.ClientStream(\n    Meteor.absoluteUrl(),\n    {\n      _testOnClose: function () {\n        test.isTrue(Fiber.current);\n        onComplete();\n      }\n    }\n  );\n  stream.on('reset', function () {\n    test.isTrue(Fiber.current);\n    stream.disconnect();\n  });\n});\n"]}