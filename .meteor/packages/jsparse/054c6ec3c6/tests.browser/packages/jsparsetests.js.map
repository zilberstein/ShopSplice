{"version":3,"file":"/packages/jsparse:tests.js","sources":["jsparse/parser_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,kD;;AAEA,oB;AACA,M;AACA,U;AACA,e;AACA,W;AACA,e;AACA,Y;AACA,Y;AACA,e;AACA,S;AACA,S;AACA,U;AACA,U;AACA,Y;AACA,kB;AACA,kB;AACA,Y;AACA,Y;AACA,Q;AACA,e;AACA,oB;AACA,Y;AACA,c;AACA,Y;AACA,a;AACA,iB;AACA,e;AACA,iB;AACA,iB;AACA,e;AACA,e;AACA,Y;AACA,e;AACA,Q;AACA,Y;AACA,Q;AACA,S;AACA,gB;AACA,W;AACA,W;AACA,W;AACA,Y;AACA,Y;AACA,S;AACA,U;AACA,gB;AACA,gB;AACA,W;AACA,gB;AACA,Y;AACA,S;AACA,e;AACA,a;AACA,U;AACA,Y;AACA,a;AACA,e;AACA,a;AACA,E;;AAEA,yB;AACA,kE;;;AAGA,kC;AACA,U;AACA,8D;AACA,qE;AACA,mE;;AAEA,8C;AACA,oC;AACA,gC;AACA,sC;AACA,mC;AACA,0B;AACA,wD;AACA,0B;AACA,qC;AACA,wE;AACA,0C;AACA,O;;AAEA,yD;AACA,8C;;AAEA,6B;AACA,mC;AACA,wC;AACA,2C;AACA,mC;AACA,4D;AACA,qD;AACA,sD;AACA,uC;AACA,8C;AACA,qD;AACA,wC;AACA,kE;AACA,+D;AACA,gE;AACA,8B;AACA,0C;AACA,0D;AACA,oE;AACA,oE;AACA,sD;AACA,uE;AACA,8D;AACA,+E;AACA,+E;AACA,gF;AACA,uC;AACA,W;AACA,gB;AACA,kD;AACA,S;AACA,Q;;AAEA,wB;AACA,qD;AACA,uD;;AAEA,0C;;AAEA,iD;AACA,0D;AACA,M;AACA,6D;AACA,oE;AACA,kE;AACA,iE;AACA,qB;AACA,M;AACA,kE;AACA,wD;AACA,+B;AACA,mD;AACA,sD;AACA,mE;AACA,Q;AACA,kC;AACA,0C;AACA,oC;;AAEA,yB;AACA,uB;AACA,W;AACA,yE;AACA,sB;AACA,mB;AACA,kB;AACA,O;AACA,2B;AACA,yB;AACA,6D;AACA,M;AACA,+D;AACA,yE;AACA,oE;AACA,mE;AACA,wE;AACA,M;AACA,sE;AACA,yE;AACA,uE;AACA,oE;AACA,iD;AACA,M;AACA,mE;AACA,4B;AACA,+B;AACA,yE;AACA,8E;AACA,wE;AACA,Q;AACA,kC;;AAEA,4C;AACA,oE;AACA,8D;AACA,wC;;AAEA,yB;AACA,uB;AACA,yD;AACA,W;AACA,0C;AACA,sB;AACA,mB;AACA,kB;AACA,O;AACA,2B;AACA,yB;AACA,8B;AACA,oC;AACA,2C;AACA,iC;AACA,qE;AACA,yB;AACA,O;AACA,K;AACA,I;AACA,E;;;AAGA,kD;AACA,gC;AACA,mE;AACA,2F;AACA,iG;AACA,wD;AACA,0F;AACA,yG;AACA,oC;AACA,sC;AACA,qG;AACA,2E;AACA,0F;AACA,qF;AACA,kF;AACA,oF;AACA,mB;AACA,sB;AACA,iE;AACA,mB;AACA,2C;AACA,6E;AACA,qD;;AAEA,0C;AACA,oC;AACA,qC;AACA,G;;AAEA,+D;AACA,gC;AACA,4B;AACA,iE;AACA,iE;AACA,uC;AACA,yC;AACA,yC;AACA,G;;AAEA,wD;AACA,gC;AACA,gB;AACA,iB;AACA,S;AACA,gD;AACA,c;AACA,wF;AACA,wC;AACA,U;AACA,iC;AACA,c;AACA,iE;AACA,2B;AACA,iF;AACA,6D;AACA,c;AACA,iE;AACA,mC;AACA,oF;AACA,uD;AACA,qB;AACA,2F;AACA,qB;AACA,iF;AACA,wB;AACA,wF;AACA,6C;AACA,4E;AACA,mF;AACA,4E;AACA,mE;AACA,+E;AACA,iE;AACA,sB;AACA,wE;AACA,0D;AACA,wE;AACA,0E;AACA,yE;AACA,oC;AACA,yD;AACA,kE;AACA,wB;AACA,4F;AACA,6B;AACA,2F;AACA,wC;AACA,8B;AACA,gG;AACA,wD;AACA,gB;AACA,oF;AACA,oB;AACA,+F;AACA,wB;AACA,mG;AACA,qB;AACA,gG;AACA,+B;AACA,0E;AACA,iG;AACA,2B;AACA,gG;AACA,wB;AACA,yB;AACA,0G;AACA,c;AACA,+C;AACA,e;AACA,6C;AACA,mB;AACA,oD;AACA,oB;AACA,kD;AACA,mB;AACA,kG;AACA,sB;AACA,uE;AACA,gB;AACA,mD;AACA,oB;AACA,iD;AACA,qB;AACA,+C;AACA,wB;AACA,sF;AACA,a;AACA,6C;AACA,iB;AACA,2C;AACA,kB;AACA,yC;AACA,qB;AACA,gF;AACA,gB;AACA,mD;AACA,e;AACA,qD;AACA,wB;AACA,gE;AACA,gB;AACA,qE;AACA,oB;AACA,mG;AACA,oB;AACA,+D;AACA,wD;AACA,4D;AACA,8E;AACA,sD;AACA,oE;AACA,4D;AACA,8D;AACA,sD;AACA,iD;AACA,6B;AACA,gG;AACA,sC;AACA,qF;AACA,2C;AACA,yB;AACA,sF;AACA,2B;AACA,4F;AACA,W;AACA,+C;AACA,a;AACA,gF;AACA,iB;AACA,4D;AACA,6D;AACA,wB;AACA,8D;AACA,6E;AACA,gB;AACA,6C;AACA,iB;AACA,2C;AACA,yB;AACA,wD;AACA,0C;AACA,+F;AACA,2B;AACA,kF;AACA,qC;AACA,8B;AACA,kE;;AAEA,kB;AACA,8B;AACA,iF;AACA,0C;AACA,W;AACA,0D;AACA,a;AACA,wD;AACA,gB;AACA,sD;AACA,Y;AACA,kD;AACA,a;AACA,mD;AACA,c;AACA,oD;AACA,iC;AACA,uE;AACA,sB;AACA,+D;AACA,8C;AACA,kC;AACA,oF;AACA,8C;AACA,qB;AACA,+D;AACA,kD;AACA,6C;AACA,sF;AACA,gF;AACA,qF;AACA,wB;AACA,W;AACA,+C;AACA,c;AACA,qD;AACA,mB;AACA,sE;AACA,6C;AACA,a;AACA,gE;AACA,gB;AACA,iG;AACA,mB;AACA,oG;AACA,iC;AACA,6E;AACA,kF;AACA,kC;AACA,yB;AACA,6F;AACA,4B;AACA,2F;AACA,6B;AACA,6E;AACA,8C;AACA,yB;AACA,wE;AACA,kC;AACA,6B;AACA,4E;AACA,sC;AACA,oB;AACA,0E;AACA,mC;AACA,6E;AACA,mF;AACA,+C;AACA,wB;AACA,+E;AACA,6C;AACA,0B;AACA,qD;AACA,mF;AACA,4B;AACA,yD;AACA,2F;AACA,yB;AACA,0E;AACA,+D;AACA,yB;AACA,+F;AACA,2C;AACA,sF;AACA,qE;AACA,iB;AACA,oE;AACA,uC;AACA,e;AACA,sE;AACA,+C;AACA,mF;AACA,kF;AACA,sF;AACA,6E;AACA,6F;AACA,mF;AACA,yF;AACA,kF;AACA,+E;AACA,6B;AACA,mF;AACA,iF;AACA,8E;AACA,yF;AACA,yF;AACA,wF;AACA,mF;AACA,0E;AACA,gF;AACA,sC;AACA,a;AACA,yE;AACA,6B;AACA,oB;AACA,0E;AACA,qF;AACA,e;AACA,mF;AACA,yD;AACA,e;AACA,qF;AACA,4D;AACA,sB;AACA,mF;AACA,gF;AACA,8C;AACA,sF;AACA,oE;AACA,kE;AACA,oE;AACA,iE;AACA,mE;AACA,yE;AACA,qF;AACA,8C;AACA,a;AACA,gC;AACA,e;AACA,gC;AACA,e;AACA,kC;AACA,iB;AACA,kC;AACA,gB;AACA,8C;AACA,kB;AACA,gD;AACA,mB;AACA,4D;AACA,qB;AACA,8D;AACA,0B;AACA,2E;AACA,6B;AACA,+E;AACA,wB;AACA,4D;AACA,4B;AACA,8D;AACA,+B;AACA,6C;AACA,4B;AACA,+B;AACA,2B;AACA,kE;AACA,0D;AACA,sF;AACA,gD;AACA,0C;AACA,oC;AACA,kD;AACA,2D;AACA,kE;AACA,qB;AACA,gF;AACA,mB;AACA,8E;AACA,mB;AACA,8E;AACA,kB;AACA,qG;AACA,kB;AACA,qG;AACA,gB;AACA,mG;AACA,gD;AACA,8B;AACA,sE;AACA,2C;AACA,a;AACA,gE;AACA,gB;AACA,gG;AACA,iB;AACA,kG;AACA,oB;AACA,uF;AACA,oD;AACA,qB;AACA,uF;AACA,qD;AACA,I;AACA,gC;AACA,mC;AACA,K;AACA,G;;AAEA,sD;AACA,gC;AACA,yE;AACA,6D;AACA,gB;AACA,mB;AACA,wB;AACA,iB;AACA,oB;AACA,4B;AACA,gB;AACA,+B;AACA,yB;AACA,qB;AACA,uB;AACA,gC;AACA,+B;AACA,4B;AACA,wB;AACA,yB;AACA,0B;AACA,wC;AACA,2B;AACA,0B;AACA,2B;AACA,oB;AACA,iB;AACA,oB;AACA,uB;AACA,8B;AACA,sB;AACA,sB;AACA,iC;AACA,wC;AACA,qB;AACA,uB;AACA,4B;AACA,mB;AACA,2B;AACA,sB;AACA,wB;AACA,qB;AACA,wB;AACA,iC;AACA,mB;AACA,gC;AACA,uB;AACA,0B;AACA,0B;AACA,e;AACA,2B;AACA,8B;AACA,e;AACA,iC;AACA,8B;AACA,oB;AACA,+B;AACA,gC;AACA,iC;AACA,I;AACA,gC;AACA,wB;AACA,K;AACA,G;;AAEA,oE;AACA,gC;AACA,kC;AACA,+F;AACA,8B;AACA,8B;AACA,+E;AACA,8B;AACA,8B;AACA,yF;AACA,sD;AACA,gC;AACA,2F;AACA,yC;AACA,sD;AACA,yB;AACA,+D;AACA,G;;AAEA,+D;AACA,gC;AACA,uB;AACA,0C;AACA,oF;AACA,6F;AACA,6C;AACA,mC;AACA,6D;AACA,kF;AACA,gC;AACA,6F;AACA,oE;AACA,uD;AACA,gD;AACA,0E;AACA,8E;AACA,2F;AACA,G;;AAEA,oD;AACA,gC;AACA,2E;AACA,uB;AACA,uC;AACA,8B;AACA,6F;AACA,G;;AAEA,6D;AACA,gC;AACA,2B;AACA,uD;AACA,wB;AACA,S;AACA,6B;AACA,kB;AACA,iB;AACA,2D;AACA,K;AACA,I;;AAEA,c;AACA,c;AACA,G","sourcesContent":["var parserTestOptions = { includeComments: true };\n\nvar allNodeNames = [\n  \";\",\n  \"array\",\n  \"assignment\",\n  \"binary\",\n  \"blockStmnt\",\n  \"boolean\",\n  \"bracket\",\n  \"breakStmnt\",\n  \"call\",\n  \"case\",\n  \"catch\",\n  \"comma\",\n  \"comment\",\n  \"continueStmnt\",\n  \"debuggerStmnt\",\n  \"default\",\n  \"doStmnt\",\n  \"dot\",\n  \"emptyStmnt\",\n  \"expressionStmnt\",\n  \"finally\",\n  \"forInSpec\",\n  \"forSpec\",\n  \"forStmnt\",\n  \"forVarInSpec\",\n  \"forVarSpec\",\n  \"functionDecl\",\n  \"functionExpr\",\n  \"idPropName\",\n  \"identifier\",\n  \"ifStmnt\",\n  \"labelStmnt\",\n  \"new\",\n  \"newcall\",\n  \"nil\",\n  \"null\",\n  \"numPropName\",\n  \"number\",\n  \"object\",\n  \"parens\",\n  \"postfix\",\n  \"program\",\n  \"prop\",\n  \"regex\",\n  \"returnStmnt\",\n  \"strPropName\",\n  \"string\",\n  \"switchStmnt\",\n  \"ternary\",\n  \"this\",\n  \"throwStmnt\",\n  \"tryStmnt\",\n  \"unary\",\n  \"varDecl\",\n  \"varStmnt\",\n  \"whileStmnt\",\n  \"withStmnt\"\n];\n\nvar allNodeNamesSet = {};\n_.each(allNodeNames, function (n) { allNodeNamesSet[n] = true; });\n\n\nvar makeTester = function (test) {\n  return {\n    // Parse code and make sure it matches expectedTreeString.\n    goodParse: function (code, expectedTreeString, regexTokenHints) {\n      var expectedTree = ParseNode.unstringify(expectedTreeString);\n\n      // first use lexer to collect all tokens\n      var lexer = new JSLexer(code);\n      var allTokensInOrder = [];\n      while (! lexer.next().isEOF()) {\n        var lex = lexer.lastLexeme;\n        if (lex.isError())\n          test.fail(\"Lexer error at \" + lex.startPos());\n        if (lex.isToken())\n          allTokensInOrder.push(lex);\n        if (regexTokenHints && regexTokenHints[allTokensInOrder.length])\n          lexer.divisionPermitted = false;\n      }\n\n      var parser = new JSParser(code, parserTestOptions);\n      var actualTree = parser.getSyntaxTree();\n\n      var nextTokenIndex = 0;\n      var check = function (tree) {\n        if (tree instanceof ParseNode) {\n          // This is a NODE (non-terminal).\n          var nodeName = tree.name;\n          if (! (nodeName && typeof nodeName === \"string\" &&\n                 allNodeNamesSet[nodeName] === true))\n            test.fail(\"Not a node name: \" + nodeName);\n          _.each(tree.children, check);\n        } else if (typeof tree === 'object' &&\n                   typeof tree.text === 'function') {\n          // This is a TOKEN (terminal).\n          // Make sure we are visiting every token once, in order.\n          // Make an exception for any comment lexemes present,\n          // because we couldn't know whether to include them in\n          // allTokensInOrder.\n          if (tree.type() !== \"COMMENT\") {\n            if (nextTokenIndex >= allTokensInOrder.length)\n              test.fail(\"Too many tokens: \" + (nextTokenIndex + 1));\n            var referenceToken = allTokensInOrder[nextTokenIndex++];\n            if (tree.text() !== referenceToken.text())\n              test.fail(tree.text() + \" !== \" + referenceToken.text());\n            if (tree.startPos() !== referenceToken.startPos())\n              test.fail(tree.startPos() + \" !== \" + referenceToken.startPos());\n            if (code.substring(tree.startPos(), tree.endPos()) !== tree.text())\n              test.fail(\"Didn't see \" + tree.text() + \" at \" + tree.startPos() +\n                        \" in \" + code);\n          }\n        } else {\n          test.fail(\"Unknown tree part: \" + tree);\n        }\n      };\n\n      check(actualTree);\n      if (nextTokenIndex !== allTokensInOrder.length)\n        test.fail(\"Too few tokens: \" + nextTokenIndex);\n\n      test.equal(parser.pos, code.length);\n\n      test.equal(ParseNode.stringify(actualTree),\n                 ParseNode.stringify(expectedTree), code);\n    },\n    // Takes code with part of it surrounding with backticks.\n    // Removes the two backtick characters, tries to parse the code,\n    // and then asserts that there was a tokenization-level error,\n    // with the part that was between the backticks called out as\n    // the bad token.\n    //\n    // For example, the test \"123`@`\" will try to parse \"123@\" and\n    // assert that a tokenization error occurred at '@'.\n    badToken: function (code) {\n      var constructMessage = function (pos, text) {\n        var nicePos = JSLexer.prettyOffset(code, pos);\n        return \"Bad token at \" + nicePos + \", text `\" + text + \"`\";\n      };\n      var pos = code.indexOf('`');\n      var text = code.match(/`(.*?)`/)[1];\n      code = code.replace(/`/g, '');\n\n      var parsed = false;\n      var error = null;\n      try {\n        var tree = new JSParser(code, parserTestOptions).getSyntaxTree();\n        parsed = true;\n      } catch (e) {\n        error = e;\n      }\n      test.isFalse(parsed);\n      test.isTrue(error);\n      test.equal(error.message, constructMessage(pos, text));\n    },\n    // Takes code with a backtick-quoted string embedded in it.\n    // Removes the backticks and their contents, tries to parse the code,\n    // and then asserts that there was a parse error at the location\n    // where the backtick-quoted string was embedded.  The embedded\n    // string must match whatever the error message says was \"expected\".\n    //\n    // For example, the test \"{`statement`\" will try to parse the code\n    // \"{\" and then assert that an error occured at the end of the string\n    // saying \"Expected statement\".  The test \"1 `semicolon`2\" will try\n    // to parse \"1 2\" and assert that the error \"Expected semicolon\"\n    // appeared after the space and before the 2.\n    //\n    // A second backtick-quoted string is used as the \"found\" token\n    // in the error message.\n    badParse: function (code) {\n      var constructMessage = function (whatExpected, pos, found, after) {\n        return \"Expected \" + whatExpected + (after ? \" after \" + after : \"\") +\n          \" at \" + JSLexer.prettyOffset(code, pos) + \", found \" + found;\n      };\n      var pos = code.indexOf('`');\n\n      var backticked = code.match(/`.*?`/g);\n      var whatExpected = backticked[0] && backticked[0].slice(1,-1);\n      var found = backticked[1] && backticked[1].slice(1, -1);\n      code = code.replace(/`.*?`/g, '');\n\n      var parsed = false;\n      var error = null;\n      var parser = new JSParser(code, parserTestOptions);\n      try {\n        var tree = parser.getSyntaxTree();\n        parsed = true;\n      } catch (e) {\n        error = e;\n      }\n      test.isFalse(parsed);\n      test.isTrue(error);\n      if (! parsed && error) {\n        var after = parser.oldToken;\n        found = (found || parser.newToken);\n        test.equal(error.message,\n                   constructMessage(whatExpected, pos, found, after),\n                   code);\n      }\n    }\n  };\n};\n\n\nTinytest.add(\"jsparse - basics\", function (test) {\n  var tester = makeTester(test);\n  tester.goodParse('1', \"program(expressionStmnt(number(1) ;()))\");\n  tester.goodParse('1 + 1', \"program(expressionStmnt(binary(number(1) + number(1)) ;()))\");\n  tester.goodParse('1*2+3*4', \"program(expressionStmnt(binary(binary(number(1) * number(2)) + \" +\n                \"binary(number(3) * number(4))) ;()))\");\n  tester.goodParse('1 + 1;', \"program(expressionStmnt(binary(number(1) + number(1)) ;))\");\n  tester.goodParse('1 + 1;;', \"program(expressionStmnt(binary(number(1) + number(1)) ;) emptyStmnt(;))\");\n  tester.goodParse('', \"program()\");\n  tester.goodParse('\\n', \"program()\");\n  tester.goodParse(';;;\\n\\n;\\n', \"program(emptyStmnt(;) emptyStmnt(;) emptyStmnt(;) emptyStmnt(;))\");\n  tester.goodParse('foo', \"program(expressionStmnt(identifier(foo) ;()))\");\n  tester.goodParse('foo();', \"program(expressionStmnt(call(identifier(foo) `(` `)`) ;))\");\n  tester.goodParse('var x = 3', \"program(varStmnt(var varDecl(x = number(3)) ;()))\");\n  tester.goodParse('++x;', \"program(expressionStmnt(unary(++ identifier(x)) ;))\");\n  tester.goodParse('x++;', \"program(expressionStmnt(postfix(identifier(x) ++) ;))\");\n  tester.goodParse(\n    'throw new Error',\n    \"program(throwStmnt(throw new(new identifier(Error)) ;()))\");\n  tester.goodParse(\n    'var x = function () { return 123; };',\n    'program(varStmnt(var varDecl(x = functionExpr(function nil() `(` `)` ' +\n      '{ returnStmnt(return number(123) ;) })) ;))');\n\n  tester.badParse(\"var x = `expression`\");\n  tester.badParse(\"1 `semicolon`1\");\n  tester.badParse(\"1+1`semicolon`:\");\n});\n\nTinytest.add(\"jsparse - tokenization errors\", function (test) {\n  var tester = makeTester(test);\n  tester.badToken(\"123`@`\");\n  tester.badToken(\"thisIsATestOf = `'unterminated `\\n strings'\");\n  // make sure newlines aren't quietly included in regex literals\n  tester.badToken(\"var x = `/`a\\nb/;\");\n  tester.badToken(\"var x = `/`a\\\\\\nb/;\");\n  tester.badToken(\"var x = `/`a[\\n]b/;\");\n});\n\nTinytest.add(\"jsparse - syntax forms\", function (test) {\n  var tester = makeTester(test);\n  var trials = [\n    // STATEMENTS\n    ['1',\n     'program(expressionStmnt(number(1) ;()))'],\n    ['1;;;;2',\n     'program(expressionStmnt(number(1) ;) emptyStmnt(;) emptyStmnt(;) emptyStmnt(;) ' +\n     'expressionStmnt(number(2) ;()))'],\n    ['{}',\n     'program(blockStmnt({ }))'],\n    ['{null}',\n     'program(blockStmnt({ expressionStmnt(null(null) ;()) }))'],\n    ['{\\nfoo()\\nbar();\\n}',\n     'program(blockStmnt({ expressionStmnt(call(identifier(foo) `(` `)`) ;()) ' +\n     'expressionStmnt(call(identifier(bar) `(` `)`) ;) }))'],\n    ['{{{}}}',\n     'program(blockStmnt({ blockStmnt({ blockStmnt({ }) }) }))'],\n    ['var x = y, z,\\n  a = b = c;',\n     'program(varStmnt(var varDecl(x = identifier(y)) , varDecl(z) , varDecl(a = ' +\n     'assignment(identifier(b) = identifier(c))) ;))'],\n    ['if (x === y);',\n     'program(ifStmnt(if `(` binary(identifier(x) === identifier(y)) `)` emptyStmnt(;)))'],\n    ['if (z) return',\n     'program(ifStmnt(if `(` identifier(z) `)` returnStmnt(return nil() ;())))'],\n    ['if (a) b; else c',\n     'program(ifStmnt(if `(` identifier(a) `)` expressionStmnt(identifier(b) ;) else ' +\n     'expressionStmnt(identifier(c) ;())))'],\n    ['if (n === 1) { foo(); } else if (n === 2) { bar(); } else { baz(); }',\n     'program(ifStmnt(if `(` binary(identifier(n) === number(1)) `)` blockStmnt(' +\n     '{ expressionStmnt(call(identifier(foo) `(` `)`) ;) }) else ifStmnt(' +\n     'if `(` binary(identifier(n) === number(2)) `)` blockStmnt(' +\n     '{ expressionStmnt(call(identifier(bar) `(` `)`) ;) }) else blockStmnt(' +\n     '{ expressionStmnt(call(identifier(baz) `(` `)`) ;) }))))'],\n    ['while (false);',\n     'program(whileStmnt(while `(` boolean(false) `)` emptyStmnt(;)))'],\n    ['while (/foo/.test(bar.baz)) {\\n  bar = bar.baz;\\n}',\n     'program(whileStmnt(while `(` call(dot(regex(/foo/) . test) `(` ' +\n     'dot(identifier(bar) . baz) `)`) `)` blockStmnt({ expressionStmnt(' +\n     'assignment(identifier(bar) = dot(identifier(bar) . baz)) ;) })))'],\n    ['while (false) while (false);',\n     'program(whileStmnt(while `(` boolean(false) `)` ' +\n     'whileStmnt(while `(` boolean (false) `)` emptyStmnt(;))))'],\n    ['do a; while (b);',\n     'program(doStmnt(do expressionStmnt(identifier(a) ;) while `(` identifier(b) `)` ;))'],\n    ['do { x-- } while (x);',\n     'program(doStmnt(do blockStmnt({ expressionStmnt(postfix(identifier(x) --) ;()) }) ' +\n     'while `(` identifier(x) `)` ;))'],\n    ['do a\\n while (b)\\n x++',\n     'program(doStmnt(do expressionStmnt(identifier(a) ;()) while `(` identifier(b) `)` ;()) ' +\n     'expressionStmnt(postfix(identifier(x) ++) ;()))'],\n    [\"for(;;);\",\n     \"program(forStmnt(for `(` forSpec(nil() ; nil() ; nil()) `)` emptyStmnt(;)))\"],\n    [\"for(x in y);\",\n     \"program(forStmnt(for `(` forInSpec(identifier(x) in identifier(y)) `)` emptyStmnt(;)))\"],\n    [\"for(var x in y);\",\n     \"program(forStmnt(for `(` forVarInSpec(var varDecl(x) in identifier(y)) `)` emptyStmnt(;)))\"],\n    [\"for(var x;;);\",\n     \"program(forStmnt(for `(` forVarSpec(var varDecl(x) ; nil() ; nil()) `)` emptyStmnt(;)))\"],\n    [\"for(var i=0;i<N;i++) {}\",\n     \"program(forStmnt(for `(` forVarSpec(var varDecl(i = number(0)) ; \" +\n     \"binary(identifier(i) < identifier(N)) ; postfix(identifier(i) ++)) `)` blockStmnt({ })))\"],\n    [\"for (var x=3 in y);\",\n     \"program(forStmnt(for `(` forVarInSpec(var varDecl(x = number(3)) in identifier(y)) `)` \" +\n     \"emptyStmnt(;)))\"],\n    [\"for (x.foo in y);\",\n     \"program(forStmnt(for `(` forInSpec(dot(identifier(x) . foo) in identifier(y)) `)` emptyStmnt(;)))\"],\n    [\"return\",\n     \"program(returnStmnt(return nil() ;()))\"],\n    [\"return;\",\n     \"program(returnStmnt(return nil() ;))\"],\n    [\"return null\",\n     \"program(returnStmnt(return null(null) ;()))\"],\n    [\"return null;\",\n     \"program(returnStmnt(return null(null) ;))\"],\n    [\"return\\n1+1\",\n     \"program(returnStmnt(return nil() ;()) expressionStmnt(binary(number(1) + number(1)) ;()))\"],\n    [\"return 1\\n  +1\",\n     \"program(returnStmnt(return binary(number(1) + number(1)) ;()))\"],\n    [\"continue\",\n     \"program(continueStmnt(continue nil() ;()))\"],\n    [\"continue foo\",\n     \"program(continueStmnt(continue foo ;()))\"],\n    [\"continue foo;\",\n     \"program(continueStmnt(continue foo ;))\"],\n    [\"continue\\n  foo;\",\n     \"program(continueStmnt(continue nil() ;()) expressionStmnt(identifier(foo) ;))\"],\n    [\"break\",\n     \"program(breakStmnt(break nil() ;()))\"],\n    [\"break foo\",\n     \"program(breakStmnt(break foo ;()))\"],\n    [\"break foo;\",\n     \"program(breakStmnt(break foo ;))\"],\n    [\"break\\n  foo;\",\n     \"program(breakStmnt(break nil() ;()) expressionStmnt(identifier(foo) ;))\"],\n    [\"throw e;\",\n     \"program(throwStmnt(throw identifier(e) ;))\"],\n    [\"throw e\",\n     \"program(throwStmnt(throw identifier(e) ;()))\"],\n    [\"throw new Error;\",\n     \"program(throwStmnt(throw new(new identifier(Error)) ;))\"],\n    [\"with(x);\",\n     \"program(withStmnt(with `(` identifier(x) `)` emptyStmnt(;)))\"],\n    [\"with(a=b) {}\",\n     \"program(withStmnt(with `(` assignment(identifier(a) = identifier(b)) `)` blockStmnt({ })))\"],\n    [\"switch(x) {}\",\n     \"program(switchStmnt(switch `(` identifier(x) `)` { }))\"],\n    [\"switch(x) {case 1:case 2:case 3:default:case 4:}\",\n     \"program(switchStmnt(switch `(` identifier(x) `)` { \" +\n     \"case(case number(1) :) case(case number(2) :) case(case number(3) :) \" +\n     \"default(default :) case(case number(4) :) }))\"],\n    [\"switch(x) {\\ncase 1:\\n  return\\ncase 2:\\ncase 3:\\n  throw e}\",\n     \"program(switchStmnt(switch `(` identifier(x) `)` { \" +\n     \"case(case number(1) : returnStmnt(return nil() ;())) \" +\n     \"case(case number(2) :) case(case number(3) : \" +\n     \"throwStmnt(throw identifier(e) ;())) }))\"],\n    [\"switch(x) {default:;}\",\n     \"program(switchStmnt(switch `(` identifier(x) `)` { default(default : emptyStmnt(;)) }))\"],\n    [\"try {} catch (e) {} finally {}\",\n     \"program(tryStmnt(try blockStmnt({ }) catch(catch `(` e `)` blockStmnt({ })) \" +\n     \"finally(finally blockStmnt({ }))))\"],\n    [\"try {} finally {}\",\n     \"program(tryStmnt(try blockStmnt({ }) nil() finally(finally blockStmnt({ }))))\"],\n    [\"try {} catch (e) {}\",\n     \"program(tryStmnt(try blockStmnt({ }) catch(catch `(` e `)` blockStmnt({ })) nil()))\"],\n    [\"a:;\",\n     \"program(labelStmnt(a : emptyStmnt(;)))\"],\n    [\"{x:1}\",\n     \"program(blockStmnt({ labelStmnt(x : expressionStmnt(number(1) ;())) }))\"],\n    [\"{x:y:z:1}\",\n     \"program(blockStmnt({ labelStmnt(x : labelStmnt(y : \" +\n     \"labelStmnt(z : expressionStmnt(number(1) ;())))) }))\"],\n    [\";;foo:\\nfor(;;);\",\n     \"program(emptyStmnt(;) emptyStmnt(;) labelStmnt(foo : \" +\n     \"forStmnt(for `(` forSpec(nil() ; nil() ; nil()) `)` emptyStmnt(;))))\"],\n    [\"debugger\",\n     \"program(debuggerStmnt(debugger ;()))\"],\n    [\"debugger;\",\n     \"program(debuggerStmnt(debugger ;))\"],\n    [\"function foo() {}\",\n     \"program(functionDecl(function foo `(` `)` { }))\"],\n    [\"function foo() {function bar() {}}\",\n     \"program(functionDecl(function foo `(` `)` { functionDecl(function bar `(` `)` { }) }))\"],\n    [\";;function f() {};;\",\n     \"program(emptyStmnt(;) emptyStmnt(;) functionDecl(function f `(` `)` { }) \" +\n     \"emptyStmnt(;) emptyStmnt(;))\"],\n    [\"function foo(a,b,c) {}\",\n     \"program(functionDecl(function foo `(` a , b , c `)` { }))\"],\n\n    // EXPRESSIONS\n    [\"null + this - 3 + true\",\n     \"program(expressionStmnt(binary(binary(binary(null(null) + this(this)) - \" +\n     \"number(3)) + boolean(true)) ;()))\"],\n    [\"+.5\",\n     \"program(expressionStmnt(unary(+ number(.5)) ;()))\"],\n    [\"a1a1a\",\n     \"program(expressionStmnt(identifier(a1a1a) ;()))\"],\n    [\"/abc/mig\",\n     \"program(expressionStmnt(regex(/abc/mig) ;()))\"],\n    [\"/[]/\",\n     \"program(expressionStmnt(regex(/[]/) ;()))\"],\n    [\"/[/]/\",\n     \"program(expressionStmnt(regex(/[/]/) ;()))\"],\n    [\"/[[/]/\",\n     \"program(expressionStmnt(regex(/[[/]/) ;()))\"],\n    [\"/.\\\\/[a//b]\\\\[\\\\][[\\\\d/]/\",\n     \"program(expressionStmnt(regex(/.\\\\/[a//b]\\\\[\\\\][[\\\\d/]/) ;()))\"],\n    [\"a / /b/mgi / c\",\n     \"program(expressionStmnt(binary(binary(identifier(a) / \" +\n     \"regex(/b/mgi)) / identifier(c)) ;()))\"],\n    [\"'a' + \\\"\\\" + \\\"b\\\" + '\\\\''\",\n     \"program(expressionStmnt(binary(binary(binary(string('a') + string(\\\"\\\")) + \" +\n     \"string(\\\"b\\\")) + string('\\\\'')) ;()))\"],\n    [\"_ + x0123 + $\",\n     \"program(expressionStmnt(binary(binary(identifier(_) + \" +\n     \"identifier(x0123)) + identifier($)) ;()))\"],\n    [\"if ((x = 1)) return ((1+2))*((1<<2));\",\n     \"program(ifStmnt(if `(` parens(`(` assignment(identifier(x) = number(1)) `)`) \" +\n     \"`)` returnStmnt(return binary(parens(`(` parens(`(` binary(number(1) + \" +\n     \"number(2)) `)`) `)`) * parens(`(` parens(`(` binary(number(1) << number(2)) \" +\n     \"`)`) `)`)) ;)))\"],\n    [\"[];\",\n     \"program(expressionStmnt(array([ ]) ;))\"],\n    [\"[,,,];\",\n     \"program(expressionStmnt(array([ , , , ]) ;))\"],\n    [\"[(1,2),,3];\",\n     \"program(expressionStmnt(array([ parens(`(` comma(number(1) , \" +\n     \"number(2)) `)`) , , number(3) ]) ;))\"],\n    [\"({});\",\n     \"program(expressionStmnt(parens(`(` object({ }) `)`) ;))\"],\n    [\"({1:1});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(numPropName(1) : number(1)) }) `)`) ;))\"],\n    [\"({x:true});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(x) : boolean(true)) }) `)`) ;))\"],\n    [\"({'a':b, c:'d', 1:null});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(strPropName('a') : \" +\n     \"identifier(b)) , prop(idPropName(c) : string('d')) , prop(numPropName(1) \" +\n     \": null(null)) }) `)`) ;))\"],\n    [\"(function () {});\",\n     \"program(expressionStmnt(parens(`(` functionExpr(function nil() `(` `)` { }) `)`) ;))\"],\n    [\"(function foo() {});\",\n     \"program(expressionStmnt(parens(`(` functionExpr(function foo `(` `)` { }) `)`) ;))\"],\n    [\"x = function () {}.y;\",\n     \"program(expressionStmnt(assignment(identifier(x) = dot(functionExpr(\" +\n     \"function nil() `(` `)` { }) . y)) ;))\"],\n    [\"(function (a) {})\",\n     \"program(expressionStmnt(parens(`(` functionExpr(function nil() \" +\n     \"`(` a `)` { }) `)`) ;()))\"],\n    [\"(function (a,b,c) {})\",\n     \"program(expressionStmnt(parens(`(` functionExpr(function nil() `(` \" +\n     \"a , b , c `)` { }) `)`) ;()))\"],\n    [\"foo.bar.baz;\",\n     \"program(expressionStmnt(dot(dot(identifier(foo) . bar) . baz) ;))\"],\n    [\"foo[bar,bar][baz].qux[1+1];\",\n     \"program(expressionStmnt(bracket(dot(bracket(bracket(identifier(foo) \" +\n     \"[ comma(identifier(bar) , identifier(bar)) ]) [ identifier(baz) ]) . qux) \" +\n     \"[ binary(number(1) + number(1)) ]) ;))\"],\n    [\"new new a.b.c[d]\",\n     \"program(expressionStmnt(new(new new(new bracket(dot(dot(identifier(a) \" +\n     \". b) . c) [ identifier(d) ]))) ;()))\"],\n    [\"new new a.b.c[d]()\",\n     \"program(expressionStmnt(new(new newcall(new \" +\n     \"bracket(dot(dot(identifier(a) . b) . c) [ identifier(d) ]) `(` `)`)) ;()))\"],\n    [\"new new a.b.c[d]()()\",\n     \"program(expressionStmnt(newcall(new newcall(new \" +\n     \"bracket(dot(dot(identifier(a) . b) . c) [ identifier(d) ]) `(` `)`) `(` `)`) ;()))\"],\n    [\"new foo(x).bar(y)\",\n     \"program(expressionStmnt(call(dot(newcall(new identifier(foo) `(` \" +\n     \"identifier(x) `)`) . bar) `(` identifier(y) `)`) ;()))\"],\n    [\"new new foo().bar\",\n     \"program(expressionStmnt(new(new dot(newcall(new identifier(foo) `(` `)`) . bar)) ;()))\"],\n    [\"delete void typeof - + ~ ! -- ++ x;\",\n     \"program(expressionStmnt(unary(delete unary(void unary(typeof unary(- unary(+ \" +\n     \"unary(~ unary(! unary(-- unary(++ identifier(x)))))))))) ;))\"],\n    [\"x++ + ++y\",\n     \"program(expressionStmnt(binary(postfix(identifier(x) ++) + \" +\n     \"unary(++ identifier(y))) ;()))\"],\n    [\"1*2+3*4\",\n     \"program(expressionStmnt(binary(binary(number(1) * number(2)) \" +\n     \"+ binary(number(3) * number(4))) ;()))\"],\n    [\"a*b/c%d+e-f<<g>>h>>>i<j>k<=l>=m instanceof n in o==p!=q===r!==s&t^u|v&&w||x\",\n     \"program(expressionStmnt(binary(binary(binary(binary(binary(binary(binary(\" +\n     \"binary(binary(binary(binary(binary(binary(binary(binary(binary(binary(binary(\" +\n     \"binary(binary(binary(binary(binary(identifier(a) * identifier(b)) / \" +\n     \"identifier(c)) % identifier(d)) + identifier(e)) - identifier(f)) << identifier(g)) \" +\n     \">> identifier(h)) >>> identifier(i)) < identifier(j)) > identifier(k)) <= \" +\n     \"identifier(l)) >= identifier(m)) instanceof identifier(n)) in identifier(o)) == \" +\n     \"identifier(p)) != identifier(q)) === identifier(r)) !== identifier(s)) & \" +\n     \"identifier(t)) ^ identifier(u)) | identifier(v)) && identifier(w)) || \" +\n     \"identifier(x)) ;()))\"],\n    [\"a||b&&c|d^e&f!==g===h!=i==j in k instanceof l>=m<=n<o<p>>>q>>r<<s-t+u%v/w*x\",\n     \"program(expressionStmnt(binary(identifier(a) || binary(identifier(b) && \" +\n     \"binary(identifier(c) | binary(identifier(d) ^ binary(identifier(e) & \" +\n     \"binary(binary(binary(binary(identifier(f) !== identifier(g)) === identifier(h)) \" +\n     \"!= identifier(i)) == binary(binary(binary(binary(binary(binary(identifier(j) in \" +\n     \"identifier(k)) instanceof identifier(l)) >= identifier(m)) <= identifier(n)) < \" +\n     \"identifier(o)) < binary(binary(binary(identifier(p) >>> identifier(q)) >> \" +\n     \"identifier(r)) << binary(binary(identifier(s) - identifier(t)) + \" +\n     \"binary(binary(binary(identifier(u) % identifier(v)) / identifier(w)) * \" +\n     \"identifier(x))))))))))) ;()))\"],\n    [\"a?b:c\",\n     \"program(expressionStmnt(ternary(identifier(a) ? identifier(b) : \" +\n     \"identifier(c)) ;()))\"],\n    [\"1==2?3=4:5=6\",\n     \"program(expressionStmnt(ternary(binary(number(1) == number(2)) ? \" +\n     \"assignment(number(3) = number(4)) : assignment(number(5) = number(6))) ;()))\"],\n    [\"a=b,c=d\",\n     \"program(expressionStmnt(comma(assignment(identifier(a) = identifier(b)) , \" +\n     \"assignment(identifier(c) = identifier(d))) ;()))\"],\n    [\"a=b=c=d\",\n     \"program(expressionStmnt(assignment(identifier(a) = assignment(identifier(b) \" +\n     \"= assignment(identifier(c) = identifier(d)))) ;()))\"],\n    [\"x[0]=x[1]=true\",\n     \"program(expressionStmnt(assignment(bracket(identifier(x) [ number(0) ]) = \" +\n     \"assignment(bracket(identifier(x) [ number(1) ]) = boolean(true))) ;()))\"],\n    [\"a*=b/=c%=d+=e-=f<<=g>>=h>>>=i&=j^=k|=l\",\n     \"program(expressionStmnt(assignment(identifier(a) *= assignment(identifier(b) \" +\n     \"/= assignment(identifier(c) %= assignment(identifier(d) += \" +\n     \"assignment(identifier(e) -= assignment(identifier(f) <<= \" +\n     \"assignment(identifier(g) >>= assignment(identifier(h) >>>= \" +\n     \"assignment(identifier(i) &= assignment(identifier(j) ^= \" +\n     \"assignment(identifier(k) |= identifier(l)))))))))))) ;()))\"],\n    [\"1;\\n\\n\\n\\n/* foo */\\n// bar\\n\", // trailing whitespace and comments\n     \"program(expressionStmnt(number(1) ;) comment(`/* foo */`) comment(`// bar`))\"],\n    // includeComments option; comments in AST\n    [\"//foo\",\n     \"program(comment(//foo))\"],\n    [\"//foo\\n\",\n     \"program(comment(//foo))\"],\n    [\"/*foo*/\",\n     \"program(comment(/*foo*/))\"],\n    [\"/*foo*/\\n\",\n     \"program(comment(/*foo*/))\"],\n    [\";\\n//foo\",\n     \"program(emptyStmnt(;) comment(//foo))\"],\n    [\";\\n/*foo*/\",\n     \"program(emptyStmnt(;) comment(/*foo*/))\"],\n    [\";\\n//foo\\n;\",\n     \"program(emptyStmnt(;) comment(//foo) emptyStmnt(;))\"],\n    [\";\\n/*foo*/\\n;\",\n     \"program(emptyStmnt(;) comment(/*foo*/) emptyStmnt(;))\"],\n    [\";\\n//foo\\n//bar\\n;\",\n     \"program(emptyStmnt(;) comment(//foo) comment(//bar) emptyStmnt(;))\"],\n    [\";\\n/*foo*/ /*bar*/\\n;\",\n     \"program(emptyStmnt(;) comment(/*foo*/) comment(/*bar*/) emptyStmnt(;))\"],\n    [\";//foo\\n//bar\\n;\",\n     \"program(emptyStmnt(;) comment(//bar) emptyStmnt(;))\"],\n    [\";/*foo*/\\n/*bar*/\\n;\",\n     \"program(emptyStmnt(;) comment(/*bar*/) emptyStmnt(;))\"],\n    [\";/*foo*//*bar*///baz\\n;\",\n     \"program(emptyStmnt(;) emptyStmnt(;))\"],\n    [\";/*foo*//*bar*///baz\",\n     \"program(emptyStmnt(;))\"],\n    [\"/*foo*//*bar*///baz\",\n     \"program(comment(/*foo*/) comment(/*bar*/) comment(//baz))\"],\n    [\"//foo\\n//bar\\nfunction aaa() {}\\nfunction bbb() {}\",\n     \"program(comment(//foo) comment(//bar) functionDecl(function aaa `(` `)` { }) \" +\n     \"functionDecl(function bbb `(` `)` { }))\"],\n    // comments don't interfere with parse\n    [\"if (true)\\n//comment\\nfoo();\",\n     \"program(ifStmnt(if `(` boolean(true) `)` \" +\n     \"expressionStmnt(call(identifier(foo) `(` `)`) ;)))\"],\n    // bare keywords allowed in property access and object literal\n    [\"foo.return();\",\n     \"program(expressionStmnt(call(dot(identifier(foo) . return) `(` `)`) ;))\"],\n    [\"foo.true();\",\n     \"program(expressionStmnt(call(dot(identifier(foo) . true) `(` `)`) ;))\"],\n    [\"foo.null();\",\n     \"program(expressionStmnt(call(dot(identifier(foo) . null) `(` `)`) ;))\"],\n    [\"({true:3})\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(true) : number(3)) }) `)`) ;()))\"],\n    [\"({null:3})\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(null) : number(3)) }) `)`) ;()))\"],\n    [\"({if:3})\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(if) : number(3)) }) `)`) ;()))\"],\n    // ES5 line continuations in string literals\n    [\"var x = 'a\\\\\\nb\\\\\\nc';\",\n     \"program(varStmnt(var varDecl(x = string(`'a\\\\\\nb\\\\\\nc'`)) ;))\"],\n    // ES5 trailing comma in object literal\n    [\"({});\",\n     \"program(expressionStmnt(parens(`(` object({ }) `)`) ;))\"],\n    [\"({x:1});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(x) : number(1)) }) `)`) ;))\"],\n    [\"({x:1,});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(x) : number(1)) , }) `)`) ;))\"],\n    [\"({x:1,y:2});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(x) : number(1)) , \" +\n     \"prop(idPropName(y) : number(2)) }) `)`) ;))\"],\n    [\"({x:1,y:2,});\",\n     \"program(expressionStmnt(parens(`(` object({ prop(idPropName(x) : number(1)) , \" +\n     \"prop(idPropName(y) : number(2)) , }) `)`) ;))\"]\n  ];\n  _.each(trials, function (tr) {\n    tester.goodParse(tr[0], tr[1]);\n  });\n});\n\nTinytest.add(\"jsparse - bad parses\", function (test) {\n  var tester = makeTester(test);\n  // string between backticks is pulled out and becomes what's \"expected\"\n  // at that location, according to the correct error message\n  var trials = [\n    '{`statement`',\n    'if (`expression`)',\n    'if `(`else',\n    'var`varDecl`;',\n    'while (`expression`);',\n    'while`(`;',\n    'do a `semicolon`while b;',\n    'do a\\n while `(`b;',\n    '1 `semicolon`2',\n    'for (`forSpec`);',\n    'for (1\\n`semicolon`2\\n3);',\n    'continue `semicolon`1+1;',\n    'break `semicolon`1+1;',\n    'throw`expression`',\n    'throw`expression`;',\n    'throw\\n`expression`',\n    'throw\\n`expression``end of line`e',\n    'throw `expression`=;',\n    'with(`expression`);',\n    'switch(`expression`)',\n    'switch(x)`{`;',\n    'try`block`',\n    'try {}`catch`',\n    'try {} catch`(`;',\n    'try {} catch(e)`block`;',\n    '1+1`semicolon`:',\n    '{a:`statement`}',\n    'function `IDENTIFIER`() {}',\n    'foo: `statement`function foo() {}',\n    '[`expression`=',\n    '[,,`expression`=',\n    '({`propertyName`|:3})',\n    '({1:2,3`:`})',\n    '({1:2,`propertyName`',\n    'x.`IDENTIFIER`,',\n    'foo;`semicolon`:;',\n    '1;`statement`=',\n    'a+b`semicolon`=c;',\n    'for(1+1 `semicolon`in {});',\n    '`statement`=',\n    'for(;`expression`var;) {}',\n    '({`propertyName`',\n    '({`propertyName`,})',\n    '({`propertyName`:})',\n    '({x`:`})',\n    '({x:1,`propertyName`',\n    '({x:1,`propertyName`,})',\n    '({x:1`,`',\n    '({x:1,`propertyName`,y:2})',\n    '({x:1,`propertyName`,})',\n    '({x:1,y:2`,`:',\n    '({x:1,y:2,`propertyName`',\n    '({x:1,y:2,`propertyName`:',\n    '({x:1,y:2,`propertyName`,})'\n  ];\n  _.each(trials, function (tr) {\n    tester.badParse(tr);\n  });\n});\n\nTinytest.add(\"jsparse - regex division ambiguity\", function (test) {\n  var tester = makeTester(test);\n  tester.goodParse(\"if (e) /f/g;\",\n                   \"program(ifStmnt(if `(` identifier(e) `)` expressionStmnt(regex(/f/g) ;)))\",\n                   {4: true});\n  tester.goodParse(\"++/x/.y;\",\n                   \"program(expressionStmnt(unary(++ dot(regex(/x/) . y)) ;))\",\n                   {1: true});\n  tester.goodParse(\"x++/2/g;\",\n                   \"program(expressionStmnt(binary(binary(postfix(identifier(x) ++) / \" +\n                   \"number(2)) / identifier(g)) ;))\");\n  tester.goodParse(\"(1+1)/2/g;\",\n                   \"program(expressionStmnt(binary(binary(parens(`(` binary(number(1) + \" +\n                   \"number(1)) `)`) / \" +\n                   \"number(2)) / identifier(g)) ;))\");\n  tester.goodParse(\"/x/\",\n                   \"program(expressionStmnt(regex(/x/) ;()))\");\n});\n\nTinytest.add(\"jsparse - semicolon insertion\", function (test) {\n  var tester = makeTester(test);\n  // Spec section 7.9.2\n  tester.badParse(\"{ 1 `semicolon`2 } 3\");\n  tester.goodParse(\"{ 1\\n2 } 3\", \"program(blockStmnt({ expressionStmnt(number(1) \" +\n                   \";()) expressionStmnt(number(2) ;()) }) expressionStmnt(number(3) ;()))\");\n  tester.badParse(\"for (a; b\\n`semicolon`)\");\n  tester.goodParse(\"return\\na + b\",\n                   \"program(returnStmnt(return nil() ;()) \" +\n                   \"expressionStmnt(binary(identifier(a) + identifier(b)) ;()))\");\n  tester.goodParse(\"a = b\\n++c\",\n                   \"program(expressionStmnt(assignment(identifier(a) = identifier(b)) ;())\" +\n                   \"expressionStmnt(unary(++ identifier(c)) ;()))\");\n  tester.badParse(\"if (a > b)\\n`statement`else c = d\");\n  tester.goodParse(\"a = b + c\\n(d + e).print()\",\n                   \"program(expressionStmnt(assignment(identifier(a) = \" +\n                   \"binary(identifier(b) + call(dot(call(identifier(c) `(` \" +\n                   \"binary(identifier(d) + identifier(e)) `)`) . print) `(` `)`))) ;()))\");\n});\n\nTinytest.add(\"jsparse - comments\", function (test) {\n  var tester = makeTester(test);\n  // newline in multi-line comment makes it into a line break for semicolon\n  // insertion purposes\n  tester.badParse(\"1/**/`semicolon`2\");\n  tester.goodParse(\"1/*\\n*/2\",\n                   \"program(expressionStmnt(number(1) ;()) expressionStmnt(number(2) ;()))\");\n});\n\nTinytest.add(\"jsparse - initial lex error\", function (test) {\n  var doTest = function (code) {\n    // this shouldn't throw\n    var parser = new JSParser(code, parserTestOptions);\n    // this should throw\n    try {\n      parser.getSyntaxTree();\n      test.fail();\n    } catch (e) {\n      test.isTrue(/^Bad token/.test(e.message), e.message);\n    }\n  };\n\n  doTest('/');\n  doTest('@');\n});\n"]}