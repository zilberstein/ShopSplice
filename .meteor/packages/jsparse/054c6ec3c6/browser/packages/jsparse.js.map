{"version":3,"file":"/packages/jsparse.js","sources":["jsparse/lexer.js","jsparse/parserlib.js","jsparse/stringify.js","jsparse/parser.js"],"names":[],"mappings":";;;;;;;;AAAA,kC;AACA,oD;AACA,E;;AAEA,kE;AACA,yB;AACA,6kF;AACA,wS;AACA,iuE;AACA,gE;AACA,kgF;AACA,gxB;AACA,2zC;AACA,oU;AACA,mE;AACA,6C;AACA,E;;AAEA,sC;AACA,c;AACA,sE;AACA,E;;AAEA,4C;;AAEA,c;AACA,0E;AACA,0E;AACA,yC;AACA,wE;AACA,8E;AACA,wD;AACA,oD;AACA,c;AACA,qE;AACA,oD;AACA,c;AACA,gC;AACA,6D;AACA,8C;AACA,4C;AACA,oE;AACA,mC;AACA,c;AACA,6D;AACA,4B;AACA,mC;AACA,uC;AACA,gE;AACA,4E;AACA,e;AACA,gE;AACA,qD;AACA,4D;AACA,8E;AACA,mC;AACA,0E;AACA,0D;AACA,c;AACA,0D;AACA,6B;AACA,+E;AACA,4E;AACA,4E;AACA,uB;AACA,oE;AACA,qB;AACA,6B;AACA,gB;AACA,6C;AACA,iD;AACA,iB;AACA,yE;AACA,gB;AACA,2B;AACA,yE;AACA,wD;AACA,sD;AACA,qB;AACA,mF;AACA,kC;AACA,uB;AACA,6C;AACA,gB;AACA,mE;AACA,0D;AACA,oD;AACA,E;AACA,wB;AACA,yC;AACA,uC;AACA,4C;AACA,6C;AACA,iE;AACA,qD;AACA,8C;AACA,wC;AACA,sB;AACA,mB;AACA,oE;AACA,+B;;AAEA,c;AACA,mG;;AAEA,qB;AACA,sB;AACA,qB;AACA,sB;AACA,yB;AACA,yB;AACA,wB;AACA,uB;AACA,mB;AACA,qB;AACA,wB;AACA,oB;AACA,yB;AACA,mB;AACA,mB;AACA,2B;AACA,oB;AACA,uB;AACA,uB;AACA,qB;AACA,sB;AACA,oB;AACA,uB;AACA,oB;AACA,qB;AACA,sB;AACA,qB;;AAEA,sB;AACA,qB;;AAEA,iB;AACA,E;;AAEA,gC;AACA,a;AACA,+C;AACA,uB;AACA,W;AACA,E;;AAEA,+E;;AAEA,kE;AACA,wD;;AAEA,yD;AACA,oE;AACA,sE;AACA,uD;AACA,mD;AACA,kE;AACA,+D;AACA,uE;AACA,I;AACA,0D;AACA,2E;AACA,gB;AACA,0D;AACA,4E;AACA,uE;AACA,sE;AACA,oB;AACA,uE;AACA,iE;AACA,uB;AACA,qB;AACA,0D;AACA,oD;AACA,iB;AACA,0D;AACA,iD;AACA,oB;AACA,gB;AACA,qB;AACA,gB;AACA,G;AACA,E;;AAEA,qB;;AAEA,yC;AACA,kB;AACA,oB;AACA,oB;AACA,E;;AAEA,yC;AACA,mB;AACA,E;;AAEA,uC;AACA,uC;AACA,E;;AAEA,qC;AACA,oB;AACA,E;;AAEA,qC;AACA,oB;AACA,E;;AAEA,wC;AACA,qC;AACA,E;;AAEA,wC;AACA,gC;AACA,E;;AAEA,sC;AACA,8B;AACA,E;;AAEA,qC;AACA,oB;AACA,E;;AAEA,qC;AACA,oB;AACA,E;;AAEA,yC;AACA,mC;AACA,mD;AACA,E;;AAEA,0D;AACA,E;AACA,wD;AACA,2D;AACA,E;AACA,oB;AACA,c;AACA,2C;AACA,+D;AACA,iE;AACA,+D;AACA,2B;AACA,4D;AACA,0C;AACA,+C;AACA,4D;AACA,qE;AACA,uE;AACA,sE;AACA,oE;AACA,gD;AACA,iE;AACA,uC;;AAEA,2B;AACA,mB;AACA,e;AACA,iC;AACA,yB;AACA,E;;AAEA,wB;;AAEA,mB;AACA,uE;AACA,uE;AACA,qE;AACA,2D;AACA,wE;AACA,oE;AACA,kE;AACA,E;AACA,gB;AACA,iD;AACA,qD;AACA,iD;AACA,gB;;AAEA,sC;AACA,kB;AACA,uB;AACA,yB;AACA,iD;;AAEA,4B;AACA,oC;;AAEA,8D;AACA,mB;AACA,4D;AACA,iB;AACA,oB;;AAEA,4D;AACA,gC;AACA,wD;AACA,4D;AACA,wD;AACA,yB;AACA,4D;AACA,4C;AACA,qB;AACA,wB;AACA,K;AACA,mB;AACA,8E;AACA,0B;AACA,kC;AACA,kC;AACA,K;AACA,0B;AACA,sB;AACA,uE;AACA,e;AACA,I;;AAEA,0B;AACA,yB;;AAEA,gE;AACA,mB;;AAEA,sE;AACA,wE;AACA,sE;AACA,uE;AACA,qD;AACA,8B;AACA,8C;AACA,0B;AACA,6B;AACA,iE;AACA,gE;AACA,uC;AACA,uC;AACA,mB;AACA,4D;AACA,2D;AACA,8B;AACA,uC;AACA,4B;AACA,iB;AACA,I;;AAEA,mE;AACA,sC;AACA,gB;AACA,gB;;AAEA,kB;AACA,uB;AACA,qB;AACA,gC;AACA,G;AACA,qC;AACA,4B;AACA,8B;AACA,+B;AACA,K;AACA,4B;AACA,6B;AACA,iD;AACA,K;AACA,2B;AACA,8B;AACA,4B;AACA,qC;AACA,c;AACA,2B;AACA,oB;AACA,iC;AACA,yB;AACA,+B;AACA,O;AACA,K;AACA,G;AACA,+C;AACA,qB;AACA,mD;AACA,G;AACA,wB;AACA,6D;AACA,8C;AACA,G;AACA,2B;AACA,sB;AACA,yB;AACA,Q;AACA,mD;AACA,oD;AACA,0C;AACA,wC;AACA,6B;AACA,4B;AACA,G;AACA,8C;AACA,yB;AACA,6B;AACA,G;AACA,kC;AACA,yB;AACA,4D;AACA,8D;AACA,a;AACA,sC;AACA,sD;AACA,0C;AACA,yD;AACA,E;;AAEA,6C;AACA,2C;AACA,sD;AACA,iD;AACA,yE;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACnaA,sC;;AAEA,+D;;AAEA,8B;AACA,8E;AACA,E;;AAEA,uC;AACA,mB;AACA,2B;;AAEA,0B;AACA,0E;AACA,E;;;AAGA,wC;AACA,6B;AACA,sB;AACA,E;;AAEA,uC;AACA,sB;AACA,E;;AAEA,+C;AACA,uC;AACA,E;;AAEA,2D;AACA,4B;;AAEA,2B;AACA,0C;;AAEA,gB;AACA,E;;AAEA,iD;AACA,4C;AACA,E;;;AAGA,2C;AACA,sD;;AAEA,a;;AAEA,qC;AACA,oB;AACA,wB;AACA,iC;AACA,O;AACA,E;;AAEA,gD;AACA,wC;AACA,2C;AACA,mB;AACA,kB;AACA,4B;AACA,4B;AACA,yC;AACA,K;AACA,E;;AAEA,qC;AACA,uB;AACA,oB;AACA,oC;AACA,kB;AACA,iB;AACA,mD;AACA,kC;AACA,mB;AACA,wB;AACA,O;AACA,kB;AACA,O;AACA,E;;AAEA,mE;AACA,oE;AACA,gC;AACA,a;AACA,qC;AACA,6D;AACA,E;AACA,uD;AACA,sC;AACA,6D;AACA,e;;AAEA,+B;AACA,4C;AACA,4B;AACA,U;AACA,4D;AACA,8D;AACA,W;AACA,8E;AACA,+C;AACA,G;;AAEA,oB;AACA,yB;AACA,kB;AACA,uC;AACA,mB;AACA,oB;;AAEA,a;AACA,wC;AACA,+B;AACA,e;AACA,qD;AACA,O;AACA,oB;AACA,O;AACA,E;;AAEA,uD;AACA,sD;AACA,oB;AACA,yB;AACA,kB;AACA,uC;AACA,iD;AACA,uC;AACA,iE;AACA,mB;AACA,oB;;AAEA,4B;AACA,8D;AACA,oB;AACA,O;AACA,E;;AAEA,mE;AACA,gE;AACA,e;AACA,2B;AACA,uC;AACA,W;AACA,iD;AACA,wC;AACA,0B;AACA,wC;AACA,Q;AACA,2B;AACA,I;AACA,oB;AACA,yB;AACA,kB;AACA,sB;AACA,0C;AACA,sB;AACA,oB;AACA,8B;;AAEA,sB;AACA,gB;AACA,4C;AACA,4B;AACA,oD;AACA,S;AACA,c;AACA,iB;AACA,4C;AACA,6B;AACA,O;AACA,oB;AACA,O;AACA,E;;AAEA,gC;AACA,sC;AACA,uB;AACA,oB;AACA,gC;;AAEA,oB;AACA,sB;AACA,kB;AACA,sB;AACA,oD;AACA,kD;AACA,6D;AACA,kD;AACA,gB;AACA,sB;;AAEA,wC;AACA,uC;AACA,Y;AACA,yB;AACA,O;AACA,oB;AACA,O;AACA,E;;AAEA,yC;AACA,sC;AACA,uB;AACA,oB;AACA,gC;;AAEA,oB;AACA,oC;AACA,kB;AACA,iB;AACA,mD;AACA,kC;AACA,qB;AACA,sB;AACA,O;AACA,oB;AACA,O;AACA,E;;AAEA,0B;AACA,iC;AACA,oB;AACA,S;AACA,kB;AACA,yC;AACA,O;AACA,E;;AAEA,kD;AACA,sC;AACA,yB;AACA,qD;AACA,E;;AAEA,iC;AACA,0B;AACA,qB;AACA,uC;AACA,E;;AAEA,6C;AACA,oB;AACA,qB;AACA,kB;AACA,8B;AACA,mC;AACA,O;AACA,E;;AAEA,iD;AACA,mB;AACA,6C;AACA,gB;AACA,2B;AACA,0B;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACnQA,6E;AACA,E;AACA,kD;AACA,0D;AACA,E;AACA,6E;AACA,6D;AACA,E;AACA,+E;AACA,mF;AACA,oD;AACA,E;AACA,+E;AACA,yD;;;AAGA,6C;AACA,mC;AACA,E;;AAEA,qC;AACA,0B;AACA,+C;AACA,iB;AACA,gB;AACA,M;AACA,e;AACA,E;;AAEA,uC;AACA,8B;AACA,kD;AACA,gD;AACA,yB;AACA,e;AACA,Q;AACA,iD;AACA,G;AACA,a;AACA,E;;AAEA,uC;AACA,kC;AACA,wC;AACA,e;AACA,6B;AACA,wD;AACA,kE;AACA,qC;AACA,e;AACA,e;AACA,G;;AAEA,+C;AACA,sC;AACA,uB;AACA,yC;AACA,qB;AACA,sC;AACA,E;;AAEA,wC;AACA,oE;AACA,yB;AACA,e;AACA,S;AACA,yC;AACA,yE;AACA,4D;AACA,M;AACA,kD;AACA,sC;AACA,I;AACA,8B;AACA,yC;AACA,2B;AACA,oB;AACA,kB;AACA,iB;AACA,O;AACA,I;AACA,0B;AACA,gD;AACA,uB;AACA,+D;AACA,kB;;AAEA,gB;AACA,sD;AACA,iD;AACA,K;;AAEA,6C;AACA,iE;;AAEA,kC;AACA,2B;AACA,sB;AACA,wC;AACA,6E;AACA,kB;AACA,8C;AACA,kC;AACA,oB;;AAEA,yB;AACA,gB;AACA,oB;AACA,6B;AACA,iD;AACA,O;;AAEA,8D;AACA,iC;AACA,K;;AAEA,gE;AACA,E;;;;;;;;;;;;;;;;;;;ACrHA,uB;;AAEA,2C;AACA,mC;AACA,4B;;AAEA,iC;;AAEA,kC;AACA,wB;AACA,oB;AACA,sB;AACA,sB;AACA,wB;AACA,sB;AACA,sB;AACA,gC;AACA,kC;;;AAGA,gC;AACA,a;AACA,+C;AACA,uB;AACA,W;AACA,E;;;AAGA,qC;AACA,iC;AACA,uB;AACA,uB;AACA,e;AACA,oC;AACA,+B;AACA,0D;AACA,iC;AACA,kC;;AAEA,0B;AACA,+C;AACA,oC;AACA,qC;AACA,qC;AACA,wB;AACA,M;AACA,U;AACA,qC;AACA,iB;AACA,M;AACA,G;;AAEA,sE;AACA,8D;AACA,qE;AACA,qC;AACA,gC;AACA,gC;AACA,G;AACA,E;;AAEA,kD;AACA,kB;AACA,yB;AACA,gC;AACA,oC;AACA,U;AACA,M;AACA,uB;AACA,sB;AACA,uC;AACA,wE;AACA,qD;AACA,sC;AACA,uC;AACA,mE;AACA,6D;AACA,6B;AACA,uC;AACA,6C;AACA,sB;AACA,4B;AACA,kC;AACA,E;;AAEA,gE;AACA,uE;AACA,oB;AACA,qC;AACA,qB;AACA,6D;AACA,+C;AACA,wB;AACA,E;;AAEA,gD;AACA,kB;;AAEA,yB;;AAEA,qC;;AAEA,6D;AACA,Y;AACA,0C;AACA,uC;AACA,M;AACA,I;;AAEA,yE;AACA,0C;AACA,+D;AACA,6C;AACA,qB;AACA,mC;AACA,8B;AACA,0E;AACA,U;AACA,I;;AAEA,4C;AACA,mD;AACA,wC;AACA,Q;AACA,I;;AAEA,yE;AACA,iC;AACA,+D;AACA,6C;AACA,sB;AACA,mC;AACA,oB;AACA,uE;AACA,8B;AACA,4C;AACA,S;AACA,oB;AACA,S;AACA,I;;AAEA,mC;AACA,0C;AACA,uC;AACA,4B;AACA,0C;AACA,O;AACA,kB;AACA,O;AACA,I;;AAEA,uC;AACA,gD;AACA,sC;AACA,Q;;AAEA,sC;AACA,gE;AACA,6C;AACA,kD;AACA,I;;AAEA,+D;AACA,0D;AACA,oB;AACA,yD;AACA,4B;AACA,sB;AACA,sB;AACA,oB;AACA,6C;AACA,0C;AACA,iD;AACA,mB;AACA,a;AACA,uD;AACA,kC;AACA,wB;AACA,mB;AACA,uB;AACA,iD;AACA,S;AACA,S;AACA,I;;AAEA,8E;AACA,qC;AACA,yE;AACA,qB;AACA,6B;AACA,0B;AACA,mB;AACA,0D;AACA,yB;AACA,mB;AACA,wD;AACA,I;AACA,8C;;AAEA,uC;AACA,0B;AACA,mB;AACA,oE;AACA,yB;AACA,mB;AACA,kE;AACA,I;AACA,kE;;AAEA,kC;AACA,uD;AACA,+B;AACA,oD;AACA,M;;AAEA,oB;AACA,qB;AACA,4B;AACA,uC;AACA,oB;AACA,uC;AACA,wB;AACA,+B;AACA,oC;AACA,+C;AACA,mE;AACA,6D;AACA,6C;AACA,gD;AACA,4D;AACA,0C;AACA,wC;AACA,8B;;AAEA,6E;AACA,mC;AACA,6D;AACA,kE;AACA,yE;;AAEA,kD;AACA,uC;AACA,6C;AACA,+C;AACA,iC;AACA,mB;AACA,uE;;AAEA,qE;AACA,2D;AACA,I;AACA,mE;AACA,8D;AACA,sE;AACA,oE;AACA,sD;AACA,gE;AACA,kE;AACA,qB;AACA,sB;AACA,4B;AACA,wC;AACA,iD;AACA,+C;AACA,6D;AACA,yE;AACA,mD;AACA,2D;AACA,iE;AACA,yD;;AAEA,uD;AACA,6B;AACA,mC;AACA,0D;AACA,6C;AACA,+D;AACA,4B;AACA,wC;AACA,+D;AACA,4B;AACA,4B;AACA,8B;AACA,6B;AACA,O;AACA,+C;AACA,kE;;AAEA,mC;AACA,+B;AACA,iD;AACA,iE;AACA,yD;AACA,2D;AACA,qD;AACA,uD;AACA,yD;AACA,mC;AACA,mE;AACA,kC;AACA,mC;AACA,0C;;;AAGA,kD;AACA,8D;AACA,gC;AACA,4C;AACA,kD;AACA,0C;AACA,iC;;AAEA,gC;;AAEA,sE;AACA,kC;AACA,I;AACA,kE;AACA,mE;AACA,6D;AACA,kE;AACA,8D;AACA,kE;AACA,gE;AACA,iC;AACA,iB;AACA,kB;AACA,+D;AACA,0D;AACA,oB;AACA,Y;AACA,uC;AACA,qB;;AAEA,qE;AACA,qE;AACA,gE;AACA,0B;AACA,6D;AACA,sC;AACA,+E;AACA,mB;AACA,oB;;AAEA,kE;AACA,sE;AACA,qE;AACA,kC;AACA,uB;AACA,sB;AACA,c;AACA,uC;AACA,4D;AACA,kD;AACA,gE;AACA,6C;AACA,0B;AACA,8E;AACA,c;AACA,+D;AACA,gB;AACA,sB;AACA,S;AACA,O;;AAEA,kE;AACA,iE;AACA,2E;AACA,yB;AACA,4D;;AAEA,oB;AACA,O;;AAEA,oC;AACA,iD;AACA,oC;AACA,iB;AACA,gC;AACA,+C;AACA,2C;AACA,0C;AACA,4B;AACA,mC;AACA,8B;AACA,mD;AACA,kB;;AAEA,sC;AACA,+B;AACA,mC;AACA,+C;;AAEA,qD;AACA,qD;AACA,qC;AACA,kD;AACA,qD;AACA,oD;AACA,4B;AACA,+B;AACA,uD;AACA,mD;AACA,gC;;AAEA,4D;AACA,yD;AACA,uD;AACA,qB;AACA,+B;AACA,sC;AACA,oC;AACA,0C;AACA,6C;AACA,sD;AACA,kD;AACA,8C;AACA,kC;AACA,kC;AACA,kC;AACA,mC;AACA,oC;AACA,uB;AACA,qB;AACA,kE;AACA,O;AACA,0D;;AAEA,4D;AACA,qB;AACA,uB;AACA,qB;AACA,kB;AACA,8C;AACA,sB;AACA,2B;AACA,iD;AACA,uD;AACA,wB;AACA,+B;AACA,0B;AACA,+C;AACA,c;AACA,O;AACA,oE;;AAEA,iE;;AAEA,uD;AACA,qB;AACA,wB;AACA,qB;AACA,sB;AACA,gE;AACA,kB;AACA,wB;;AAEA,6C;AACA,yD;AACA,6D;AACA,8C;AACA,0B;AACA,iB;AACA,+D;AACA,0B;AACA,8E;;AAEA,mC;AACA,gC;AACA,6B;AACA,kC;AACA,oE;AACA,W;AACA,wB;AACA,W;AACA,O;AACA,8D;;AAEA,6C;AACA,qB;AACA,uB;AACA,qB;AACA,kB;AACA,gE;AACA,wB;AACA,+B;AACA,0B;AACA,6C;AACA,c;AACA,O;AACA,0C;;AAEA,e;;AAEA,+D;AACA,4B;AACA,kB;;AAEA,4D;AACA,M;AACA,qE;AACA,mE;AACA,qE;AACA,yC;AACA,M;AACA,0D;AACA,oE;AACA,kE;AACA,gE;AACA,+D;AACA,mB;AACA,6D;AACA,2D;AACA,uB;AACA,0B;AACA,2B;AACA,+B;AACA,Y;AACA,+D;AACA,6B;AACA,K;AACA,yE;AACA,mC;AACA,+B;AACA,+B;AACA,2B;AACA,sC;AACA,uC;AACA,wB;AACA,wB;AACA,O;AACA,6B;AACA,K;AACA,gB;AACA,M;;AAEA,gD;;AAEA,wD;AACA,iC;AACA,gB;AACA,kB;AACA,W;AACA,Y;AACA,+B;AACA,qC;AACA,mC;AACA,2C;AACA,e;AACA,6C;;AAEA,iC;AACA,sB;AACA,Q;AACA,+D;AACA,qB;AACA,gC;AACA,sC;AACA,8D;AACA,+D;AACA,uE;AACA,sD;AACA,mE;AACA,oD;AACA,+C;AACA,kE;;AAEA,+C;AACA,iD;AACA,wD;AACA,0D;AACA,yD;AACA,oD;AACA,yB;AACA,0D;AACA,0B;AACA,2C;AACA,8C;AACA,S;AACA,kB;AACA,mD;AACA,sB;AACA,oB;;AAEA,uC;AACA,4C;AACA,uC;AACA,+C;AACA,kE;AACA,2C;AACA,U;AACA,4D;AACA,8D;AACA,qD;AACA,iC;AACA,yB;AACA,O;;AAEA,iD;AACA,iB;AACA,yB;;AAEA,wC;AACA,4D;AACA,O;;AAEA,4E;;AAEA,iE;AACA,oD;AACA,kB;;AAEA,+D;AACA,gB;AACA,gB;AACA,kC;AACA,6B;AACA,0D;AACA,K;AACA,wC;;AAEA,+B;AACA,e;AACA,gD;AACA,yB;;AAEA,gD;AACA,oC;AACA,4D;;AAEA,yB;AACA,c;AACA,4C;AACA,6C;AACA,6C;;AAEA,qC;AACA,gB;AACA,4B;AACA,Y;AACA,6C;AACA,qC;AACA,gC;AACA,yB;AACA,6C;AACA,qC;AACA,gC;AACA,4B;AACA,4C;AACA,kD;AACA,oE;AACA,+B;AACA,c;AACA,wB;AACA,kC;AACA,qB;AACA,yB;AACA,uB;AACA,oB;AACA,qB;AACA,wC;AACA,mC;AACA,mE;AACA,yC;AACA,sE;AACA,uE;AACA,6B;AACA,mC;AACA,mD;AACA,2D;AACA,6D;AACA,kB;AACA,kB;AACA,c;AACA,uB;AACA,8D;AACA,2B;AACA,yB;AACA,kD;AACA,wB;AACA,yD;AACA,oC;AACA,8C;AACA,kD;AACA,iE;AACA,mC;AACA,yD;AACA,Y;;AAEA,2C;AACA,c;AACA,8C;AACA,gF;AACA,kF;AACA,6E;AACA,6E;AACA,8E;AACA,0E;AACA,8E;AACA,4E;AACA,oE;AACA,sE;AACA,kD;AACA,kF;AACA,uD;AACA,qF;AACA,sD;AACA,mF;AACA,2C;AACA,6B;;AAEA,8B;AACA,+D;AACA,2D;AACA,yC;AACA,kE;AACA,kE;AACA,mD;AACA,yB;AACA,mE;AACA,mB;;AAEA,6B;AACA,kB;AACA,4B;AACA,4D;AACA,yB;AACA,+B;AACA,oB;AACA,8B;AACA,yE;AACA,yB;AACA,4B;AACA,iB;AACA,2B;AACA,yE;AACA,yB;AACA,4B;AACA,iB;AACA,uB;AACA,oC;AACA,sE;AACA,sE;AACA,gE;AACA,kD;AACA,mC;AACA,4C;AACA,mF;AACA,mC;AACA,wB;AACA,yB;;AAEA,2B;AACA,gB;AACA,yE;AACA,oB;;AAEA,wB;AACA,W;AACA,8C;AACA,+B;AACA,0C;AACA,yB;AACA,2B;AACA,c;AACA,qC;AACA,+B;AACA,kC;AACA,yB;;AAEA,6B;AACA,kB;AACA,4D;AACA,mB;AACA,+B;AACA,qC;AACA,6B;AACA,8B;AACA,wC;AACA,qB;;AAEA,+B;AACA,Y;AACA,wC;AACA,Y;AACA,kB;AACA,oB;AACA,oE;AACA,6C;AACA,4B;AACA,kB;AACA,sB;AACA,mD;AACA,+B;AACA,0B;AACA,e;AACA,qD;AACA,+B;AACA,6D;;AAEA,oC;AACA,sD;AACA,0C;AACA,0C;AACA,6C;AACA,uC;AACA,8C;AACA,2C;AACA,6C;AACA,0C;AACA,yC;AACA,2C;AACA,0C;AACA,wC;AACA,+C;;AAEA,Y;;AAEA,0B;AACA,qD;;AAEA,iE;AACA,mE;AACA,mD;AACA,kD;AACA,wD;;AAEA,2B;AACA,6D;;AAEA,qB;AACA,c;AACA,4B;AACA,wD;AACA,4D;;AAEA,6B;AACA,E","sourcesContent":["var regexEscape = function (str) {\n  return str.replace(/[\\][^$\\\\.*+?(){}|]/g, '\\\\$&');\n};\n\n// Adapted from source code of http://xregexp.com/plugins/#unicode\nvar unicodeCategories = {\n  Ll: \"0061-007A00B500DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F05210523052505270561-05871D00-1D2B1D6B-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7B2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2CF32D00-2D252D272D2DA641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA661A663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CA78EA791A793A7A1A7A3A7A5A7A7A7A9A7FAFB00-FB06FB13-FB17FF41-FF5A\",\n  Lm: \"02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D6A1D781D9B-1DBF2071207F2090-209C2C7C2C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A7F8A7F9A9CFAA70AADDAAF3AAF4FF70FF9EFF9F\",\n  Lo: \"00AA00BA01BB01C0-01C3029405D0-05EA05F0-05F20620-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150840-085808A008A2-08AC0904-0939093D09500958-09610972-09770979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA10FD-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF11CF51CF62135-21382D30-2D672D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCAAE0-AAEAAAF2AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC\",\n  Lt: \"01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC\",\n  Lu: \"0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E05200522052405260531-055610A0-10C510C710CD1E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CED2CF2A640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA660A662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BA78DA790A792A7A0A7A2A7A4A7A6A7A8A7AAFF21-FF3A\",\n  Mc: \"0903093B093E-09400949-094C094E094F0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1BAC1BAD1BE71BEA-1BEC1BEE1BF21BF31C24-1C2B1C341C351CE11CF21CF3302E302FA823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BAAEBAAEEAAEFAAF5ABE3ABE4ABE6ABE7ABE9ABEAABEC\",\n  Mn: \"0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065F067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0859-085B08E4-08FE0900-0902093A093C0941-0948094D0951-095709620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F8D-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135D-135F1712-17141732-1734175217531772177317B417B517B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91BAB1BE61BE81BE91BED1BEF-1BF11C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1CF41DC0-1DE61DFC-1DFF20D0-20DC20E120E5-20F02CEF-2CF12D7F2DE0-2DFF302A-302D3099309AA66FA674-A67DA69FA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1AAECAAEDAAF6ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26\",\n  Nd: \"0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19\",\n  Nl: \"16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF\",\n  Pc: \"005F203F20402054FE33FE34FE4D-FE4FFF3F\"\n};\n\nvar unicodeClass = function (abbrev) {\n  return '[' +\n    unicodeCategories[abbrev].replace(/[0-9A-F]{4}/ig, \"\\\\u$&\") + ']';\n};\n\n// See ECMA-262 spec, 3rd edition, section 7\n\n// Section 7.2\n// Match one or more characters of whitespace, excluding line terminators.\n// Do this by matching reluctantly, stopping at a non-dot (line terminator\n// or end of string) or a non-whitespace.\n// We are taking advantage of the fact that we are parsing JS from JS in\n// regexes like this by \"passing through\" the spec's definition of whitespace,\n// which is the same in regexes and the lexical grammar.\nvar rWhiteSpace = /[^\\S\\u000A\\u000D\\u2028\\u2029]+/g;\n// Section 7.3\n// Match one line terminator.  Same as (?!.)[\\s\\S] but more explicit.\nvar rLineTerminator = /[\\u000A\\u000D\\u2028\\u2029]/g;\n// Section 7.4\n// Match one multi-line comment.\n// [\\s\\S] is shorthand for any character, including newlines.\n// The *? reluctant qualifier makes this easy.\nvar rMultiLineComment = /\\/\\*[\\s\\S]*?\\*\\//g;\n// Match one single-line comment, not including the line terminator.\nvar rSingleLineComment = /\\/\\/.*/g;\n// Section 7.6\n// Match one or more characters that can start an identifier.\n// This is IdentifierStart+.\nvar rIdentifierPrefix = new RegExp(\n  \"([a-zA-Z$_]+|\\\\\\\\u[0-9a-fA-F]{4}|\" +\n    [unicodeClass('Lu'), unicodeClass('Ll'), unicodeClass('Lt'),\n     unicodeClass('Lm'), unicodeClass('Lo'), unicodeClass('Nl')].join('|') +\n    \")+\", 'g');\n// Match one or more characters that can continue an identifier.\n// This is (IdentifierPart and not IdentifierStart)+.\n// To match a full identifier, match rIdentifierPrefix, then\n// match rIdentifierMiddle followed by rIdentifierPrefix until they both fail.\nvar rIdentifierMiddle = new RegExp(\n  \"([0-9]|\" + [unicodeClass('Mn'), unicodeClass('Mc'), unicodeClass('Nd'),\n               unicodeClass('Pc')].join('|') + \")+\", 'g');\n// Section 7.7\n// Match one punctuator (except for division punctuators).\nvar rPunctuator = new RegExp(\n  regexEscape(\"{ } ( ) [ ] . ; , < > <= >= == != === !== + - * % ++ -- << >> \"+\n              \">>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^=\")\n  // sort from longest to shortest so that we don't match '==' for '===' and\n  // '*' for '*=', etc.\n    .split(' ').sort(function (a,b) { return b.length - a.length; })\n    .join('|'), 'g');\nvar rDivPunctuator = /\\/=?/g;\n// Section 7.8.3\nvar rHexLiteral = /0[xX][0-9a-fA-F]+(?!\\w)/g;\nvar rOctLiteral = /0[0-7]+(?!\\w)/g; // deprecated\nvar rDecLiteral =\n      /(((0|[1-9][0-9]*)(\\.[0-9]*)?)|\\.[0-9]+)([Ee][+-]?[0-9]+)?(?!\\w)/g;\n// Section 7.8.4\nvar rStringQuote = /[\"']/g;\n// Match one or more characters besides quotes, backslashes, or line ends\nvar rStringMiddle = /(?=.)[^\"'\\\\]+?((?!.)|(?=[\"'\\\\]))/g;\n// Match one escape sequence, including the backslash.\nvar rEscapeSequence =\n      /\\\\(['\"\\\\bfnrtv]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/g;\n// Match one ES5 line continuation\nvar rLineContinuation =\n      /\\\\(\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/g;\n// Section 7.8.5\n// Match one regex literal, including slashes, not including flags.\n// Support unescaped '/' in character classes, per 5th ed.\n// For example: `/[/]/` will match the string `\"/\"`.\n//\n// Explanation of regex:\n// - Match `/` not followed by `/` or `*`\n// - Match one or more of any of these:\n//   - Backslash followed by one non-newline\n//   - One non-newline, not `[` or `\\` or `/`\n//   - A character class, beginning with `[` and ending with `]`.\n//     In the middle is zero or more of any of these:\n//     - Backslash followed by one non-newline\n//     - One non-newline, not `]` or `\\`\n// - Match closing `/`\nvar rRegexLiteral =\n      /\\/(?![*\\/])(\\\\.|(?=.)[^\\[\\/\\\\]|\\[(\\\\.|(?=.)[^\\]\\\\])*\\])+\\//g;\nvar rRegexFlags = /[a-zA-Z]*/g;\n\nvar rDecider =\n      /((?=.)\\s)|(\\/[\\/\\*]?)|([\\][{}();,<>=!+*%&|^~?:-]|\\.(?![0-9]))|([\\d.])|([\"'])|(.)|([\\S\\s])/g;\n\nvar keywordLookup = {\n  ' break': 'KEYWORD',\n  ' case': 'KEYWORD',\n  ' catch': 'KEYWORD',\n  ' continue': 'KEYWORD',\n  ' debugger': 'KEYWORD',\n  ' default': 'KEYWORD',\n  ' delete': 'KEYWORD',\n  ' do': 'KEYWORD',\n  ' else': 'KEYWORD',\n  ' finally': 'KEYWORD',\n  ' for': 'KEYWORD',\n  ' function': 'KEYWORD',\n  ' if': 'KEYWORD',\n  ' in': 'KEYWORD',\n  ' instanceof': 'KEYWORD',\n  ' new': 'KEYWORD',\n  ' return': 'KEYWORD',\n  ' switch': 'KEYWORD',\n  ' this': 'KEYWORD',\n  ' throw': 'KEYWORD',\n  ' try': 'KEYWORD',\n  ' typeof': 'KEYWORD',\n  ' var': 'KEYWORD',\n  ' void': 'KEYWORD',\n  ' while': 'KEYWORD',\n  ' with': 'KEYWORD',\n\n  ' false': 'BOOLEAN',\n  ' true': 'BOOLEAN',\n\n  ' null': 'NULL'\n};\n\nvar makeSet = function (array) {\n  var s = {};\n  for (var i = 0, N = array.length; i < N; i++)\n    s[array[i]] = true;\n  return s;\n};\n\nvar nonTokenTypes = makeSet('WHITESPACE COMMENT NEWLINE EOF ERROR'.split(' '));\n\nvar punctuationBeforeDivision = makeSet('] ) } ++ --'.split(' '));\nvar keywordsBeforeDivision = makeSet('this'.split(' '));\n\nvar guessIsDivisionPermittedAfterToken = function (tok) {\n  // Figure out if a '/' character should be interpreted as division\n  // rather than the start of a regular expression when it follows the\n  // token, which must be a token lexeme per isToken().\n  // The beginning of section 7 of the spec briefly\n  // explains what's going on; basically the lexical grammar can't\n  // distinguish, for example, `e/f/g` (division) from `e=/f/g`\n  // (assignment of a regular expression), among many other variations.\n  //\n  // THIS IS ONLY A HEURISTIC, though it will rarely fail.\n  // Here are the two cases I know of where help from the parser is needed:\n  //  - if (foo)\n  //        /ba/.test(\"banana\") && console.log(\"matches\");\n  //    (Close paren of a control structure before a statement starting with\n  //     a regex literal.  Starting a statement with a regex literal is\n  //     unusual, of course, because it's hard to have a side effect.)\n  //  - ++ /foo/.abc\n  //    (Prefix `++` or `--` before an expression starting with a regex\n  //     literal.  This will run but I can't see any use for it.)\n  switch (tok.type()) {\n  case \"PUNCTUATION\":\n    // few punctuators can end an expression, but e.g. `)`\n    return !! punctuationBeforeDivision[tok.text()];\n  case \"KEYWORD\":\n    // few keywords can end an expression, but e.g. `this`\n    return !! keywordsBeforeDivision[tok.text()];\n  case \"IDENTIFIER\":\n    return true;\n  default: // literal\n    return true;\n  }\n};\n\n////////// PUBLIC API\n\nvar Lexeme = function (pos, type, text) {\n  this._pos = pos;\n  this._type = type;\n  this._text = text;\n};\n\nLexeme.prototype.startPos = function () {\n  return this._pos;\n};\n\nLexeme.prototype.endPos = function () {\n  return this._pos + this._text.length;\n};\n\nLexeme.prototype.type = function () {\n  return this._type;\n};\n\nLexeme.prototype.text = function () {\n  return this._text;\n};\n\nLexeme.prototype.isToken = function () {\n  return ! nonTokenTypes[this._type];\n};\n\nLexeme.prototype.isError = function () {\n  return this._type === \"ERROR\";\n};\n\nLexeme.prototype.isEOF = function () {\n  return this._type === \"EOF\";\n};\n\nLexeme.prototype.prev = function () {\n  return this._prev;\n};\n\nLexeme.prototype.next = function () {\n  return this._next;\n};\n\nLexeme.prototype.toString = function () {\n  return this.isError() ? \"ERROR\" :\n    this.isEOF() ? \"EOF\" : \"`\" + this.text() + \"`\";\n};\n\n// Create a Lexer for the given string of JavaScript code.\n//\n// A lexer keeps a pointer `pos` into the string that is\n// advanced when you ask for the next lexeme with `next()`.\n//\n// XXXXX UPDATE DOCS\n// Properties:\n//   code: Original JavaScript code string.\n//   pos:  Current index into the string.  You can assign to it\n//           to continue lexing from a different position.  After\n//           calling next(), it is the ending index of the most\n//           recent lexeme.\n//   lastPos:  The starting index of the most recent lexeme.\n//           Equal to `pos - text.length`.\n//   text: Text of the last lexeme as a string.\n//   type: Type of the last lexeme, as returned by `next()`.\n//   divisionPermitted: Whether a '/' character should be interpreted\n//           as division rather than the start of a regular expression.\n//           This flag is set automatically during lexing based on the\n//           previous token (i.e. the most recent token lexeme), but\n//           it is technically only a heuristic.\n//           Thie flag can be read and set manually to affect the\n//           parsing of the next token.\n\nJSLexer = function (code) {\n  this.code = code;\n  this.pos = 0;\n  this.divisionPermitted = false;\n  this.lastLexeme = null;\n};\n\nJSLexer.Lexeme = Lexeme;\n\n// XXXX UPDATE DOCS\n// Return the type of the next of lexeme starting at `pos`, and advance\n// `pos` to the end of the lexeme.  The text of the lexeme is available\n// in `text`.  The text is always the substring of `code` between the\n// old and new values of `pos`.  An \"EOF\" lexeme terminates\n// the stream.  \"ERROR\" lexemes indicate a bad input string.  Out of all\n// lexemes, only \"EOF\" has empty text, and it always has empty text.\n// All others contain at least one character from the source code.\n//\n// Lexeme types:\n// Literals: BOOLEAN, NULL, REGEX, NUMBER, STRING\n// Whitespace-like: WHITESPACE, COMMENT, NEWLINE, EOF\n// Other Tokens: IDENTIFIER, KEYWORD, PUNCTUATION\n// ... and ERROR\n\nJSLexer.prototype.next = function () {\n  var self = this;\n  var code = self.code;\n  var origPos = self.pos;\n  var divisionPermitted = self.divisionPermitted;\n\n  if (origPos > code.length)\n    throw new Error(\"out of range\");\n\n  // Running regexes inside this function will move this local\n  // `pos` forward.\n  // When we commit to emitting a lexeme, we'll set self.pos\n  // based on it.\n  var pos = origPos;\n\n  // Emit a lexeme.  Always called as `return lexeme(type)`.\n  var lexeme = function (type) {\n    // If `pos` hasn't moved, we consider this an error.\n    // This means that grammar cases that only run one regex\n    // or an alternation ('||') of regexes don't need to\n    // check for failure.\n    // This also guarantees that only EOF lexemes are empty.\n    if (pos === origPos && type !== 'EOF') {\n      type = 'ERROR';\n      pos = origPos + 1;\n    }\n    self.pos = pos;\n    var lex = new JSLexer.Lexeme(origPos, type, code.substring(origPos, pos));\n    if (self.lastLexeme) {\n      self.lastLexeme._next = lex;\n      lex._prev = self.lastLexeme;\n    }\n    self.lastLexeme = lex;\n    if (lex.isToken())\n      self.divisionPermitted = guessIsDivisionPermittedAfterToken(lex);\n    return lex;\n  };\n\n  if (pos === code.length)\n    return lexeme('EOF');\n\n  // Result of the regex match in the most recent call to `run`.\n  var match = null;\n\n  // Run a regex starting from `pos`, recording the end of the matched\n  // string in `pos` and the match data in `match`.  The regex must have\n  // the 'g' (global) flag.  If it doesn't match at `pos`, set `match`\n  // to null.  The caller should expect the regex to match at `pos`, as\n  // failure is too expensive to run in a tight loop.\n  var run = function (regex) {\n    // Cause regex matching to start at `pos`.\n    regex.lastIndex = pos;\n    match = regex.exec(code);\n    // Simulate \"sticky\" matching by throwing out the match if it\n    // didn't match exactly at `pos`.  If it didn't, we may have\n    // just searched the entire string.\n    if (match && (match.index !== pos))\n      match = null;\n    // Record the end position of the match back into `pos`.\n    // Avoid an IE7 bug where lastIndex is incremented when\n    // the match has 0 length.\n    if (match && match[0].length !== 0)\n      pos = regex.lastIndex;\n    return match;\n  };\n\n  // Decide which case of the grammar we are in based on one or two\n  // characters, then roll back `pos`.\n  run(rDecider);\n  pos = origPos;\n\n  // Grammar cases\n  if (match[1]) { // \\s\n    run(rWhiteSpace);\n    return lexeme('WHITESPACE');\n  }\n  if (match[2]) { // one of //, /*, /\n    if (match[2] === '//') {\n      run(rSingleLineComment);\n      return lexeme('COMMENT');\n    }\n    if (match[2] === '/*') {\n      run(rMultiLineComment);\n      return lexeme(match ? 'COMMENT' : 'ERROR');\n    }\n    if (match[2] === '/') {\n      if (divisionPermitted) {\n        run(rDivPunctuator);\n        return lexeme('PUNCTUATION');\n      } else {\n        run(rRegexLiteral);\n        if (! match)\n          return lexeme('ERROR');\n        run(rRegexFlags);\n        return lexeme('REGEX');\n      }\n    }\n  }\n  if (match[3]) { // any other punctuation char\n    run(rPunctuator);\n    return lexeme(match ? 'PUNCTUATION' : 'ERROR');\n  }\n  if (match[4]) { // 0-9\n    run(rDecLiteral) || run(rHexLiteral) || run(rOctLiteral);\n    return lexeme(match ? 'NUMBER' : 'ERROR');\n  }\n  if (match[5]) { // \" or '\n    run(rStringQuote);\n    var quote = match[0];\n    do {\n      run(rStringMiddle) || run(rEscapeSequence) ||\n        run(rLineContinuation) || run(rStringQuote);\n    } while (match && match[0] !== quote);\n    if (! (match && match[0] === quote))\n      return lexeme('ERROR');\n    return lexeme('STRING');\n  }\n  if (match[7]) { // non-dot (line terminator)\n    run(rLineTerminator);\n    return lexeme('NEWLINE');\n  }\n  // dot (any non-line-terminator)\n  run(rIdentifierPrefix);\n  // Use non-short-circuiting bitwise OR, '|', to always try\n  // both regexes in sequence, returning false only if neither\n  // matched.\n  while ((!! run(rIdentifierMiddle)) |\n         (!! run(rIdentifierPrefix))) { /*continue*/ }\n  var word = code.substring(origPos, pos);\n  return lexeme(keywordLookup[' '+word] || 'IDENTIFIER');\n};\n\nJSLexer.prettyOffset = function (code, pos) {\n  var codeUpToPos = code.substring(0, pos);\n  var startOfLine = codeUpToPos.lastIndexOf('\\n') + 1;\n  var indexInLine = pos - startOfLine; // 0-based\n  var lineNum = codeUpToPos.replace(/[^\\n]+/g, '').length + 1; // 1-based\n  return \"line \" + lineNum + \", offset \" + indexInLine;\n};\n","///// TOKENIZER AND PARSER COMBINATORS\n\n// XXX track line/col position, for errors and maybe token info\n\nvar isArray = function (obj) {\n  return obj && (typeof obj === 'object') && (typeof obj.length === 'number');\n};\n\nParseNode = function (name, children) {\n  this.name = name;\n  this.children = children;\n\n  if (! isArray(children))\n    throw new Error(\"Expected array in new ParseNode(\" + name + \", ...)\");\n};\n\n\nParser = function (expecting, runFunc) {\n  this.expecting = expecting;\n  this._run = runFunc;\n};\n\nParser.prototype.parse = function (t) {\n  return this._run(t);\n};\n\nParser.prototype.parseRequired = function (t) {\n  return this.parseRequiredIf(t, true);\n};\n\nParser.prototype.parseRequiredIf = function (t, required) {\n  var result = this._run(t);\n\n  if (required && ! result)\n    throw t.getParseError(this.expecting);\n\n  return result;\n};\n\nParser.expecting = function (expecting, parser) {\n  return new Parser(expecting, parser._run);\n};\n\n\n// A parser that consume()s has to succeed.\n// Similarly, a parser that fails can't have consumed.\n\nParsers = {};\n\nParsers.assertion = function (test) {\n  return new Parser(\n    null, function (t) {\n      return test(t) ? [] : null;\n    });\n};\n\nParsers.node = function (name, childrenParser) {\n  return new Parser(name, function (t) {\n    var children = childrenParser.parse(t);\n    if (! children)\n      return null;\n    if (! isArray(children))\n      children = [children];\n    return new ParseNode(name, children);\n  });\n};\n\nParsers.or = function (/*parsers*/) {\n  var args = arguments;\n  return new Parser(\n    args[args.length - 1].expecting,\n    function (t) {\n      var result;\n      for(var i = 0, N = args.length; i < N; i++) {\n        result = args[i].parse(t);\n        if (result)\n          return result;\n      }\n      return null;\n    });\n};\n\n// Parses a left-recursive expression with zero or more occurrences\n// of a binary op.  Leaves the term unwrapped if no op.  For example\n// (in a hypothetical use case):\n// `1` => \"1\"\n// `1+2` => [\"binary\", \"1\", \"+\", \"2\"]\n// `1+2+3` => [\"binary\", [\"binary\", \"1\", \"+\", \"2\"], \"+\", \"3\"]\n//\n// opParsers is an array of op parsers from high to low\n// precedence (tightest-binding first)\nParsers.binaryLeft = function (name, termParser, opParsers) {\n  var opParser;\n\n  if (opParsers.length === 1) {\n    // take single opParser out of its array\n    opParser = opParsers[0];\n  } else {\n    // pop off last opParser (non-destructively) and replace\n    // termParser with a recursive binaryLeft on the remaining\n    // ops.\n    termParser = Parsers.binaryLeft(name, termParser, opParsers.slice(0, -1));\n    opParser = opParsers[opParsers.length - 1];\n  }\n\n  return new Parser(\n    termParser.expecting,\n    function (t) {\n      var result = termParser.parse(t);\n      if (! result)\n        return null;\n\n      var op;\n      while ((op = opParser.parse(t))) {\n        result = new ParseNode(\n          name,\n          [result, op, termParser.parseRequired(t)]);\n      }\n      return result;\n    });\n};\n\nParsers.unary = function (name, termParser, opParser) {\n  var unaryList = Parsers.opt(Parsers.list(opParser));\n  return new Parser(\n    termParser.expecting,\n    function (t) {\n      var unaries = unaryList.parse(t);\n      // if we have unaries, we are committed and\n      // have to match a term or error.\n      var result = termParser.parseRequiredIf(t, unaries.length);\n      if (! result)\n        return null;\n\n      while (unaries.length)\n        result = new ParseNode(name, [unaries.pop(), result]);\n      return result;\n    });\n};\n\n// Parses a list of one or more items with a separator, listing the\n// items and separators.  (Separator is optional.)  For example:\n// `x` => [\"x\"]\n// `x,y` => [\"x\", \",\", \"y\"]\n// `x,y,z` => [\"x\", \",\", \"y\", \",\", \"z\"]\n// Unpacks.\nParsers.list = function (itemParser, sepParser) {\n  var push = function(array, newThing) {\n    if (isArray(newThing))\n      array.push.apply(array, newThing);\n    else\n      array.push(newThing);\n  };\n  return new Parser(\n    itemParser.expecting,\n    function (t) {\n      var result = [];\n      var firstItem = itemParser.parse(t);\n      if (! firstItem)\n        return null;\n      push(result, firstItem);\n\n      if (sepParser) {\n        var sep;\n        while ((sep = sepParser.parse(t))) {\n          push(result, sep);\n          push(result, itemParser.parseRequired(t));\n        }\n      } else {\n        var item;\n        while ((item = itemParser.parse(t)))\n          push(result, item);\n      }\n      return result;\n    });\n};\n\n// Unpacks arrays (nested seqs).\nParsers.seq = function (/*parsers*/) {\n  var args = arguments;\n  if (! args.length)\n    return Parsers.constant([]);\n\n  return new Parser(\n    args[0].expecting,\n    function (t) {\n      var result = [];\n      for (var i = 0, N = args.length; i < N; i++) {\n        // first item in sequence can fail, and we\n        // fail (without error); after that, error on failure\n        var r = args[i].parseRequiredIf(t, i > 0);\n        if (! r)\n          return null;\n\n        if (isArray(r)) // append array!\n          result.push.apply(result, r);\n        else\n          result.push(r);\n      }\n      return result;\n    });\n};\n\n// parsers except last must never consume\nParsers.and = function (/*parsers*/) {\n  var args = arguments;\n  if (! args.length)\n    return Parsers.constant([]);\n\n  return new Parser(\n    args[args.length - 1].expecting,\n    function (t) {\n      var result;\n      for(var i = 0, N = args.length; i < N; i++) {\n        result = args[i].parse(t);\n        if (! result)\n          return null;\n      }\n      return result;\n    });\n};\n\n// parser must not consume\nParsers.not = function (parser) {\n  return new Parser(\n    null,\n    function (t) {\n      return parser.parse(t) ? null : [];\n    });\n};\n\n// parser that looks at nothing and returns result\nParsers.constant = function (result) {\n  return new Parser(null,\n                    function (t) { return result; });\n};\n\nParsers.opt = function (parser) {\n  return Parser.expecting(\n    parser.expecting,\n    Parsers.or(parser, Parsers.seq()));\n};\n\nParsers.mapResult = function (parser, func) {\n  return new Parser(\n    parser.expecting,\n    function (t) {\n      var v = parser.parse(t);\n      return v ? func(v, t) : null;\n    });\n};\n\nParsers.lazy = function (expecting, parserFunc) {\n  var inner = null;\n  return new Parser(expecting, function (t) {\n    if (! inner)\n      inner = parserFunc();\n    return inner.parse(t);\n  });\n};\n","// The \"tree string\" format is a simple format for representing syntax trees.\n//\n// For example, the parse of `x++;` is written as:\n// \"program(expressionStmnt(postfix(identifier(x) ++) ;))\"\n//\n// A Node is written as \"name(item1 item2 item3)\", with additional whitespace\n// allowed anywhere between the name, parentheses, and items.\n//\n// Tokens don't need to be escaped unless they contain '(', ')', whitespace, or\n// backticks, or are empty.  If they do, they can be written enclosed in backticks.\n// To escape a backtick within backticks, double it.\n//\n// `stringify` generates \"canonical\" tree strings, which have no extra escaping\n// or whitespace, just one space between items in a Node.\n\n\nParseNode.prototype.stringify = function () {\n  return ParseNode.stringify(this);\n};\n\nvar backtickEscape = function (str) {\n  if (/[\\s()`]/.test(str))\n    return '`' + str.replace(/`/g, '``') + '`';\n  else if (! str)\n    return '``';\n  else\n    return str;\n};\n\nvar backtickUnescape = function (str) {\n  if (str.charAt(0) === '`') {\n    if (str.length === 1 || str.slice(-1) !== '`')\n      throw new Error(\"Mismatched ` in \" + str);\n    if (str.length === 2)\n      str = '';\n    else\n      str = str.slice(1, -1).replace(/``/g, '`');\n  }\n  return str;\n};\n\nParseNode.stringify = function (tree) {\n  if (tree instanceof ParseNode) {\n    var str = backtickEscape(tree.name);\n    str += '(';\n    var escapedChildren = [];\n    for(var i = 0, N = tree.children.length; i < N; i++)\n      escapedChildren.push(ParseNode.stringify(tree.children[i]));\n    str += escapedChildren.join(' ');\n    str += ')';\n    return str;\n  }\n\n  // Treat a token object or string as a token.\n  if (typeof tree.text === 'function')\n    tree = tree.text();\n  else if (typeof tree.text === 'string')\n    tree = tree.text;\n  return backtickEscape(String(tree));\n};\n\nParseNode.unstringify = function (str) {\n  var lexemes = str.match(/\\(|\\)|`([^`]||``)*`|`|[^\\s()`]+/g) || [];\n  var N = lexemes.length;\n  var state = {\n    i: 0,\n    getParseError: function (expecting) {\n      throw new Error(\"unstringify: Expecting \" + expecting +\", found \" +\n                      (lexemes[this.i] || \"end of string\"));\n    },\n    peek: function () { return lexemes[this.i]; },\n    advance: function () { this.i++; }\n  };\n  var paren = function (chr) {\n    return new Parser(chr, function (t) {\n      if (t.peek() !== chr)\n        return null;\n      t.advance();\n      return chr;\n    });\n  };\n  var EMPTY_STRING = [\"\"];\n  var token = new Parser('token', function (t) {\n    var txt = t.peek();\n    if (!txt || txt.charAt(0) === '(' || txt.charAt(0) === ')')\n      return null;\n\n    t.advance();\n    // can't return falsy value from successful parser\n    return backtickUnescape(txt) || EMPTY_STRING;\n  });\n\n  // Make \"item\" lazy so it can be recursive.\n  var item = Parsers.lazy('token', function () { return item; });\n\n  // Parse a single node or token.\n  item = Parsers.mapResult(\n    Parsers.seq(token,\n                Parsers.opt(Parsers.seq(\n                  paren('('), Parsers.opt(Parsers.list(item)), paren(')')))),\n    function (v) {\n      for(var i = 0, N = v.length; i < N; i++)\n        if (v[i] === EMPTY_STRING)\n          v[i] = \"\";\n\n      if (v.length === 1)\n        // token\n        return v[0];\n      // node. exclude parens\n      return new ParseNode(v[0], v.slice(2, -1));\n    });\n\n  var endOfString = new Parser(\"end of string\", function (t) {\n    return t.i === N ? [] : null;\n  });\n\n  return Parsers.seq(item, endOfString).parseRequired(state)[0];\n};\n","///// JAVASCRIPT PARSER\n\n// What we don't support from ECMA-262 5.1:\n//  - object literal trailing comma\n//  - object literal get/set\n\nvar expecting = Parser.expecting;\n\nvar assertion = Parsers.assertion;\nvar node = Parsers.node;\nvar or = Parsers.or;\nvar and = Parsers.and;\nvar not = Parsers.not;\nvar list = Parsers.list;\nvar seq = Parsers.seq;\nvar opt = Parsers.opt;\nvar constant = Parsers.constant;\nvar mapResult = Parsers.mapResult;\n\n\nvar makeSet = function (array) {\n  var s = {};\n  for (var i = 0, N = array.length; i < N; i++)\n    s[array[i]] = true;\n  return s;\n};\n\n\nJSParser = function (code, options) {\n  this.lexer = new JSLexer(code);\n  this.oldToken = null;\n  this.newToken = null;\n  this.pos = 0;\n  this.isLineTerminatorHere = false;\n  this.includeComments = false;\n  // the last COMMENT lexeme between oldToken and newToken\n  // that we've consumed, if any.\n  this.lastCommentConsumed = null;\n\n  options = options || {};\n  // pass {tokens:'strings'} to get strings for\n  // tokens instead of token objects\n  if (options.tokens === 'strings') {\n    this.tokenFunc = function (tok) {\n      return tok.text();\n    };\n  } else {\n    this.tokenFunc = function (tok) {\n      return tok;\n    };\n  }\n\n  // pass {includeComments: true} to include comments in the AST.  For\n  // a comment to be included, it must occur where a series of\n  // statements could occur, and it must be preceded by only comments\n  // and whitespace on the same line.\n  if (options.includeComments) {\n    this.includeComments = true;\n  }\n};\n\nJSParser.prototype.consumeNewToken = function () {\n  var self = this;\n  var lexer = self.lexer;\n  self.oldToken = self.newToken;\n  self.isLineTerminatorHere = false;\n  var lex;\n  do {\n    lex = lexer.next();\n    if (lex.isError())\n      throw new Error(\"Bad token at \" +\n                      JSLexer.prettyOffset(lexer.code, lex.startPos()) +\n                      \", text `\" + lex.text() + \"`\");\n    else if (lex.type() === \"NEWLINE\")\n      self.isLineTerminatorHere = true;\n    else if (lex.type() === \"COMMENT\" && ! /^.*$/.test(lex.text()))\n      // multiline comments containing line terminators count\n      // as line terminators.\n      self.isLineTerminatorHere = true;\n  } while (! lex.isEOF() && ! lex.isToken());\n  self.newToken = lex;\n  self.pos = lex.startPos();\n  self.lastCommentConsumed = null;\n};\n\nJSParser.prototype.getParseError = function (expecting, found) {\n  var msg = (expecting ? \"Expected \" + expecting : \"Unexpected token\");\n  if (this.oldToken)\n    msg += \" after \" + this.oldToken;\n  var pos = this.pos;\n  msg += \" at \" + JSLexer.prettyOffset(this.lexer.code, pos);\n  msg += \", found \" + (found || this.newToken);\n  return new Error(msg);\n};\n\nJSParser.prototype.getSyntaxTree = function () {\n  var self = this;\n\n  self.consumeNewToken();\n\n  var NIL = new ParseNode('nil', []);\n\n  var booleanFlaggedParser = function (parserConstructFunc) {\n    return {\n      'false': parserConstructFunc(false),\n      'true': parserConstructFunc(true)\n    };\n  };\n\n  // Takes a space-separated list of either punctuation or keyword tokens\n  var lookAheadToken = function (tokens) {\n    var type = (/\\w/.test(tokens) ? 'KEYWORD' : 'PUNCTUATION');\n    var textSet = makeSet(tokens.split(' '));\n    return expecting(\n      tokens.split(' ').join(', '),\n      assertion(function (t) {\n        return (t.newToken.type() === type && textSet[t.newToken.text()]);\n      }));\n  };\n\n  var lookAheadTokenType = function (type) {\n    return expecting(type, assertion(function (t) {\n      return t.newToken.type() === type;\n    }));\n  };\n\n  // Takes a space-separated list of either punctuation or keyword tokens\n  var token = function (tokens) {\n    var type = (/\\w/.test(tokens) ? 'KEYWORD' : 'PUNCTUATION');\n    var textSet = makeSet(tokens.split(' '));\n    return new Parser(\n      tokens.split(' ').join(', '),\n      function (t) {\n        if (t.newToken.type() === type && textSet[t.newToken.text()]) {\n          t.consumeNewToken();\n          return self.tokenFunc(t.oldToken);\n        }\n        return null;\n      });\n  };\n\n  var tokenType = function (type) {\n    return new Parser(type, function (t) {\n      if (t.newToken.type() === type) {\n        t.consumeNewToken();\n        return self.tokenFunc(t.oldToken);\n      }\n      return null;\n    });\n  };\n\n  var noLineTerminatorHere = expecting(\n    'noLineTerminator', assertion(function (t) {\n      return ! t.isLineTerminatorHere;\n    }));\n\n  var nonLHSExpressionNames = makeSet(\n    'unary binary postfix ternary assignment comma'.split(' '));\n  var isExpressionLHS = function (exprNode) {\n    return ! nonLHSExpressionNames[exprNode.name];\n  };\n\n  // Like token, but marks tokens that need to defy the lexer's\n  // heuristic about whether the next '/' is a division or\n  // starts a regex.\n  var preSlashToken = function (text, divisionNotRegex) {\n    var inner = token(text);\n    return new Parser(\n      inner.expecting,\n      function (t) {\n        // temporarily set divisionPermitted,\n        // restoring it if we don't match.\n        var oldValue = t.lexer.divisionPermitted;\n        var result;\n        try {\n          t.lexer.divisionPermitted = divisionNotRegex;\n          result = inner.parse(t);\n          return result;\n        } finally {\n          if (! result)\n            t.lexer.divisionPermitted = oldValue;\n        }\n      });\n  };\n\n  // Mark some productions \"lazy\" to allow grammar circularity, i.e. accessing\n  // later parsers from earlier ones.\n  // These lazy versions will be replaced with real ones, which they will\n  // access when run.\n  var expressionMaybeNoIn = {\n    'false': Parsers.lazy(\n      'expression',\n      function () { return expressionMaybeNoIn[false]; }),\n    'true': Parsers.lazy(\n      'expression',\n      function () { return expressionMaybeNoIn[true]; })\n  };\n  var expression = expressionMaybeNoIn[false];\n\n  var assignmentExpressionMaybeNoIn = {\n    'false': Parsers.lazy(\n      'expression',\n      function () { return assignmentExpressionMaybeNoIn[false]; }),\n    'true': Parsers.lazy(\n      'expression',\n      function () { return assignmentExpressionMaybeNoIn[true]; })\n  };\n  var assignmentExpression = assignmentExpressionMaybeNoIn[false];\n\n  var functionBody = Parsers.lazy(\n    'statement', function () { return functionBody; });\n  var statement = Parsers.lazy(\n    'statement', function () { return statement; });\n  ////\n\n  var arrayLiteral =\n        node('array',\n             seq(token('['),\n                 opt(list(token(','))),\n                 or(\n                   lookAheadToken(']'),\n                   list(\n                     expecting(\n                       'expression',\n                       or(assignmentExpression,\n                          // count a peeked-at ']' as an expression\n                          // to support elisions at end, e.g.\n                          // `[1,2,3,,,,,,]`.\n                          lookAheadToken(']'))),\n                     // list seperator is one or more commas\n                     // to support elision\n                     list(token(',')))),\n                 token(']')));\n\n  // \"IdentifierName\" in ES5 allows reserved words, like in a property access\n  // or a key of an object literal.\n  // Put IDENTIFIER last so it shows up in the error message.\n  var identifierName = or(tokenType('NULL'), tokenType('BOOLEAN'),\n                          tokenType('KEYWORD'), tokenType('IDENTIFIER'));\n\n  var propertyName = expecting('propertyName', or(\n    node('idPropName', identifierName),\n    node('numPropName', tokenType('NUMBER')),\n    node('strPropName', tokenType('STRING'))));\n  var nameColonValue = expecting(\n    'propertyName',\n    node('prop', seq(propertyName, token(':'), assignmentExpression)));\n\n  // Allow trailing comma in object literal, per ES5.  Trailing comma\n  // must follow a `name:value`, that is, `{,}` is invalid.\n  //\n  // We can't just use a normal comma list(), because it will seize\n  // on the comma as a sign that the list continues.  Instead,\n  // we specify a list of either ',' or nameColonValue, using positive\n  // and negative lookAheads to constrain the sequence.  The grammar\n  // is ordered so that error messages will always say\n  // \"Expected propertyName\" or \"Expected ,\" as appropriate, not\n  // \"Expected ,\" when the look-ahead is negative or \"Expected }\".\n  var objectLiteral =\n        node('object',\n             seq(token('{'),\n                 or(lookAheadToken('}'),\n                    and(not(lookAheadToken(',')),\n                        list(or(seq(token(','),\n                                    expecting('propertyName',\n                                              not(lookAheadToken(',')))),\n                                seq(nameColonValue,\n                                    or(lookAheadToken('}'),\n                                       lookAheadToken(','))))))),\n                 expecting('propertyName', token('}'))));\n\n  var functionMaybeNameRequired = booleanFlaggedParser(\n    function (nameRequired) {\n      return seq(token('function'),\n                 (nameRequired ? tokenType('IDENTIFIER') :\n                  or(tokenType('IDENTIFIER'),\n                     and(lookAheadToken('('), constant(NIL)))),\n                 token('('),\n                 or(lookAheadToken(')'),\n                    list(tokenType('IDENTIFIER'), token(','))),\n                 token(')'),\n                 token('{'),\n                 functionBody,\n                 token('}'));\n    });\n  var functionExpression = node('functionExpr',\n                                functionMaybeNameRequired[false]);\n\n  var primaryOrFunctionExpression =\n        expecting('expression',\n                  or(node('this', token('this')),\n                     node('identifier', tokenType('IDENTIFIER')),\n                     node('number', tokenType('NUMBER')),\n                     node('boolean', tokenType('BOOLEAN')),\n                     node('null', tokenType('NULL')),\n                     node('regex', tokenType('REGEX')),\n                     node('string', tokenType('STRING')),\n                     node('parens',\n                          seq(token('('), expression, token(')'))),\n                     arrayLiteral,\n                     objectLiteral,\n                     functionExpression));\n\n\n  var dotEnding = seq(token('.'), identifierName);\n  var bracketEnding = seq(token('['), expression, token(']'));\n  var callArgs = seq(token('('),\n                     or(lookAheadToken(')'),\n                        list(assignmentExpression,\n                             token(','))),\n                     token(')'));\n\n  var newKeyword = token('new');\n\n  // This is a completely equivalent refactor of the spec's production\n  // for a LeftHandSideExpression.\n  //\n  // An lhsExpression is basically an expression that can serve as\n  // the left-hand-side of an assignment, though function calls and\n  // \"new\" invocation are included because they have the same\n  // precedence.  Actually, the spec technically allows a function\n  // call to \"return\" a valid l-value, as in `foo(bar) = baz`,\n  // though no built-in or user-specifiable call has this property\n  // (it would have to be defined by a browser or other \"host\").\n  var lhsExpression = new Parser(\n    'expression',\n    function (t) {\n      // Accumulate all initial \"new\" keywords, not yet knowing\n      // if they have a corresponding argument list later.\n      var news = [];\n      var n;\n      while ((n = newKeyword.parse(t)))\n        news.push(n);\n\n      // Read the primaryOrFunctionExpression that will be the \"core\"\n      // of this lhsExpression.  It is preceded by zero or more `new`\n      // keywords, and followed by any sequence of (...), [...],\n      // and .foo add-ons.\n      // if we have 'new' keywords, we are committed and must\n      // match an expression or error.\n      var result = primaryOrFunctionExpression.parseRequiredIf(t, news.length);\n      if (! result)\n        return null;\n\n      // Our plan of attack is to apply each dot, bracket, or call\n      // as we come across it.  Whether a call is a `new` call depends\n      // on whether there are `new` keywords we haven't used.  If so,\n      // we pop one off the stack.\n      var done = false;\n      while (! done) {\n        var r;\n        if ((r = dotEnding.parse(t))) {\n          result = new ParseNode('dot', [result].concat(r));\n        } else if ((r = bracketEnding.parse(t))) {\n          result = new ParseNode('bracket', [result].concat(r));\n        } else if ((r = callArgs.parse(t))) {\n          if (news.length)\n            result = new ParseNode('newcall', [news.pop(), result].concat(r));\n          else\n            result = new ParseNode('call', [result].concat(r));\n        } else {\n          done = true;\n        }\n      }\n\n      // There may be more `new` keywords than calls, which is how\n      // paren-less constructions (`new Date`) are parsed.  We've\n      // already handled `new foo().bar()`, now handle `new new foo().bar`.\n      while (news.length)\n        result = new ParseNode('new', [news.pop(), result]);\n\n      return result;\n    });\n\n  var postfixToken = token('++ --');\n  var postfixLookahead = lookAheadToken('++ --');\n  var postfixExpression = expecting(\n    'expression',\n    mapResult(seq(lhsExpression,\n                  opt(and(noLineTerminatorHere,\n                          postfixLookahead,\n                          postfixToken))),\n              function (v) {\n                if (v.length === 1)\n                  return v[0];\n                return new ParseNode('postfix', v);\n              }));\n\n  var unaryExpression = Parsers.unary(\n    'unary', postfixExpression,\n    or(token('delete void typeof'),\n       preSlashToken('++ -- + - ~ !', false)));\n\n  // The \"noIn\" business is all to facilitate parsing\n  // of for-in constructs, though the cases that make\n  // this required are quite obscure.\n  // The `for(var x in y)` form is allowed to take\n  // an initializer for `x` (which is only useful for\n  // its side effects, or if `y` has no properties).\n  // So an example might be:\n  // `for(var x = a().b in c);`\n  // In this example, `var x = a().b` is parsed without\n  // the `in`, which would otherwise be part of the\n  // varDecl, using varDeclNoIn.\n\n  // Our binaryExpression is the spec's LogicalORExpression,\n  // which includes all the higher-precendence operators.\n  var binaryExpressionMaybeNoIn = booleanFlaggedParser(\n    function (noIn) {\n      // high to low precedence\n      var binaryOps = [token('* / %'),\n                       token('+ -'),\n                       token('<< >> >>>'),\n                       or(token('< > <= >='),\n                          noIn ? token('instanceof') :\n                          token('instanceof in')),\n                       token('== != === !=='),\n                       token('&'),\n                       token('^'),\n                       token('|'),\n                       token('&&'),\n                       token('||')];\n      return expecting(\n        'expression',\n        Parsers.binaryLeft('binary', unaryExpression, binaryOps));\n    });\n  var binaryExpression = binaryExpressionMaybeNoIn[false];\n\n  var conditionalExpressionMaybeNoIn = booleanFlaggedParser(\n    function (noIn) {\n      return expecting(\n        'expression',\n        mapResult(\n          seq(binaryExpressionMaybeNoIn[noIn],\n              opt(seq(\n                token('?'),\n                assignmentExpression, token(':'),\n                assignmentExpressionMaybeNoIn[noIn]))),\n          function (v) {\n            if (v.length === 1)\n              return v[0];\n            return new ParseNode('ternary', v);\n          }));\n    });\n  var conditionalExpression = conditionalExpressionMaybeNoIn[false];\n\n  var assignOp = token('= *= /= %= += -= <<= >>= >>>= &= ^= |=');\n\n  assignmentExpressionMaybeNoIn = booleanFlaggedParser(\n    function (noIn) {\n      return new Parser(\n        'expression',\n        function (t) {\n          var r = conditionalExpressionMaybeNoIn[noIn].parse(t);\n          if (! r)\n            return null;\n\n          // Assignment is right-associative.\n          // Plan of attack: make a list of all the parts\n          // [expression, op, expression, op, ... expression]\n          // and then fold them up at the end.\n          var parts = [r];\n          var op;\n          while (isExpressionLHS(r) &&(op = assignOp.parse(t)))\n            parts.push(op,\n                       conditionalExpressionMaybeNoIn[noIn].parseRequired(t));\n\n          var result = parts.pop();\n          while (parts.length) {\n            op = parts.pop();\n            var lhs = parts.pop();\n            result = new ParseNode('assignment', [lhs, op, result]);\n          }\n          return result;\n        });\n    });\n  assignmentExpression = assignmentExpressionMaybeNoIn[false];\n\n  expressionMaybeNoIn = booleanFlaggedParser(\n    function (noIn) {\n      return expecting(\n        'expression',\n        mapResult(\n          list(assignmentExpressionMaybeNoIn[noIn], token(',')),\n          function (v) {\n            if (v.length === 1)\n              return v[0];\n            return new ParseNode('comma', v);\n          }));\n    });\n  expression = expressionMaybeNoIn[false];\n\n  // STATEMENTS\n\n  var comment = node('comment', new Parser(null, function (t) {\n    if (! t.includeComments)\n      return null;\n\n    // Match a COMMENT lexeme between oldToken and newToken.\n    //\n    // This is an unusual Parser because it doesn't match and consume\n    // newToken, but instead uses the next()/prev() API on lexemes.\n    // It assumes it can walk the linked list backwards from newToken\n    // (though not necessarily forwards).\n    //\n    // We start at the last comment we've visited for this\n    // oldToken/newToken pair, if any, or else oldToken, or else the\n    // beginning of the token stream.  We ignore comments that are\n    // preceded by any non-comment source code on the same line.\n    var lexeme = (t.lastCommentConsumed || t.oldToken || null);\n    if (! lexeme) {\n      // no oldToken, must be on first token.  walk backwards\n      // to start with first lexeme (which may be a comment\n      // or whitespace)\n      lexeme = t.newToken;\n      while (lexeme.prev())\n        lexeme = lexeme.prev();\n    } else {\n      // start with lexeme after last token or comment consumed\n      lexeme = lexeme.next();\n    }\n    var seenNewline = ((! t.oldToken) || t.lastCommentConsumed || false);\n    while (lexeme !== t.newToken) {\n      var type = lexeme.type();\n      if (type === \"NEWLINE\") {\n        seenNewline = true;\n      } else if (type === \"COMMENT\") {\n        t.lastCommentConsumed = lexeme;\n        if (seenNewline)\n          return lexeme;\n      }\n      lexeme = lexeme.next();\n    }\n    return null;\n  }));\n\n  var statements = list(or(comment, statement));\n\n  // implements JavaScript's semicolon \"insertion\" rules\n  var maybeSemicolon = expecting(\n    'semicolon',\n    or(token(';'),\n       and(\n         or(\n           lookAheadToken('}'),\n           lookAheadTokenType('EOF'),\n           assertion(function (t) {\n             return t.isLineTerminatorHere;\n           })),\n         constant(new ParseNode(';', [])))));\n\n  var expressionStatement = node(\n    'expressionStmnt',\n    and(\n      not(or(lookAheadToken('{'), lookAheadToken('function'))),\n      seq(expression,\n          expecting('semicolon',\n                    or(maybeSemicolon,\n                       // allow presence of colon to terminate\n                       // statement legally, for the benefit of\n                       // expressionOrLabelStatement.  Basically assume\n                       // an implicit semicolon.  This\n                       // is safe because a colon can never legally\n                       // follow a semicolon anyway.\n                       and(lookAheadToken(':'),\n                           constant(new ParseNode(';', []))))))));\n\n  // it's hard to parse statement labels, as in\n  // `foo: x = 1`, because we can't tell from the\n  // first token whether we are looking at an expression\n  // statement or a label statement.  To work around this,\n  // expressionOrLabelStatement parses the expression and\n  // then rewrites the result if it is an identifier\n  // followed by a colon.\n  var labelColonAndStatement = seq(token(':'), statement);\n  var noColon = expecting(\n    'semicolon', not(lookAheadToken(':')));\n  var expressionOrLabelStatement = new Parser(\n    null,\n    function (t) {\n      var exprStmnt = expressionStatement.parse(t);\n      if (! exprStmnt)\n        return null;\n\n      var expr = exprStmnt.children[0];\n      var maybeSemi = exprStmnt.children[1];\n      if (expr.name !== 'identifier' ||\n          ! (maybeSemi instanceof ParseNode)) {\n        // We either have a non-identifier expression or a present\n        // semicolon.  This is not a label.\n        //\n        // Fail now if we are looking at a colon, causing an\n        // error message on input like `1+1:` of the same kind\n        // you'd get without statement label parsing.\n        noColon.parseRequired(t);\n        return exprStmnt;\n      }\n\n      var rest = labelColonAndStatement.parse(t);\n      if (! rest)\n        return exprStmnt;\n\n      return new ParseNode('labelStmnt',\n                           [expr.children[0]].concat(rest));\n    });\n\n  var emptyStatement = node('emptyStmnt', token(';')); // required semicolon\n\n  var blockStatement = expecting('block', node('blockStmnt', seq(\n    token('{'), or(lookAheadToken('}'), statements),\n    token('}'))));\n\n  var varDeclMaybeNoIn = booleanFlaggedParser(function (noIn) {\n    return node(\n      'varDecl',\n      seq(tokenType('IDENTIFIER'),\n          opt(seq(token('='),\n                  assignmentExpressionMaybeNoIn[noIn]))));\n  });\n  var varDecl = varDeclMaybeNoIn[false];\n\n  var variableStatement = node(\n    'varStmnt',\n    seq(token('var'), list(varDecl, token(',')),\n        maybeSemicolon));\n\n  // A paren that may be followed by a statement\n  // beginning with a regex literal.\n  var closeParenBeforeStatement = preSlashToken(')', false);\n\n  var ifStatement = node(\n    'ifStmnt',\n    seq(token('if'), token('('), expression,\n        closeParenBeforeStatement, statement,\n        opt(seq(token('else'), statement))));\n\n  var secondThirdClauses = expecting(\n    'semicolon',\n    and(lookAheadToken(';'),\n        seq(\n          expecting('semicolon', token(';')),\n          or(and(lookAheadToken(';'),\n                 constant(NIL)),\n             expression),\n          expecting('semicolon', token(';')),\n          or(and(lookAheadToken(')'),\n                 constant(NIL)),\n             expression))));\n  var inExpr = seq(token('in'), expression);\n  var inExprExpectingSemi = expecting('semicolon',\n                                      seq(token('in'), expression));\n  var forSpec = mapResult(node(\n    'forSpec',\n    or(seq(token('var'),\n           varDeclMaybeNoIn[true],\n           expecting(\n             'commaOrIn',\n             or(inExpr,\n                seq(\n                  or(\n                    lookAheadToken(';'),\n                    seq(token(','),\n                        list(varDeclMaybeNoIn[true], token(',')))),\n                  secondThirdClauses)))),\n       // get the case where the first clause is empty out of the way.\n       // the lookAhead's return value is the empty placeholder for the\n       // missing expression.\n       seq(and(lookAheadToken(';'),\n               constant(NIL)), secondThirdClauses),\n       // custom parser the non-var case because we have to\n       // read the first expression before we know if there's\n       // an \"in\".\n       new Parser(\n         null,\n         function (t) {\n           var firstExpr = expressionMaybeNoIn[true].parse(t);\n           if (! firstExpr)\n             return null;\n           var rest = secondThirdClauses.parse(t);\n           if (! rest) {\n             // we need a left-hand-side expression for a\n             // `for (x in y)` loop.\n             if (! isExpressionLHS(firstExpr))\n               throw t.getParseError(\"semicolon\");\n             // if we don't see 'in' at this point, it's probably\n             // a missing semicolon\n             rest = inExprExpectingSemi.parseRequired(t);\n           }\n\n           return [firstExpr].concat(rest);\n         }))),\n                          function (clauses) {\n                            // There are four kinds of for-loop, and we call the\n                            // part between the parens one of forSpec, forVarSpec,\n                            // forInSpec, and forVarInSpec.  Having parsed it\n                            // already, we rewrite the node name based on how\n                            // many items came out.  forIn and forVarIn always\n                            // have 3 and 4 items respectively.  for has 5\n                            // (the optional expressions are present as nils).\n                            // forVar has 6 or more, because `for(var x;;);`\n                            // produces [`var` `x` `;` nil `;` nil].\n                            var numChildren = clauses.children.length;\n                            if (numChildren === 3)\n                              return new ParseNode('forInSpec', clauses.children);\n                            else if (numChildren === 4)\n                              return new ParseNode('forVarInSpec', clauses.children);\n                            else if (numChildren >= 6)\n                              return new ParseNode('forVarSpec', clauses.children);\n                            return clauses;\n                          });\n\n  var iterationStatement = or(\n    node('doStmnt', seq(token('do'), statement, token('while'),\n                        token('('), expression, token(')'),\n                        maybeSemicolon)),\n    node('whileStmnt', seq(token('while'), token('('), expression,\n                           closeParenBeforeStatement, statement)),\n    // semicolons must be real, not maybeSemicolons\n    node('forStmnt', seq(\n      token('for'), token('('), forSpec, closeParenBeforeStatement,\n      statement)));\n\n  var returnStatement = node(\n    'returnStmnt',\n    seq(token('return'), or(\n      and(noLineTerminatorHere, expression), constant(NIL)),\n        maybeSemicolon));\n  var continueStatement = node(\n    'continueStmnt',\n    seq(token('continue'), or(\n      and(noLineTerminatorHere, tokenType('IDENTIFIER')), constant(NIL)),\n        maybeSemicolon));\n  var breakStatement = node(\n    'breakStmnt',\n    seq(token('break'), or(\n      and(noLineTerminatorHere, tokenType('IDENTIFIER')), constant(NIL)),\n        maybeSemicolon));\n  var throwStatement = node(\n    'throwStmnt',\n    seq(token('throw'),\n        and(or(noLineTerminatorHere,\n               // If there is a line break here and more tokens after,\n               // we want to error appropriately.  `throw \\n e` should\n               // complain about the \"end of line\", not the `e`.\n               and(not(lookAheadTokenType(\"EOF\")),\n                   new Parser(null,\n                              function (t) {\n                                throw t.getParseError('expression', 'end of line');\n                              }))),\n            expression),\n        maybeSemicolon));\n\n  var withStatement = node(\n    'withStmnt',\n    seq(token('with'), token('('), expression, closeParenBeforeStatement,\n        statement));\n\n  var switchCase = node(\n    'case',\n    seq(token('case'), expression, token(':'),\n        or(lookAheadToken('}'),\n           lookAheadToken('case default'),\n           statements)));\n  var switchDefault = node(\n    'default',\n    seq(token('default'), token(':'),\n        or(lookAheadToken('}'),\n           lookAheadToken('case'),\n           statements)));\n\n  var switchStatement = node(\n    'switchStmnt',\n    seq(token('switch'), token('('), expression, token(')'),\n        token('{'),\n        or(lookAheadToken('}'),\n           lookAheadToken('default'),\n           list(switchCase)),\n        opt(seq(switchDefault,\n                opt(list(switchCase)))),\n        token('}')));\n\n  var catchFinally = expecting(\n    'catch',\n    and(lookAheadToken('catch finally'),\n        seq(\n          or(node(\n            'catch',\n            seq(token('catch'), token('('), tokenType('IDENTIFIER'),\n                token(')'), blockStatement)),\n             constant(NIL)),\n          or(node(\n            'finally',\n            seq(token('finally'), blockStatement)),\n             constant(NIL)))));\n  var tryStatement = node(\n    'tryStmnt',\n    seq(token('try'), blockStatement, catchFinally));\n  var debuggerStatement = node(\n    'debuggerStmnt', seq(token('debugger'), maybeSemicolon));\n\n  statement = expecting('statement',\n                        or(expressionOrLabelStatement,\n                           emptyStatement,\n                           blockStatement,\n                           variableStatement,\n                           ifStatement,\n                           iterationStatement,\n                           returnStatement,\n                           continueStatement,\n                           breakStatement,\n                           withStatement,\n                           switchStatement,\n                           throwStatement,\n                           tryStatement,\n                           debuggerStatement));\n\n  // PROGRAM\n\n  var functionDecl = node(\n    'functionDecl', functionMaybeNameRequired[true]);\n\n  // Look for statement before functionDecl, to catch comments in\n  // includeComments mode.  A statement can't start with 'function'\n  // anyway, so the order doesn't matter otherwise.\n  var sourceElement = or(statement, functionDecl);\n  var sourceElements = list(or(comment, sourceElement));\n\n  functionBody = expecting(\n    'functionBody', or(lookAheadToken('}'), sourceElements));\n\n  var program = node(\n    'program',\n    seq(opt(sourceElements),\n        // If not at EOF, complain \"expecting statement\"\n        expecting('statement', lookAheadTokenType(\"EOF\"))));\n\n  return program.parse(this);\n};\n"]}