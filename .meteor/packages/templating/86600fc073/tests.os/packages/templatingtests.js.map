{"version":3,"file":"/packages/templating:tests.js","sources":["templating/plugin/html_scanner.js","templating/scanner_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,gB;AACA,4D;AACA,qC;AACA,I;AACA,wD;AACA,0D;AACA,yC;;AAEA,yC;AACA,2B;AACA,I;;AAEA,0C;AACA,wB;AACA,kB;;AAEA,oC;AACA,oC;AACA,sB;AACA,M;;AAEA,+D;AACA,iC;AACA,mC;;AAEA,4C;AACA,6D;AACA,6B;AACA,gF;AACA,gB;AACA,M;;AAEA,8C;;AAEA,4E;;AAEA,kB;AACA,wD;AACA,4C;;AAEA,sC;AACA,kB;AACA,sD;;AAEA,gC;AACA,wC;AACA,uC;AACA,2C;;AAEA,gC;AACA,6C;;AAEA,uB;AACA,yC;AACA,yC;AACA,iC;AACA,6C;AACA,yB;AACA,mD;AACA,yD;AACA,iB;AACA,O;AACA,kC;AACA,sD;AACA,yB;AACA,0B;AACA,8E;AACA,mB;AACA,0B;AACA,uE;AACA,S;AACA,0B;AACA,O;;AAEA,2B;AACA,oD;AACA,qD;AACA,yE;AACA,e;AACA,wB;AACA,4C;AACA,gC;AACA,8B;AACA,gC;AACA,6C;AACA,8B;AACA,gB;AACA,yD;AACA,6D;AACA,0D;AACA,qC;AACA,qE;AACA,wC;AACA,O;AACA,sC;AACA,8C;AACA,oB;AACA,mE;AACA,gB;AACA,kD;AACA,iD;AACA,qC;AACA,yC;;AAEA,uB;AACA,wE;AACA,kE;AACA,6C;AACA,K;;AAEA,mB;AACA,I;;AAEA,4B;AACA,qB;AACA,sB;AACA,sB;AACA,oB;AACA,mB;AACA,I;;AAEA,yE;AACA,4D;;AAEA,6B;AACA,mE;AACA,iE;AACA,sC;AACA,oB;;AAEA,oC;AACA,2B;AACA,2B;AACA,sC;AACA,0B;AACA,c;AACA,O;AACA,K;;AAEA,yB;AACA,qB;AACA,8D;AACA,+B;AACA,a;AACA,K;;;AAGA,2B;AACA,S;AACA,iD;AACA,iB;AACA,+C;AACA,wC;AACA,oE;AACA,4D;AACA,qE;AACA,Y;AACA,gE;AACA,kE;AACA,4E;AACA,O;AACA,U;AACA,gB;AACA,K;AACA,kE;AACA,oC;;AAEA,6B;AACA,8B;AACA,iB;AACA,4D;;AAEA,uE;AACA,wB;AACA,Y;AACA,e;AACA,qB;AACA,8D;AACA,kD;AACA,mD;AACA,uD;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACvLA,2D;AACA,0D;AACA,+C;AACA,gB;AACA,Q;AACA,2D;AACA,kD;AACA,I;;AAEA,kD;AACA,S;AACA,U;AACA,iB;AACA,6B;AACA,kB;AACA,U;AACA,0E;AACA,0B;AACA,uC;AACA,a;AACA,K;AACA,oD;AACA,I;;AAEA,oD;AACA,mD;AACA,oC;AACA,iC;AACA,iD;AACA,kC;;AAEA,8D;AACA,iC;AACA,2C;AACA,+C;AACA,I;;AAEA,yB;AACA,qC;AACA,uC;;AAEA,yB;AACA,e;AACA,4C;AACA,8F;;AAEA,sC;AACA,e;AACA,gE;AACA,8F;;AAEA,qD;AACA,e;AACA,uD;AACA,qE;AACA,8F;;AAEA,kB;AACA,e;AACA,yF;AACA,6F;AACA,4B;;AAEA,sC;AACA,e;AACA,iG;AACA,6F;AACA,4B;;AAEA,6B;AACA,e;AACA,wF;AACA,gF;AACA,6F;AACA,mG;AACA,yB;AACA,4B;;AAEA,sB;AACA,e;AACA,wE;AACA,iG;AACA,0B;;AAEA,mC;AACA,e;AACA,2E;AACA,0C;AACA,iG;AACA,0B;;AAEA,0D;AACA,e;AACA,kF;AACA,8C;AACA,iG;AACA,0B;;AAEA,oC;AACA,e;AACA,2E;AACA,iG;AACA,0B;;AAEA,uC;AACA,e;AACA,gE;AACA,0C;AACA,mD;AACA,kE;AACA,0B;;AAEA,yE;AACA,+B;;AAEA,wC;AACA,yB;AACA,4D;AACA,gB;;AAEA,iB;AACA,yB;AACA,gE;AACA,uC;AACA,yB;AACA,sE;AACA,wB;;AAEA,iB;AACA,yB;AACA,8C;AACA,mB;;AAEA,qB;AACA,yB;AACA,6B;AACA,gE;AACA,gB;;AAEA,4B;AACA,yB;AACA,6B;AACA,2D;AACA,mD;AACA,+B;AACA,mB;;AAEA,4B;AACA,yB;AACA,6B;AACA,yB;AACA,mB;;AAEA,qC;AACA,yB;AACA,mE;AACA,kB;;AAEA,qC;AACA,yB;AACA,mE;AACA,kB;;AAEA,0B;AACA,yB;AACA,sD;AACA,iD;AACA,wB;;AAEA,G","sourcesContent":["html_scanner = {\n  // Scan a template file for <head>, <body>, and <template>\n  // tags and extract their contents.\n  //\n  // This is a primitive, regex-based scanner.  It scans\n  // top-level tags, which are allowed to have attributes,\n  // and ignores top-level HTML comments.\n\n  // Has fields 'message', 'line', 'file'\n  ParseError: function () {\n  },\n\n  scan: function (contents, source_name) {\n    var rest = contents;\n    var index = 0;\n\n    var advance = function(amount) {\n      rest = rest.substring(amount);\n      index += amount;\n    };\n\n    var throwParseError = function (msg, atIndex, lineOffset) {\n      atIndex = atIndex || index;\n      lineOffset = lineOffset || 0;\n\n      var ret = new html_scanner.ParseError;\n      ret.message = msg || \"bad formatting in HTML template\";\n      ret.file = source_name;\n      ret.line = contents.substring(0, atIndex).split('\\n').length + lineOffset;\n      throw ret;\n    };\n\n    var results = html_scanner._initResults();\n\n    var rOpenTag = /^((<(template|head|body)\\b)|(<!--)|(<!DOCTYPE|{{!)|$)/i;\n\n    while (rest) {\n      // skip whitespace first (for better line numbers)\n      advance(rest.match(/^\\s*/)[0].length);\n\n      var match = rOpenTag.exec(rest);\n      if (! match)\n        throwParseError(); // unknown text encountered\n\n      var matchToken = match[1];\n      var matchTokenTagName =  match[3];\n      var matchTokenComment = match[4];\n      var matchTokenUnsupported = match[5];\n\n      var tagStartIndex = index;\n      advance(match.index + match[0].length);\n\n      if (! matchToken)\n        break; // matched $ (end of file)\n      if (matchTokenComment === '<!--') {\n        // top-level HTML comment\n        var commentEnd = /--\\s*>/.exec(rest);\n        if (! commentEnd)\n          throwParseError(\"unclosed HTML comment\");\n        advance(commentEnd.index + commentEnd[0].length);\n        continue;\n      }\n      if (matchTokenUnsupported) {\n        switch (matchTokenUnsupported.toLowerCase()) {\n        case '<!doctype':\n          throwParseError(\n            \"Can't set DOCTYPE here.  (Meteor sets <!DOCTYPE html> for you)\");\n        case '{{!':\n          throwParseError(\n            \"Can't use '{{! }}' outside a template.  Use '<!-- -->'.\");\n        }\n        throwParseError();\n      }\n\n      // otherwise, a <tag>\n      var tagName = matchTokenTagName.toLowerCase();\n      var tagAttribs = {}; // bare name -> value dict\n      var rTagPart = /^\\s*((([a-zA-Z0-9:_-]+)\\s*=\\s*([\"'])(.*?)\\4)|(>))/;\n      var attr;\n      // read attributes\n      while ((attr = rTagPart.exec(rest))) {\n        var attrToken = attr[1];\n        var attrKey = attr[3];\n        var attrValue = attr[5];\n        advance(attr.index + attr[0].length);\n        if (attrToken === '>')\n          break;\n        // XXX we don't HTML unescape the attribute value\n        // (e.g. to allow \"abcd&quot;efg\") or protect against\n        // collisions with methods of tagAttribs (e.g. for\n        // a property named toString)\n        attrValue = attrValue.match(/^\\s*([\\s\\S]*?)\\s*$/)[1]; // trim\n        tagAttribs[attrKey] = attrValue;\n      }\n      if (! attr) // didn't end on '>'\n        throwParseError(\"Parse error in tag\");\n      // find </tag>\n      var end = (new RegExp('</'+tagName+'\\\\s*>', 'i')).exec(rest);\n      if (! end)\n        throwParseError(\"unclosed <\"+tagName+\">\");\n      var tagContents = rest.slice(0, end.index);\n      var contentsStartIndex = index;\n      advance(end.index + end[0].length);\n\n      // act on the tag\n      html_scanner._handleTag(results, tagName, tagAttribs, tagContents,\n                              throwParseError, contentsStartIndex,\n                              tagStartIndex);\n    }\n\n    return results;\n  },\n\n  _initResults: function() {\n    var results = {};\n    results.head = '';\n    results.body = '';\n    results.js = '';\n    return results;\n  },\n\n  _handleTag: function (results, tag, attribs, contents, throwParseError,\n                        contentsStartIndex, tagStartIndex) {\n\n    // trim the tag contents.\n    // this is a courtesy and is also relied on by some unit tests.\n    var m = contents.match(/^([ \\t\\r\\n]*)([\\s\\S]*?)[ \\t\\r\\n]*$/);\n    contentsStartIndex += m[1].length;\n    contents = m[2];\n\n    // do we have 1 or more attribs?\n    var hasAttribs = false;\n    for(var k in attribs) {\n      if (attribs.hasOwnProperty(k)) {\n        hasAttribs = true;\n        break;\n      }\n    }\n\n    if (tag === \"head\") {\n      if (hasAttribs)\n        throwParseError(\"Attributes on <head> not supported\");\n      results.head += contents;\n      return;\n    }\n\n\n    // <body> or <template>\n    try {\n      var ast = Handlebars.to_json_ast(contents);\n    } catch (e) {\n      if (e instanceof Handlebars.ParseError) {\n        if (typeof(e.line) === \"number\")\n          // subtract one from e.line because it is one-based but we\n          // need it to be an offset from contentsStartIndex\n          throwParseError(e.message, contentsStartIndex, e.line - 1);\n        else\n          // No line number available from Handlebars parser, so\n          // generate the parse error at the <template> tag itself\n          throwParseError(\"error in template: \" + e.message, tagStartIndex);\n      }\n      else\n        throw e;\n    }\n    var code = 'Package.handlebars.Handlebars.json_ast_to_func(' +\n          JSON.stringify(ast) + ')';\n\n    if (tag === \"template\") {\n      var name = attribs.name;\n      if (! name)\n        throwParseError(\"Template has no 'name' attribute\");\n\n      results.js += \"Template.__define__(\" + JSON.stringify(name) + \",\"\n        + code + \");\\n\";\n    } else {\n      // <body>\n      if (hasAttribs)\n        throwParseError(\"Attributes on <body> not supported\");\n      results.js += \"Meteor.startup(function(){\" +\n        \"document.body.appendChild(Spark.render(\" +\n        \"Template.__define__(null,\" + code + \")));});\";\n    }\n  }\n};\n","Tinytest.add(\"templating - html scanner\", function (test) {\n  var testInString = function(actualStr, wantedContents) {\n    if (actualStr.indexOf(wantedContents) >= 0)\n      test.ok();\n    else\n      test.fail(\"Expected \"+JSON.stringify(wantedContents)+\n                \" in \"+JSON.stringify(actualStr));\n  };\n\n  var checkError = function(f, msgText, lineNum) {\n    try {\n      f();\n    } catch (e) {\n      if (e.line === lineNum)\n        test.ok();\n      else\n        test.fail(\"Error should have been on line \" + lineNum + \", not \" +\n                  e.line);\n      testInString(e.message, msgText);\n      return;\n    }\n    test.fail(\"Parse error didn't throw exception\");\n  };\n\n  var BODY_PREAMBLE = \"Meteor.startup(function(){\" +\n        \"document.body.appendChild(Spark.render(\" +\n        \"Template.__define__(null,\";\n  var BODY_POSTAMBLE = \")));});\";\n  var TEMPLATE_PREAMBLE = \"Template.__define__(\";\n  var TEMPLATE_POSTAMBLE = \");\\n\";\n\n  var checkResults = function(results, expectJs, expectHead) {\n    test.equal(results.body, '');\n    test.equal(results.js, expectJs || '');\n    test.equal(results.head, expectHead || '');\n  };\n\n  checkError(function() {\n    return html_scanner.scan(\"asdf\");\n  }, \"formatting in HTML template\", 1);\n\n  // body all on one line\n  checkResults(\n    html_scanner.scan(\"<body>Hello</body>\"),\n    BODY_PREAMBLE+'Package.handlebars.Handlebars.json_ast_to_func([\"Hello\"])'+BODY_POSTAMBLE);\n\n  // multi-line body, contents trimmed\n  checkResults(\n    html_scanner.scan(\"\\n\\n\\n<body>\\n\\nHello\\n\\n</body>\\n\\n\\n\"),\n    BODY_PREAMBLE+'Package.handlebars.Handlebars.json_ast_to_func([\"Hello\"])'+BODY_POSTAMBLE);\n\n  // same as previous, but with various HTML comments\n  checkResults(\n    html_scanner.scan(\"\\n<!--\\n\\nfoo\\n-->\\n<!-- -->\\n\"+\n                      \"<body>\\n\\nHello\\n\\n</body>\\n\\n<!----\\n>\\n\\n\"),\n    BODY_PREAMBLE+'Package.handlebars.Handlebars.json_ast_to_func([\"Hello\"])'+BODY_POSTAMBLE);\n\n  // head and body\n  checkResults(\n    html_scanner.scan(\"<head>\\n<title>Hello</title>\\n</head>\\n\\n<body>World</body>\\n\\n\"),\n    BODY_PREAMBLE+'Package.handlebars.Handlebars.json_ast_to_func([\"World\"])'+BODY_POSTAMBLE,\n    \"<title>Hello</title>\");\n\n  // head and body with tag whitespace\n  checkResults(\n    html_scanner.scan(\"<head\\n>\\n<title>Hello</title>\\n</head  >\\n\\n<body>World</body\\n\\n>\\n\\n\"),\n    BODY_PREAMBLE+'Package.handlebars.Handlebars.json_ast_to_func([\"World\"])'+BODY_POSTAMBLE,\n    \"<title>Hello</title>\");\n\n  // head, body, and template\n  checkResults(\n    html_scanner.scan(\"<head>\\n<title>Hello</title>\\n</head>\\n\\n<body>World</body>\\n\\n\"+\n                      '<template name=\"favoritefood\">\\n  pizza\\n</template>\\n'),\n    BODY_PREAMBLE+'Package.handlebars.Handlebars.json_ast_to_func([\"World\"])'+BODY_POSTAMBLE+\n      TEMPLATE_PREAMBLE+'\"favoritefood\",Package.handlebars.Handlebars.json_ast_to_func([\"pizza\"])'+\n      TEMPLATE_POSTAMBLE,\n    \"<title>Hello</title>\");\n\n  // one-line template\n  checkResults(\n    html_scanner.scan('<template name=\"favoritefood\">pizza</template>'),\n    TEMPLATE_PREAMBLE+'\"favoritefood\",Package.handlebars.Handlebars.json_ast_to_func([\"pizza\"])'+\n      TEMPLATE_POSTAMBLE);\n\n  // template with other attributes\n  checkResults(\n    html_scanner.scan('<template foo=\"bar\" name=\"favoritefood\" baz=\"qux\">'+\n                      'pizza</template>'),\n    TEMPLATE_PREAMBLE+'\"favoritefood\",Package.handlebars.Handlebars.json_ast_to_func([\"pizza\"])'+\n      TEMPLATE_POSTAMBLE);\n\n  // whitespace around '=' in attributes and at end of tag\n  checkResults(\n    html_scanner.scan('<template foo = \"bar\" name  =\"favoritefood\" baz= \"qux\"  >'+\n                      'pizza</template\\n\\n>'),\n    TEMPLATE_PREAMBLE+'\"favoritefood\",Package.handlebars.Handlebars.json_ast_to_func([\"pizza\"])'+\n      TEMPLATE_POSTAMBLE);\n\n  // whitespace around template name\n  checkResults(\n    html_scanner.scan('<template name=\" favoritefood  \">pizza</template>'),\n    TEMPLATE_PREAMBLE+'\"favoritefood\",Package.handlebars.Handlebars.json_ast_to_func([\"pizza\"])'+\n      TEMPLATE_POSTAMBLE);\n\n  // single quotes around template name\n  checkResults(\n    html_scanner.scan('<template name=\\'the \"cool\" template\\'>'+\n                      'pizza</template>'),\n    TEMPLATE_PREAMBLE+'\"the \\\\\"cool\\\\\" template\",'+\n      'Package.handlebars.Handlebars.json_ast_to_func([\"pizza\"])'+\n      TEMPLATE_POSTAMBLE);\n\n  // error cases; exact line numbers are not critical, these just reflect\n  // the current implementation\n\n  // unclosed body (error mentions body)\n  checkError(function() {\n    return html_scanner.scan(\"\\n\\n<body>\\n  Hello\\n</body\");\n  }, \"body\", 3);\n\n  // bad open tag\n  checkError(function() {\n    return html_scanner.scan(\"\\n\\n\\n<bodyd>\\n  Hello\\n</body>\");\n  }, \"formatting in HTML template\", 4);\n  checkError(function() {\n    return html_scanner.scan(\"\\n\\n\\n\\n<body foo=>\\n  Hello\\n</body>\");\n  }, \"error in tag\", 5);\n\n  // unclosed tag\n  checkError(function() {\n    return html_scanner.scan(\"\\n<body>Hello\");\n  }, \"nclosed\", 2);\n\n  // unnamed template\n  checkError(function() {\n    return html_scanner.scan(\n      \"\\n\\n<template>Hi</template>\\n\\n<template>Hi</template>\");\n  }, \"name\", 3);\n\n  // helpful doctype message\n  checkError(function() {\n    return html_scanner.scan(\n      '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" '+\n        '\"http://www.w3.org/TR/html4/strict.dtd\">'+\n        '\\n\\n<head>\\n</head>');\n  }, \"DOCTYPE\", 1);\n\n  // lowercase basic doctype\n  checkError(function() {\n    return html_scanner.scan(\n      '<!doctype html>');\n  }, \"DOCTYPE\", 1);\n\n  // attributes on body not supported\n  checkError(function() {\n    return html_scanner.scan('<body foo=\"bar\">\\n  Hello\\n</body>');\n  }, \"<body>\", 3);\n\n  // attributes on head not supported\n  checkError(function() {\n    return html_scanner.scan('<head foo=\"bar\">\\n  Hello\\n</head>');\n  }, \"<head>\", 3);\n\n  // can't mismatch quotes\n  checkError(function() {\n    return html_scanner.scan('<template name=\"foo\\'>'+\n                             'pizza</template>');\n  }, \"error in tag\", 1);\n\n});\n"]}