{"version":3,"file":"/packages/compileTemplates:plugin.js","sources":["compileTemplates/plugin/html_scanner.js","compileTemplates/plugin/compile-templates.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,gB;AACA,4D;AACA,qC;AACA,I;AACA,wD;AACA,0D;AACA,yC;;AAEA,yC;AACA,2B;AACA,I;;AAEA,0C;AACA,wB;AACA,kB;;AAEA,oC;AACA,oC;AACA,sB;AACA,M;;AAEA,+D;AACA,iC;AACA,mC;;AAEA,4C;AACA,6D;AACA,6B;AACA,gF;AACA,gB;AACA,M;;AAEA,8C;;AAEA,4E;;AAEA,kB;AACA,wD;AACA,4C;;AAEA,sC;AACA,kB;AACA,sD;;AAEA,gC;AACA,wC;AACA,uC;AACA,2C;;AAEA,gC;AACA,6C;;AAEA,uB;AACA,yC;AACA,yC;AACA,iC;AACA,6C;AACA,yB;AACA,mD;AACA,yD;AACA,iB;AACA,O;AACA,kC;AACA,sD;AACA,yB;AACA,0B;AACA,8E;AACA,mB;AACA,0B;AACA,uE;AACA,S;AACA,0B;AACA,O;;AAEA,2B;AACA,oD;AACA,qD;AACA,yE;AACA,e;AACA,wB;AACA,4C;AACA,gC;AACA,8B;AACA,gC;AACA,6C;AACA,8B;AACA,gB;AACA,yD;AACA,6D;AACA,0D;AACA,qC;AACA,qE;AACA,wC;AACA,O;AACA,sC;AACA,8C;AACA,oB;AACA,mE;AACA,gB;AACA,kD;AACA,iD;AACA,qC;AACA,yC;;AAEA,uB;AACA,wE;AACA,kE;AACA,6C;AACA,K;;AAEA,mB;AACA,I;;AAEA,4B;AACA,qB;AACA,sB;AACA,sB;AACA,oB;AACA,mB;AACA,I;;AAEA,yE;AACA,4D;;AAEA,6B;AACA,mE;AACA,iE;AACA,sC;AACA,oB;;AAEA,oC;AACA,2B;AACA,2B;AACA,sC;AACA,0B;AACA,c;AACA,O;AACA,K;;AAEA,yB;AACA,qB;AACA,8D;AACA,+B;AACA,a;AACA,K;;;AAGA,2B;AACA,S;AACA,iD;AACA,iB;AACA,+C;AACA,wC;AACA,oE;AACA,4D;AACA,qE;AACA,Y;AACA,gE;AACA,kE;AACA,4E;AACA,O;AACA,U;AACA,gB;AACA,K;AACA,kE;AACA,oC;;AAEA,6B;AACA,8B;AACA,iB;AACA,4D;;AAEA,uE;AACA,wB;AACA,Y;AACA,e;AACA,qB;AACA,8D;AACA,kD;AACA,mD;AACA,uD;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACvLA,+B;;AAEA,6D;AACA,iD;AACA,iD;AACA,sE;AACA,oE;AACA,sE;AACA,oE;AACA,iB;AACA,W;;AAEA,oE;AACA,qB;AACA,qD;AACA,O;AACA,qE;AACA,e;AACA,+C;AACA,yB;AACA,2B;AACA,0C;AACA,oB;AACA,S;AACA,a;AACA,U;AACA,c;AACA,G;;AAEA,mB;AACA,wE;;AAEA,mB;AACA,wE;;AAEA,mB;AACA,wD;AACA,0B;AACA,qB;AACA,mD;AACA,uC;AACA,kD;AACA,6D;;AAEA,gC;;AAEA,+B;AACA,iE;AACA,wC;AACA,sB;AACA,O;AACA,G;AACA,G","sourcesContent":["html_scanner = {\n  // Scan a template file for <head>, <body>, and <template>\n  // tags and extract their contents.\n  //\n  // This is a primitive, regex-based scanner.  It scans\n  // top-level tags, which are allowed to have attributes,\n  // and ignores top-level HTML comments.\n\n  // Has fields 'message', 'line', 'file'\n  ParseError: function () {\n  },\n\n  scan: function (contents, source_name) {\n    var rest = contents;\n    var index = 0;\n\n    var advance = function(amount) {\n      rest = rest.substring(amount);\n      index += amount;\n    };\n\n    var throwParseError = function (msg, atIndex, lineOffset) {\n      atIndex = atIndex || index;\n      lineOffset = lineOffset || 0;\n\n      var ret = new html_scanner.ParseError;\n      ret.message = msg || \"bad formatting in HTML template\";\n      ret.file = source_name;\n      ret.line = contents.substring(0, atIndex).split('\\n').length + lineOffset;\n      throw ret;\n    };\n\n    var results = html_scanner._initResults();\n\n    var rOpenTag = /^((<(template|head|body)\\b)|(<!--)|(<!DOCTYPE|{{!)|$)/i;\n\n    while (rest) {\n      // skip whitespace first (for better line numbers)\n      advance(rest.match(/^\\s*/)[0].length);\n\n      var match = rOpenTag.exec(rest);\n      if (! match)\n        throwParseError(); // unknown text encountered\n\n      var matchToken = match[1];\n      var matchTokenTagName =  match[3];\n      var matchTokenComment = match[4];\n      var matchTokenUnsupported = match[5];\n\n      var tagStartIndex = index;\n      advance(match.index + match[0].length);\n\n      if (! matchToken)\n        break; // matched $ (end of file)\n      if (matchTokenComment === '<!--') {\n        // top-level HTML comment\n        var commentEnd = /--\\s*>/.exec(rest);\n        if (! commentEnd)\n          throwParseError(\"unclosed HTML comment\");\n        advance(commentEnd.index + commentEnd[0].length);\n        continue;\n      }\n      if (matchTokenUnsupported) {\n        switch (matchTokenUnsupported.toLowerCase()) {\n        case '<!doctype':\n          throwParseError(\n            \"Can't set DOCTYPE here.  (Meteor sets <!DOCTYPE html> for you)\");\n        case '{{!':\n          throwParseError(\n            \"Can't use '{{! }}' outside a template.  Use '<!-- -->'.\");\n        }\n        throwParseError();\n      }\n\n      // otherwise, a <tag>\n      var tagName = matchTokenTagName.toLowerCase();\n      var tagAttribs = {}; // bare name -> value dict\n      var rTagPart = /^\\s*((([a-zA-Z0-9:_-]+)\\s*=\\s*([\"'])(.*?)\\4)|(>))/;\n      var attr;\n      // read attributes\n      while ((attr = rTagPart.exec(rest))) {\n        var attrToken = attr[1];\n        var attrKey = attr[3];\n        var attrValue = attr[5];\n        advance(attr.index + attr[0].length);\n        if (attrToken === '>')\n          break;\n        // XXX we don't HTML unescape the attribute value\n        // (e.g. to allow \"abcd&quot;efg\") or protect against\n        // collisions with methods of tagAttribs (e.g. for\n        // a property named toString)\n        attrValue = attrValue.match(/^\\s*([\\s\\S]*?)\\s*$/)[1]; // trim\n        tagAttribs[attrKey] = attrValue;\n      }\n      if (! attr) // didn't end on '>'\n        throwParseError(\"Parse error in tag\");\n      // find </tag>\n      var end = (new RegExp('</'+tagName+'\\\\s*>', 'i')).exec(rest);\n      if (! end)\n        throwParseError(\"unclosed <\"+tagName+\">\");\n      var tagContents = rest.slice(0, end.index);\n      var contentsStartIndex = index;\n      advance(end.index + end[0].length);\n\n      // act on the tag\n      html_scanner._handleTag(results, tagName, tagAttribs, tagContents,\n                              throwParseError, contentsStartIndex,\n                              tagStartIndex);\n    }\n\n    return results;\n  },\n\n  _initResults: function() {\n    var results = {};\n    results.head = '';\n    results.body = '';\n    results.js = '';\n    return results;\n  },\n\n  _handleTag: function (results, tag, attribs, contents, throwParseError,\n                        contentsStartIndex, tagStartIndex) {\n\n    // trim the tag contents.\n    // this is a courtesy and is also relied on by some unit tests.\n    var m = contents.match(/^([ \\t\\r\\n]*)([\\s\\S]*?)[ \\t\\r\\n]*$/);\n    contentsStartIndex += m[1].length;\n    contents = m[2];\n\n    // do we have 1 or more attribs?\n    var hasAttribs = false;\n    for(var k in attribs) {\n      if (attribs.hasOwnProperty(k)) {\n        hasAttribs = true;\n        break;\n      }\n    }\n\n    if (tag === \"head\") {\n      if (hasAttribs)\n        throwParseError(\"Attributes on <head> not supported\");\n      results.head += contents;\n      return;\n    }\n\n\n    // <body> or <template>\n    try {\n      var ast = Handlebars.to_json_ast(contents);\n    } catch (e) {\n      if (e instanceof Handlebars.ParseError) {\n        if (typeof(e.line) === \"number\")\n          // subtract one from e.line because it is one-based but we\n          // need it to be an offset from contentsStartIndex\n          throwParseError(e.message, contentsStartIndex, e.line - 1);\n        else\n          // No line number available from Handlebars parser, so\n          // generate the parse error at the <template> tag itself\n          throwParseError(\"error in template: \" + e.message, tagStartIndex);\n      }\n      else\n        throw e;\n    }\n    var code = 'Package.handlebars.Handlebars.json_ast_to_func(' +\n          JSON.stringify(ast) + ')';\n\n    if (tag === \"template\") {\n      var name = attribs.name;\n      if (! name)\n        throwParseError(\"Template has no 'name' attribute\");\n\n      results.js += \"Template.__define__(\" + JSON.stringify(name) + \",\"\n        + code + \");\\n\";\n    } else {\n      // <body>\n      if (hasAttribs)\n        throwParseError(\"Attributes on <body> not supported\");\n      results.js += \"Meteor.startup(function(){\" +\n        \"document.body.appendChild(Spark.render(\" +\n        \"Template.__define__(null,\" + code + \")));});\";\n    }\n  }\n};\n","var path = Npm.require('path');\n\nPlugin.registerSourceHandler(\"html\", function (compileStep) {\n  // XXX use archinfo rather than rolling our own\n  if (! compileStep.arch.match(/^browser(\\.|$)/))\n    // XXX might be nice to throw an error here, but then we'd have to\n    // make it so that packages.js ignores html files that appear in\n    // the server directories in an app tree.. or, it might be nice to\n    // make html files actually work on the server (against jsdom or\n    // something)\n    return;\n\n  // XXX the way we deal with encodings here is sloppy .. should get\n  // religion on that\n  var contents = compileStep.read().toString('utf8');\n  try {\n    var results = html_scanner.scan(contents, compileStep.inputPath);\n  } catch (e) {\n    if (e instanceof html_scanner.ParseError) {\n      compileStep.error({\n        message: e.message,\n        sourcePath: compileStep.inputPath,\n        line: e.line\n      });\n      return;\n    } else\n      throw e;\n  }\n\n  if (results.head)\n    compileStep.appendDocument({ section: \"head\", data: results.head });\n\n  if (results.body)\n    compileStep.appendDocument({ section: \"body\", data: results.body });\n\n  if (results.js) {\n    var path_part = path.dirname(compileStep.inputPath);\n    if (path_part === '.')\n      path_part = '';\n    if (path_part.length && path_part !== path.sep)\n      path_part = path_part + path.sep;\n    var ext = path.extname(compileStep.inputPath);\n    var basename = path.basename(compileStep.inputPath, ext);\n\n    // XXX generate a source map\n\n    compileStep.addJavaScript({\n      path: path.join(path_part, \"template.\" + basename + \".js\"),\n      sourcePath: compileStep.inputPath,\n      data: results.js\n    });\n  }\n});\n"]}