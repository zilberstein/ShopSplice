{"version":3,"file":"/packages/jquery-waypoints.js","sources":["jquery-waypoints/waypoints.js"],"names":[],"mappings":";;;;;;;;AAAA,I;AACA,0B;AACA,wC;AACA,qD;AACA,+E;AACA,+E;AACA,G;AACA,C;AACA,G;AACA,4E;AACA,mC;AACA,C;AACA,sE;AACA,8E;AACA,C;AACA,W;AACA,Q;AACA,6D;AACA,Q;AACA,6E;AACA,Q;AACA,0E;AACA,Q;AACA,qE;AACA,Q;AACA,0E;AACA,6B;AACA,Q;AACA,sE;AACA,kC;AACA,Q;AACA,wE;AACA,sE;AACA,wB;AACA,yE;AACA,sE;AACA,gD;AACA,M;AACA,4E;AACA,qC;AACA,0E;AACA,6C;AACA,Q;AACA,6E;AACA,+C;AACA,wD;AACA,sB;AACA,Q;AACA,yC;AACA,yD;AACA,mD;AACA,M;AACA,qB;AACA,E;AACA,S;AACA,0B;AACA,8C;AACA,iF;AACA,G;AACA,C;AACA,0C;AACA,c;AACA,E;AACA,qB;AACA,E;AACA,8D;AACA,iC;AACA,E;AACA,I;AACA,wE;AACA,6C;AACA,I;AACA,wC;AACA,uC;AACA,iC;AACA,+B;AACA,I;AACA,I;AACA,E;AACA,I;AACA,wF;AACA,oE;AACA,I;AACA,yC;AACA,2B;AACA,wC;AACA,gE;AACA,W;AACA,I;AACA,Y;AACA,I;AACA,E;AACA,2E;AACA,gB;AACA,E;AACA,I;AACA,sE;AACA,2D;AACA,qE;AACA,+E;AACA,gE;AACA,gE;AACA,+E;AACA,I;AACA,+B;AACA,mB;AACA,wB;AACA,iB;AACA,I;AACA,M;AACA,gE;AACA,sC;AACA,6D;AACA,+E;AACA,yE;AACA,M;AACA,oB;AACA,I;AACA,qB;AACA,qB;AACA,E;AACA,kC;AACA,8C;AACA,K;AACA,6E;AACA,yC;AACA,iB;AACA,C;AACA,6E;AACA,yD;AACA,qB;AACA,+D;AACA,8D;AACA,Q;AACA,4B;AACA,K;AACA,sB;AACA,yC;AACA,wB;AACA,M;AACA,C;AACA,sE;AACA,gC;AACA,C;AACA,oC;AACA,sB;AACA,C;AACA,+E;AACA,sC;AACA,C;AACA,O;AACA,+E;AACA,iF;AACA,4C;AACA,O;AACA,2C;AACA,sD;AACA,wD;AACA,O;AACA,Q;AACA,Y;AACA,M;AACA,G;AACA,uF;AACA,2D;AACA,0B;AACA,2B;AACA,2C;AACA,sB;AACA,6B;AACA,+C;AACA,K;AACA,0D;AACA,0B;AACA,2B;AACA,2C;AACA,wB;AACA,6B;AACA,+C;AACA,K;AACA,a;AACA,G;AACA,+B;AACA,M;AACA,8E;AACA,iD;AACA,M;AACA,oB;AACA,a;AACA,I;AACA,E;AACA,iF;AACA,sB;AACA,2C;AACA,oB;AACA,G;AACA,oC;AACA,mC;AACA,e;AACA,kB;AACA,K;AACA,M;AACA,G;AACA,gB;AACA,I;AACA,E;AACA,0C;AACA,a;AACA,K;AACA,2C;AACA,G;AACA,U;AACA,sB;AACA,sE;AACA,uE;AACA,2E;AACA,6D;AACA,I;AACA,U;AACA,oB;AACA,0E;AACA,oE;AACA,2D;AACA,I;AACA,gF;AACA,uE;AACA,2E;AACA,mD;AACA,C;AACA,2B;AACA,I;AACA,+E;AACA,gF;AACA,6E;AACA,gE;AACA,C;AACA,qE;AACA,qB;AACA,M;AACA,I;AACA,gF;AACA,gF;AACA,a;AACA,C;AACA,qD;AACA,iC;AACA,mC;AACA,O;AACA,Y;AACA,2D;AACA,O;AACA,M;AACA,I;AACA,gF;AACA,8E;AACA,sC;AACA,C;AACA,qD;AACA,6B;AACA,O;AACA,0C;AACA,M;AACA,I;AACA,4C;AACA,C;AACA,0B;AACA,wC;AACA,M;AACA,I;AACA,gF;AACA,+B;AACA,C;AACA,8E;AACA,+E;AACA,gC;AACA,K;AACA,+B;AACA,yD;AACA,0B;AACA,8C;AACA,a;AACA,qB;AACA,C;AACA,qD;AACA,sC;AACA,iC;AACA,M;AACA,C;AACA,yD;AACA,iC;AACA,4C;AACA,M;AACA,6C;AACA,C;AACA,2C;AACA,oB;AACA,sC;AACA,6B;AACA,M;AACA,K;AACA,8C;AACA,6C;AACA,yE;AACA,wC;AACA,K;AACA,sB;AACA,qD;AACA,kB;AACA,oE;AACA,+B;AACA,8C;AACA,sB;AACA,C;AACA,sC;AACA,mB;AACA,8B;AACA,wB;AACA,sB;AACA,sB;AACA,S;AACA,M;AACA,W;AACA,4C;AACA,M;AACA,K;AACA,8C;AACA,a;AACA,+B;AACA,M;AACA,6D;AACA,sC;AACA,6C;AACA,M;AACA,O;AACA,I;AACA,gF;AACA,sB;AACA,I;AACA,gB;AACA,K;AACA,G;AACA,G;AACA,K;AACA,+B;AACA,G;AACA,iF;AACA,8E;AACA,kF;AACA,mC;AACA,K;AACA,uB;AACA,sC;AACA,qB;AACA,K;AACA,sC;AACA,sC;AACA,C;AACA,qB;AACA,kC;AACA,C;AACA,iC;AACA,8D;AACA,8B;AACA,Q;AACA,O;AACA,Q;AACA,O;AACA,K;AACA,G;AACA,K;AACA,gC;AACA,G;AACA,6E;AACA,sE;AACA,K;AACA,wB;AACA,gD;AACA,I;AACA,I;AACA,E;AACA,I;AACA,8C;AACA,I;AACA,e;AACA,G;AACA,K;AACA,8B;AACA,G;AACA,4E;AACA,kF;AACA,kF;AACA,mF;AACA,yE;AACA,K;AACA,wB;AACA,qC;AACA,0C;AACA,wD;AACA,2E;AACA,uD;AACA,K;AACA,yC;AACA,mE;AACA,wD;AACA,qB;AACA,C;AACA,yD;AACA,wC;AACA,2B;AACA,M;AACA,oE;AACA,mD;AACA,sD;AACA,O;AACA,4D;AACA,sD;AACA,iD;AACA,mD;AACA,2D;AACA,O;AACA,C;AACA,S;AACA,8D;AACA,0B;AACA,Q;AACA,uD;AACA,oC;AACA,C;AACA,Q;AACA,uE;AACA,sE;AACA,oB;AACA,Q;AACA,yC;AACA,C;AACA,qF;AACA,kC;AACA,O;AACA,0F;AACA,oC;AACA,O;AACA,wE;AACA,+B;AACA,gE;AACA,oC;AACA,O;AACA,Q;AACA,K;AACA,8C;AACA,sC;AACA,iC;AACA,Q;AACA,O;AACA,K;AACA,G;AACA,G;AACA,K;AACA,qC;AACA,G;AACA,6E;AACA,wE;AACA,+B;AACA,K;AACA,+B;AACA,mE;AACA,K;AACA,G;AACA,G;AACA,K;AACA,qB;AACA,G;AACA,gF;AACA,Y;AACA,C;AACA,yB;AACA,sD;AACA,0B;AACA,M;AACA,8B;AACA,G;AACA,gF;AACA,Y;AACA,K;AACA,0B;AACA,qB;AACA,qC;AACA,yC;AACA,qC;AACA,Q;AACA,O;AACA,kB;AACA,I;AACA,I;AACA,C;AACA,E;AACA,I;AACA,iD;AACA,I;AACA,+B;AACA,G;AACA,yB;AACA,iF;AACA,I;AACA,sD;AACA,+C;AACA,I;AACA,yC;AACA,oD;AACA,I;AACA,S;AACA,sE;AACA,I;AACA,I;AACA,E;AACA,E;AACA,I;AACA,gF;AACA,uB;AACA,E;AACA,S;AACA,6B;AACA,kB;AACA,gF;AACA,qF;AACA,mF;AACA,kF;AACA,oD;AACA,E;AACA,Y;AACA,U;AACA,gB;AACA,kF;AACA,+E;AACA,sC;AACA,G;AACA,S;AACA,W;AACA,qB;AACA,mF;AACA,kD;AACA,C;AACA,Q;AACA,6B;AACA,a;AACA,gF;AACA,+E;AACA,6E;AACA,gD;AACA,G;AACA,c;AACA,U;AACA,iB;AACA,+E;AACA,8C;AACA,G;AACA,a;AACA,U;AACA,iB;AACA,0D;AACA,E;AACA,kF;AACA,gF;AACA,oF;AACA,wB;AACA,C;AACA,gB;AACA,E;AACA,gF;AACA,kF;AACA,iD;AACA,C;AACA,yC;AACA,sB;AACA,kE;AACA,G;AACA,E;AACA,kF;AACA,6E;AACA,+E;AACA,gF;AACA,E;AACA,kF;AACA,2C;AACA,E;AACA,0B;AACA,E;AACA,qE;AACA,C;AACA,mF;AACA,8E;AACA,gF;AACA,mD;AACA,E;AACA,oF;AACA,oF;AACA,kD;AACA,E;AACA,iD;AACA,qC;AACA,K;AACA,E;AACA,0D;AACA,E;AACA,4E;AACA,oC;AACA,E;AACA,kD;AACA,0B;AACA,K;AACA,E;AACA,wB;AACA,E;AACA,uB;AACA,0C;AACA,6B;AACA,M;AACA,K;AACA,E;AACA,I;AACA,uB;AACA,oB;AACA,a;AACA,sB;AACA,kB;AACA,I;AACA,E;AACA,E;AACA,E;AACA,E;AACA,E;AACA,I;AACA,kE;AACA,I;AACA,6B;AACA,2B;AACA,yC;AACA,I;AACA,S;AACA,oC;AACA,I;AACA,I;AACA,E;AACA,E;AACA,I;AACA,sB;AACA,E;AACA,gE;AACA,G;AACA,gB;AACA,S;AACA,e;AACA,mE;AACA,yE;AACA,uE;AACA,8B;AACA,gE;AACA,G;AACA,gB;AACA,S;AACA,e;AACA,uE;AACA,0E;AACA,2E;AACA,sC;AACA,gE;AACA,I;AACA,qB;AACA,uB;AACA,sB;AACA,I;AACA,E;AACA,sB;AACA,wC;AACA,qB;AACA,K;AACA,6C","sourcesContent":["/*!\r\njQuery Waypoints - v1.1.7\r\nCopyright (c) 2011-2012 Caleb Troughton\r\nDual licensed under the MIT license and GPL license.\r\nhttps://github.com/imakewebthings/jquery-waypoints/blob/master/MIT-license.txt\r\nhttps://github.com/imakewebthings/jquery-waypoints/blob/master/GPL-license.txt\r\n*/\r\n\r\n/*\r\nWaypoints is a small jQuery plugin that makes it easy to execute a function\r\nwhenever you scroll to an element.\r\n\r\nGitHub Repository: https://github.com/imakewebthings/jquery-waypoints\r\nDocumentation and Examples: http://imakewebthings.github.com/jquery-waypoints\r\n\r\nChangelog:\r\n\tv1.1.7\r\n\t\t- Actually fix the post-load bug in Issue #28 from v1.1.3.\r\n\tv1.1.6\r\n\t\t- Fix potential memory leak by unbinding events on empty context elements.\r\n\tv1.1.5\r\n\t\t- Make plugin compatible with Browserify/RequireJS. (Thanks @cjroebuck)\r\n\tv1.1.4\r\n\t\t- Add handler option to give alternate binding method. (Issue #34)\r\n\tv1.1.3\r\n\t\t- Fix cases where waypoints are added post-load and should be triggered\r\n\t\t  immediately. (Issue #28)\r\n\tv1.1.2\r\n\t\t- Fixed error thrown by waypoints with triggerOnce option that were\r\n\t\t  triggered via resize refresh.\r\n\tv1.1.1\r\n\t\t- Fixed bug in initialization where all offsets were being calculated\r\n\t\t  as if set to 0 initially, causing unwarranted triggers during the\r\n\t\t  subsequent refresh.\r\n\t\t- Added onlyOnScroll, an option for individual waypoints that disables\r\n\t\t  triggers due to an offset refresh that crosses the current scroll\r\n\t\t  point. (All credit to @knuton on this one.)\r\n\tv1.1\r\n\t\t- Moved the continuous option out of global settings and into the options\r\n\t\t  object for individual waypoints.\r\n\t\t- Added the context option, which allows for using waypoints within any\r\n\t\t  scrollable element, not just the window.\r\n\tv1.0.2\r\n\t\t- Moved scroll and resize handler bindings out of load.  Should play nicer\r\n\t\t  with async loaders like Head JS and LABjs.\r\n\t\t- Fixed a 1px off error when using certain % offsets.\r\n\t\t- Added unit tests.\r\n\tv1.0.1\r\n\t\t- Added $.waypoints('viewportHeight').\r\n\t\t- Fixed iOS bug (using the new viewportHeight method).\r\n\t\t- Added offset function alias: 'bottom-in-view'.\r\n\tv1.0\r\n\t\t- Initial release.\r\n\t\r\nSupport:\r\n\t- jQuery versions 1.4.3+\r\n\t- IE6+, FF3+, Chrome 6+, Safari 4+, Opera 11\r\n\t- Other versions and browsers may work, these are just the ones I've looked at.\r\n*/\r\n\r\n(function($, wp, wps, window, undefined){\r\n\t'$:nomunge';\r\n\t\r\n\tvar $w = $(window),\r\n\t\r\n\t// Keeping common strings as variables = better minification\r\n\teventName = 'waypoint.reached',\r\n\t\r\n\t/*\r\n\tFor the waypoint and direction passed in, trigger the waypoint.reached\r\n\tevent and deal with the triggerOnce option.\r\n\t*/\r\n\ttriggerWaypoint = function(way, dir) {\r\n\t\tway.element.trigger(eventName, dir);\r\n\t\tif (way.options.triggerOnce) {\r\n\t\t\tway.element[wp]('destroy');\r\n\t\t}\r\n\t},\r\n\t\r\n\t/*\r\n\tGiven a jQuery element and Context, returns the index of that element in the waypoints\r\n\tarray.  Returns the index, or -1 if the element is not a waypoint.\r\n\t*/\r\n\twaypointIndex = function(el, context) {\r\n\t\tif (!context) return -1;\r\n\t\tvar i = context.waypoints.length - 1;\r\n\t\twhile (i >= 0 && context.waypoints[i].element[0] !== el[0]) {\r\n\t\t\ti -= 1;\r\n\t\t}\r\n\t\treturn i;\r\n\t},\r\n\t\r\n\t// Private list of all elements used as scrolling contexts for waypoints.\r\n\tcontexts = [],\r\n\t\r\n\t/*\r\n\tContext Class - represents a scrolling context.  Properties include:\r\n\t\telement: jQuery object containing a single HTML element.\r\n\t\twaypoints: Array of waypoints operating under this scroll context.\r\n\t\toldScroll: Keeps the previous scroll position to determine scroll direction.\r\n\t\tdidScroll: Flag used in scrolling the context's scroll event.\r\n\t\tdidResize: Flag used in scrolling the context's resize event.\r\n\t\tdoScroll: Function that checks for crossed waypoints. Called from throttler.\r\n\t*/\r\n\tContext = function(context) {\r\n\t\t$.extend(this, {\r\n\t\t\telement: $(context),\r\n\t\t\toldScroll: 0,\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\tList of all elements that have been registered as waypoints.\r\n\t\t\tEach object in the array contains:\r\n\t\t\t\telement: jQuery object containing a single HTML element.\r\n\t\t\t\toffset: The window scroll offset, in px, that triggers the waypoint event.\r\n\t\t\t\toptions: Options object that was passed to the waypoint fn function.\r\n\t\t\t*/\r\n\t\t\t'waypoints': [],\r\n\t\t\t\r\n\t\t\tdidScroll: false,\r\n\t\t\tdidResize: false,\r\n\t\r\n\t\t\tdoScroll: $.proxy(function() {\r\n\t\t\t\tvar newScroll = this.element.scrollTop(),\r\n\t\t\t\t\r\n\t\t\t\t// Are we scrolling up or down? Used for direction argument in callback.\r\n\t\t\t\tisDown = newScroll > this.oldScroll,\r\n\t\t\t\tthat = this,\r\n\r\n\t\t\t\t// Get a list of all waypoints that were crossed since last scroll move.\r\n\t\t\t\tpointsHit = $.grep(this.waypoints, function(el, i) {\r\n\t\t\t\t\treturn isDown ?\r\n\t\t\t\t\t\t(el.offset > that.oldScroll && el.offset <= newScroll) :\r\n\t\t\t\t\t\t(el.offset <= that.oldScroll && el.offset > newScroll);\r\n\t\t\t\t}),\r\n\t\t\t\tlen = pointsHit.length;\r\n\t\t\t\t\r\n\t\t\t\t// iOS adjustment\r\n\t\t\t\tif (!this.oldScroll || !newScroll) {\r\n\t\t\t\t\t$[wps]('refresh');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Done with scroll comparisons, store new scroll before ejection\r\n\t\t\t\tthis.oldScroll = newScroll;\r\n\r\n\t\t\t\t// No waypoints crossed? Eject.\r\n\t\t\t\tif (!len) return;\r\n\r\n\t\t\t\t// If several waypoints triggered, need to do so in reverse order going up\r\n\t\t\t\tif (!isDown) pointsHit.reverse();\r\n\r\n\t\t\t\t/*\r\n\t\t\t\tOne scroll move may cross several waypoints.  If the waypoint's continuous\r\n\t\t\t\toption is true it should fire even if it isn't the last waypoint.  If false,\r\n\t\t\t\tit will only fire if it's the last one.\r\n\t\t\t\t*/\r\n\t\t\t\t$.each(pointsHit, function(i, point) {\r\n\t\t\t\t\tif (point.options.continuous || i === len - 1) {\r\n\t\t\t\t\t\ttriggerWaypoint(point, [isDown ? 'down' : 'up']);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}, this)\r\n\t\t});\r\n\t\t\r\n\t\t// Setup scroll and resize handlers.  Throttled at the settings-defined rate limits.\r\n\t\t$(context).bind('scroll.waypoints', $.proxy(function() {\r\n\t\t\tif (!this.didScroll) {\r\n\t\t\t\tthis.didScroll = true;\r\n\t\t\t\twindow.setTimeout($.proxy(function() {\r\n\t\t\t\t\tthis.doScroll();\r\n\t\t\t\t\tthis.didScroll = false;\r\n\t\t\t\t}, this), $[wps].settings.scrollThrottle);\r\n\t\t\t}\r\n\t\t}, this)).bind('resize.waypoints', $.proxy(function() {\r\n\t\t\tif (!this.didResize) {\r\n\t\t\t\tthis.didResize = true;\r\n\t\t\t\twindow.setTimeout($.proxy(function() {\r\n\t\t\t\t\t$[wps]('refresh');\r\n\t\t\t\t\tthis.didResize = false;\r\n\t\t\t\t}, this), $[wps].settings.resizeThrottle);\r\n\t\t\t}\r\n\t\t}, this));\r\n\t\t\r\n\t\t$w.load($.proxy(function() {\r\n\t\t\t/*\r\n\t\t\tFire a scroll check, should the page be loaded at a non-zero scroll value,\r\n\t\t\tas with a fragment id link or a page refresh.\r\n\t\t\t*/\r\n\t\t\tthis.doScroll();\r\n\t\t}, this));\r\n\t},\r\n\t\r\n\t/* Returns a Context object from the contexts array, given the raw HTML element\r\n\tfor that context. */\r\n\tgetContextByElement = function(element) {\r\n\t\tvar found = null;\r\n\t\t\r\n\t\t$.each(contexts, function(i, c) {\r\n\t\t\tif (c.element[0] === element) {\r\n\t\t\t\tfound = c;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\treturn found;\r\n\t},\r\n\t\r\n\t// Methods exposed to the effin' object \r\n\tmethods = {\r\n\t\t/*\r\n\t\tjQuery.fn.waypoint([handler], [options])\r\n\t\t\r\n\t\thandler\r\n\t\t\tfunction, optional\r\n\t\t\tA callback function called when the user scrolls past the element.\r\n\t\t\tThe function signature is function(event, direction) where event is\r\n\t\t\ta standard jQuery Event Object and direction is a string, either 'down'\r\n\t\t\tor 'up' indicating which direction the user is scrolling.\r\n\t\t\t\r\n\t\toptions\r\n\t\t\tobject, optional\r\n\t\t\tA map of options to apply to this set of waypoints, including where on\r\n\t\t\tthe browser window the waypoint is triggered. For a full list of\r\n\t\t\toptions and their defaults, see $.fn.waypoint.defaults.\r\n\t\t\t\r\n\t\tThis is how you register an element as a waypoint. When the user scrolls past\r\n\t\tthat element it triggers waypoint.reached, a custom event. Since the\r\n\t\tparameters for creating a waypoint are optional, we have a few different\r\n\t\tpossible signatures. Let’s look at each of them.\r\n\r\n\t\tsomeElements.waypoint();\r\n\t\t\t\r\n\t\tCalling .waypoint with no parameters will register the elements as waypoints\r\n\t\tusing the default options. The elements will fire the waypoint.reached event,\r\n\t\tbut calling it in this way does not bind any handler to the event. You can\r\n\t\tbind to the event yourself, as with any other event, like so:\r\n\r\n\t\tsomeElements.bind('waypoint.reached', function(event, direction) {\r\n\t\t   // make it rain\r\n\t\t});\r\n\t\t\t\r\n\t\tYou will usually want to create a waypoint and immediately bind a function to\r\n\t\twaypoint.reached, and can do so by passing a handler as the first argument to\r\n\t\t.waypoint:\r\n\r\n\t\tsomeElements.waypoint(function(event, direction) {\r\n\t\t   if (direction === 'down') {\r\n\t\t      // do this on the way down\r\n\t\t   }\r\n\t\t   else {\r\n\t\t      // do this on the way back up through the waypoint\r\n\t\t   }\r\n\t\t});\r\n\t\t\t\r\n\t\tThis will still use the default options, which will trigger the waypoint when\r\n\t\tthe top of the element hits the top of the window. We can pass .waypoint an\r\n\t\toptions object to customize things:\r\n\r\n\t\tsomeElements.waypoint(function(event, direction) {\r\n\t\t   // do something amazing\r\n\t\t}, {\r\n\t\t   offset: '50%'  // middle of the page\r\n\t\t});\r\n\t\t\t\r\n\t\tYou can also pass just an options object.\r\n\r\n\t\tsomeElements.waypoint({\r\n\t\t   offset: 100  // 100px from the top\r\n\t\t});\r\n\t\t\t\r\n\t\tThis behaves like .waypoint(), in that it registers the elements as waypoints\r\n\t\tbut binds no event handlers.\r\n\r\n\t\tCalling .waypoint on an existing waypoint will extend the previous options.\r\n\t\tIf the call includes a handler, it will be bound to waypoint.reached without\r\n\t\tunbinding any other handlers.\r\n\t\t*/\r\n\t\tinit: function(f, options) {\r\n\t\t\t// Register each element as a waypoint, add to array.\r\n\t\t\tthis.each(function() {\r\n\t\t\t\tvar cElement = $.fn[wp].defaults.context,\r\n\t\t\t\tcontext,\r\n\t\t\t\t$this = $(this);\r\n\r\n\t\t\t\t// Default window context or a specific element?\r\n\t\t\t\tif (options && options.context) {\r\n\t\t\t\t\tcElement = options.context;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Find the closest element that matches the context\r\n\t\t\t\tif (!$.isWindow(cElement)) {\r\n\t\t\t\t\tcElement = $this.closest(cElement)[0];\r\n\t\t\t\t}\r\n\t\t\t\tcontext = getContextByElement(cElement);\r\n\r\n\t\t\t\t// Not a context yet? Create and push.\r\n\t\t\t\tif (!context) {\r\n\t\t\t\t\tcontext = new Context(cElement);\r\n\t\t\t\t\tcontexts.push(context);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Extend default and preexisting options\r\n\t\t\t\tvar ndx = waypointIndex($this, context),\r\n\t\t\t\tbase = ndx < 0 ? $.fn[wp].defaults : context.waypoints[ndx].options,\r\n\t\t\t\topts = $.extend({}, base, options);\r\n\t\t\t\t\r\n\t\t\t\t// Offset aliases\r\n\t\t\t\topts.offset = opts.offset === \"bottom-in-view\" ?\r\n\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\tvar cHeight = $.isWindow(cElement) ? $[wps]('viewportHeight')\r\n\t\t\t\t\t\t\t: $(cElement).height();\r\n\t\t\t\t\t\treturn cHeight - $(this).outerHeight();\r\n\t\t\t\t\t} : opts.offset;\r\n\r\n\t\t\t\t// Update, or create new waypoint\r\n\t\t\t\tif (ndx < 0) {\r\n\t\t\t\t\tcontext.waypoints.push({\r\n\t\t\t\t\t\t'element': $this,\r\n\t\t\t\t\t\t'offset': null,\r\n\t\t\t\t\t\t'options': opts\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tcontext.waypoints[ndx].options = opts;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Bind the function if it was passed in.\r\n\t\t\t\tif (f) {\r\n\t\t\t\t\t$this.bind(eventName, f);\r\n\t\t\t\t}\r\n\t\t\t\t// Bind the function in the handler option if it exists.\r\n\t\t\t\tif (options && options.handler) {\r\n\t\t\t\t\t$this.bind(eventName, options.handler);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// Need to re-sort+refresh the waypoints array after new elements are added.\r\n\t\t\t$[wps]('refresh');\r\n\t\t\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\t/*\r\n\t\tjQuery.fn.waypoint('remove')\r\n\t\t\r\n\t\tPassing the string 'remove' to .waypoint unregisters the elements as waypoints\r\n\t\tand wipes any custom options, but leaves the waypoint.reached events bound.\r\n\t\tCalling .waypoint again in the future would reregister the waypoint and the old\r\n\t\thandlers would continue to work.\r\n\t\t*/\r\n\t\tremove: function() {\r\n\t\t\treturn this.each(function(i, el) {\r\n\t\t\t\tvar $el = $(el);\r\n\t\t\t\t\r\n\t\t\t\t$.each(contexts, function(i, c) {\r\n\t\t\t\t\tvar ndx = waypointIndex($el, c);\r\n\r\n\t\t\t\t\tif (ndx >= 0) {\r\n\t\t\t\t\t\tc.waypoints.splice(ndx, 1);\r\n\r\n\t\t\t\t\t\tif (!c.waypoints.length) {\r\n\t\t\t\t\t\t\tc.element.unbind('scroll.waypoints resize.waypoints');\r\n\t\t\t\t\t\t\tcontexts.splice(i, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/*\r\n\t\tjQuery.fn.waypoint('destroy')\r\n\t\t\r\n\t\tPassing the string 'destroy' to .waypoint will unbind all waypoint.reached\r\n\t\tevent handlers on those elements and unregisters them as waypoints.\r\n\t\t*/\r\n\t\tdestroy: function() {\r\n\t\t\treturn this.unbind(eventName)[wp]('remove');\r\n\t\t}\r\n\t},\r\n\t\r\n\t/*\r\n\tMethods used by the jQuery object extension.\r\n\t*/\r\n\tjQMethods = {\r\n\t\t\r\n\t\t/*\r\n\t\tjQuery.waypoints('refresh')\r\n\t\t\r\n\t\tThis will force a recalculation of each waypoint’s trigger point based on\r\n\t\tits offset option and context. This is called automatically whenever the window\r\n\t\t(or other defined context) is resized, new waypoints are added, or a waypoint’s\r\n\t\toptions are modified. If your project is changing the DOM or page layout without\r\n\t\tdoing one of these things, you may want to manually call this refresh.\r\n\t\t*/\r\n\t\trefresh: function() {\r\n\t\t\t$.each(contexts, function(i, c) {\r\n\t\t\t\tvar isWin = $.isWindow(c.element[0]),\r\n\t\t\t\tcontextOffset = isWin ? 0 : c.element.offset().top,\r\n\t\t\t\tcontextHeight = isWin ? $[wps]('viewportHeight') : c.element.height(),\r\n\t\t\t\tcontextScroll = isWin ? 0 : c.element.scrollTop();\r\n\t\t\t\t\r\n\t\t\t\t$.each(c.waypoints, function(j, o) {\r\n\t\t\t\t\t/* $.each isn't safe from element removal due to triggerOnce.\r\n\t\t\t\t\tShould rewrite the loop but this is way easier. */\r\n\t\t\t\t\tif (!o) return;\r\n\r\n\t\t\t\t\t// Adjustment is just the offset if it's a px value\r\n\t\t\t\t\tvar adjustment = o.options.offset,\r\n\t\t\t\t\toldOffset = o.offset;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Set adjustment to the return value if offset is a function.\r\n\t\t\t\t\tif (typeof o.options.offset === \"function\") {\r\n\t\t\t\t\t\tadjustment = o.options.offset.apply(o.element);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Calculate the adjustment if offset is a percentage.\r\n\t\t\t\t\telse if (typeof o.options.offset === \"string\") {\r\n\t\t\t\t\t\tvar amount = parseFloat(o.options.offset);\r\n\t\t\t\t\t\tadjustment = o.options.offset.indexOf(\"%\") ?\r\n\t\t\t\t\t\t\tMath.ceil(contextHeight * (amount / 100)) : amount;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* \r\n\t\t\t\t\tSet the element offset to the window scroll offset, less\r\n\t\t\t\t\tall our adjustments.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\to.offset = o.element.offset().top - contextOffset\r\n\t\t\t\t\t\t+ contextScroll - adjustment;\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\tAn element offset change across the current scroll point triggers\r\n\t\t\t\t\tthe event, just as if we scrolled past it unless prevented by an\r\n\t\t\t\t\toptional flag.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tif (o.options.onlyOnScroll) return;\r\n\r\n\t\t\t\t\tif (oldOffset !== null && c.oldScroll > oldOffset && c.oldScroll <= o.offset) {\r\n\t\t\t\t\t\ttriggerWaypoint(o, ['up']);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (oldOffset !== null && c.oldScroll < oldOffset && c.oldScroll >= o.offset) {\r\n\t\t\t\t\t\ttriggerWaypoint(o, ['down']);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* For new waypoints added after load, check that down should have\r\n\t\t\t\t\talready been triggered */\r\n\t\t\t\t\telse if (!oldOffset && c.element.scrollTop() > o.offset) {\r\n\t\t\t\t\t\ttriggerWaypoint(o, ['down']);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\t// Keep waypoints sorted by offset value.\r\n\t\t\t\tc.waypoints.sort(function(a, b) {\r\n\t\t\t\t\treturn a.offset - b.offset;\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\t/*\r\n\t\tjQuery.waypoints('viewportHeight')\r\n\t\t\r\n\t\tThis will return the height of the viewport, adjusting for inconsistencies\r\n\t\tthat come with calling $(window).height() in iOS. Recommended for use\r\n\t\twithin any offset functions.\r\n\t\t*/\r\n\t\tviewportHeight: function() {\r\n\t\t\treturn (window.innerHeight ? window.innerHeight : $w.height());\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\t/*\r\n\t\tjQuery.waypoints()\r\n\t\t\r\n\t\tThis will return a jQuery object with a collection of all registered waypoint\r\n\t\telements.\r\n\r\n\t\t$('.post').waypoint();\r\n\t\t$('.ad-unit').waypoint(function(event, direction) {\r\n\t\t   // Passed an ad unit\r\n\t\t});\r\n\t\tconsole.log($.waypoints());\r\n\t\t\r\n\t\tThe example above would log a jQuery object containing all .post and .ad-unit\r\n\t\telements.\r\n\t\t*/\r\n\t\taggregate: function() {\r\n\t\t\tvar points = $();\r\n\t\t\t$.each(contexts, function(i, c) {\r\n\t\t\t\t$.each(c.waypoints, function(i, e) {\r\n\t\t\t\t\tpoints = points.add(e.element);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\treturn points;\r\n\t\t}\r\n\t};\r\n\r\n\t\r\n\t/*\r\n\tfn extension.  Delegates to appropriate method.\r\n\t*/\r\n\t$.fn[wp] = function(method) {\r\n\t\t\r\n\t\tif (methods[method]) {\r\n\t\t\treturn methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\t}\r\n\t\telse if (typeof method === \"function\" || !method) {\r\n\t\t\treturn methods.init.apply(this, arguments);\r\n\t\t}\r\n\t\telse if (typeof method === \"object\") {\r\n\t\t\treturn methods.init.apply(this, [null, method]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$.error( 'Method ' + method + ' does not exist on jQuery ' + wp );\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\t/*\r\n\tThe default options object that is extended when calling .waypoint. It has the\r\n\tfollowing properties:\r\n\t\r\n\tcontext\r\n\t\tstring | element | jQuery*\r\n\t\tdefault: window\r\n\t\tThe context defines which scrollable element the waypoint belongs to and acts\r\n\t\twithin. The default, window, means the waypoint offset is calculated with relation\r\n\t\tto the whole viewport.  You can set this to another element to use the waypoints\r\n\t\twithin that element.  Accepts a selector string, *but if you use jQuery 1.6+ it\r\n\t\talso accepts a raw HTML element or jQuery object.\r\n\t\r\n\tcontinuous\r\n\t\tboolean\r\n\t\tdefault: true\r\n\t\tIf true, and multiple waypoints are triggered in one scroll, this waypoint will\r\n\t\ttrigger even if it is not the last waypoint reached.  If false, it will only\r\n\t\ttrigger if it is the last waypoint.\r\n\t\t\r\n\thandler\r\n\t\tfunction\r\n\t\tdefault: undefined\r\n\t\tAn alternative way to bind functions to the waypoint, without using the function\r\n\t\tas the first argument to the waypoint function.\r\n\r\n\toffset\r\n\t\tnumber | string | function\r\n\t\tdefault: 0\r\n\t\tDetermines how far the top of the element must be from the top of the browser\r\n\t\twindow to trigger a waypoint. It can be a number, which is taken as a number\r\n\t\tof pixels, a string representing a percentage of the viewport height, or a\r\n\t\tfunction that will return a number of pixels.\r\n\t\t\r\n\tonlyOnScroll\r\n\t\tboolean\r\n\t\tdefault: false\r\n\t\tIf true, this waypoint will not trigger if an offset change during a refresh\r\n\t\tcauses it to pass the current scroll point.\r\n\t\t\r\n\ttriggerOnce\r\n\t\tboolean\r\n\t\tdefault: false\r\n\t\tIf true, the waypoint will be destroyed when triggered.\r\n\t\r\n\tAn offset of 250 would trigger the waypoint when the top of the element is 250px\r\n\tfrom the top of the viewport. Negative values for any offset work as you might\r\n\texpect. A value of -100 would trigger the waypoint when the element is 100px above\r\n\tthe top of the window.\r\n\r\n\toffset: '100%'\r\n\t\r\n\tA string percentage will determine the pixel offset based on the height of the\r\n\twindow. When resizing the window, this offset will automatically be recalculated\r\n\twithout needing to call $.waypoints('refresh').\r\n\r\n\t// The bottom of the element is in view\r\n\toffset: function() {\r\n\t   return $.waypoints('viewportHeight') - $(this).outerHeight();\r\n\t}\r\n\t\r\n\tOffset can take a function, which must return a number of pixels from the top of\r\n\tthe window. The this value will always refer to the raw HTML element of the\r\n\twaypoint. As with % values, functions are recalculated automatically when the\r\n\twindow resizes. For more on recalculating offsets, see $.waypoints('refresh').\r\n\t\r\n\tAn offset value of 'bottom-in-view' will act as an alias for the function in the\r\n\texample above, as this is a common usage.\r\n\t\r\n\toffset: 'bottom-in-view'\r\n\t\r\n\tYou can see this alias in use on the Scroll Analytics example page.\r\n\r\n\tThe triggerOnce flag, if true, will destroy the waypoint after the first trigger.\r\n\tThis is just a shortcut for calling .waypoint('destroy') within the waypoint\r\n\thandler. This is useful in situations such as scroll analytics, where you only\r\n\twant to record an event once for each page visit.\r\n\t\r\n\tThe context option lets you use Waypoints within an element other than the window.\r\n\tYou can define the context with a selector string and the waypoint will act within\r\n\tthe nearest ancestor that matches this selector.\r\n\t\r\n\t$('.something-scrollable .waypoint').waypoint({\r\n\t   context: '.something-scrollable'\r\n\t});\r\n\t\r\n\tYou can see this in action on the Dial Controls example.\r\n\t\r\n\tThe handler option gives authors an alternative way to bind functions when\r\n\tcreating a waypoint.  In place of:\r\n\t\r\n\t$('.item').waypoint(function(event, direction) {\r\n\t   // make things happen\r\n\t});\r\n\t\r\n\tYou may instead write:\r\n\t\r\n\t$('.item').waypoint({\r\n\t   handler: function(event, direction) {\r\n\t      // make things happen\r\n\t   }\r\n\t});\r\n\t\r\n\t*/\r\n\t$.fn[wp].defaults = {\r\n\t\tcontinuous: true,\r\n\t\toffset: 0,\r\n\t\ttriggerOnce: false,\r\n\t\tcontext: window\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t/*\r\n\tjQuery object extension. Delegates to appropriate methods above.\r\n\t*/\r\n\t$[wps] = function(method) {\r\n\t\tif (jQMethods[method]) {\r\n\t\t\treturn jQMethods[method].apply(this);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn jQMethods['aggregate']();\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\t/*\r\n\t$.waypoints.settings\r\n\t\r\n\tSettings object that determines some of the plugin’s behavior.\r\n\t\t\r\n\tresizeThrottle\r\n\t\tnumber\r\n\t\tdefault: 200\r\n\t\tFor performance reasons, the refresh performed during resizes is\r\n\t\tthrottled. This value is the rate-limit in milliseconds between resize\r\n\t\trefreshes. For more information on throttling, check out Ben Alman’s\r\n\t\tthrottle / debounce plugin.\r\n\t\thttp://benalman.com/projects/jquery-throttle-debounce-plugin/\r\n\t\t\r\n\tscrollThrottle\r\n\t\tnumber\r\n\t\tdefault: 100\r\n\t\tFor performance reasons, checking for any crossed waypoints during a\r\n\t\tscroll event is throttled. This value is the rate-limit in milliseconds\r\n\t\tbetween scroll checks. For more information on throttling, check out Ben\r\n\t\tAlman’s throttle / debounce plugin.\r\n\t\thttp://benalman.com/projects/jquery-throttle-debounce-plugin/\r\n\t*/\r\n\t$[wps].settings = {\r\n\t\tresizeThrottle: 200,\r\n\t\tscrollThrottle: 100\r\n\t};\r\n\t\r\n\t$w.load(function() {\r\n\t\t// Calculate everything once on load.\r\n\t\t$[wps]('refresh');\r\n\t});\r\n})(jQuery, 'waypoint', 'waypoints', window);\r\n"]}