{"version":3,"file":"/packages/browser-policy-content.js","sources":["browser-policy-content/browser-policy-content.js"],"names":[],"mappings":";;;;;;;;AAAA,gE;AACA,2E;AACA,+E;AACA,qB;AACA,E;AACA,6E;AACA,4E;AACA,qB;AACA,E;AACA,oD;AACA,uB;AACA,mE;AACA,sB;AACA,yB;AACA,c;AACA,iB;AACA,E;AACA,yE;AACA,6C;AACA,6E;AACA,wB;AACA,gF;AACA,4E;AACA,c;AACA,+E;AACA,wB;AACA,E;AACA,6E;AACA,Q;AACA,gC;AACA,2B;AACA,8B;AACA,uB;AACA,E;;AAEA,Y;AACA,6E;;AAEA,yC;AACA,qC;AACA,iC;AACA,2B;AACA,2B;;AAEA,2B;;AAEA,+B;AACA,iC;AACA,e;AACA,sC;AACA,0C;AACA,sD;AACA,iC;AACA,4B;AACA,4C;AACA,gC;AACA,Q;AACA,yC;AACA,K;;AAEA,2C;AACA,4D;AACA,kE;;AAEA,kD;AACA,iD;AACA,8E;AACA,K;AACA,E;;AAEA,8C;AACA,gE;AACA,E;;AAEA,+E;AACA,4B;AACA,mD;AACA,0B;AACA,mB;AACA,kC;AACA,yD;AACA,E;;AAEA,oC;AACA,8E;AACA,+E;AACA,6E;AACA,wE;AACA,gD;AACA,0D;AACA,yE;AACA,qD;AACA,4D;AACA,uE;AACA,E;;AAEA,+C;AACA,qC;AACA,mD;AACA,E;;AAEA,iC;AACA,kD;AACA,8B;AACA,wC;AACA,kB;;AAEA,kB;AACA,uB;;AAEA,4D;AACA,wB;AACA,0B;AACA,6B;AACA,gD;AACA,kD;AACA,O;;AAEA,8B;AACA,uB;AACA,kB;AACA,I;AACA,uB;AACA,qB;AACA,uB;AACA,I;;AAEA,6B;AACA,qB;AACA,kB;AACA,2B;AACA,uE;AACA,M;AACA,I;;AAEA,kD;AACA,iC;AACA,2D;AACA,I;;AAEA,mD;;AAEA,mC;AACA,yC;AACA,6C;AACA,iC;AACA,I;AACA,sC;AACA,yC;AACA,6C;AACA,kC;AACA,I;AACA,0B;AACA,yC;AACA,2C;AACA,I;AACA,6B;AACA,yC;AACA,2C;AACA,I;AACA,kC;AACA,wC;AACA,4C;AACA,I;AACA,qC;AACA,wC;AACA,4C;AACA,I;;AAEA,mC;AACA,sC;AACA,yD;AACA,I;AACA,mC;AACA,qD;AACA,I;AACA,wC;AACA,0C;AACA,kD;AACA,sC;AACA,O;AACA,I;AACA,4B;AACA,qB;AACA,e;AACA,uB;AACA,M;AACA,kC;AACA,G;AACA,G;;AAEA,uE;AACA,wD;AACA,2C;AACA,oC;AACA,4B;AACA,2C;AACA,4B;AACA,kC;AACA,8D;AACA,+B;AACA,iB;AACA,oC;AACA,U;AACA,mE;AACA,8D;AACA,wE;AACA,2E;;AAEA,qC;AACA,4B;AACA,mC;AACA,W;;AAEA,kE;AACA,6C;AACA,wC;AACA,W;AACA,qC;AACA,oE;AACA,wB;AACA,2C;AACA,a;AACA,iB;AACA,gE;AACA,U;AACA,mE;AACA,6C;AACA,4C;AACA,W;AACA,mE;AACA,6C;AACA,gD;AACA,W;AACA,U;;;AAGA,mB","sourcesContent":["// By adding this package, you get the following default policy:\n// No eval or other string-to-code, and content can only be loaded from the\n// same origin as the app (except for XHRs and websocket connections, which can\n// go to any origin).\n//\n// Apps should call BrowserPolicy.content.disallowInlineScripts() if they are\n// not using any inline script tags and are willing to accept an extra round\n// trip on page load.\n//\n// BrowserPolicy.content functions for tweaking CSP:\n// allowInlineScripts()\n// disallowInlineScripts(): adds extra round-trip to page load time\n// allowInlineStyles()\n// disallowInlineStyles()\n// allowEval()\n// disallowEval()\n//\n// For each type of content (script, object, image, media, font, connect,\n// style), there are the following functions:\n// allow<content type>Origin(origin): allows the type of content to be loaded\n// from the given origin\n// allow<content type>DataUrl(): allows the content to be loaded from data: URLs\n// allow<content type>SameOrigin(): allows the content to be loaded from the\n// same origin\n// disallow<content type>(): disallows this type of content all together (can't\n// be called for script)\n//\n// The following functions allow you to set rules for all types of content at\n// once:\n// allowAllContentOrigin(origin)\n// allowAllContentDataUrl()\n// allowAllContentSameOrigin()\n// disallowAllContent()\n//\n\nvar cspSrcs;\nvar cachedCsp; // Avoid constructing the header out of cspSrcs when possible.\n\n// CSP keywords have to be single-quoted.\nvar unsafeInline = \"'unsafe-inline'\";\nvar unsafeEval = \"'unsafe-eval'\";\nvar selfKeyword = \"'self'\";\nvar noneKeyword = \"'none'\";\n\nBrowserPolicy.content = {};\n\nvar parseCsp = function (csp) {\n  var policies = csp.split(\"; \");\n  cspSrcs = {};\n  _.each(policies, function (policy) {\n    if (policy[policy.length - 1] === \";\")\n      policy = policy.substring(0, policy.length - 1);\n    var srcs = policy.split(\" \");\n    var directive = srcs[0];\n    if (_.indexOf(srcs, noneKeyword) !== -1)\n      cspSrcs[directive] = null;\n    else\n      cspSrcs[directive] = srcs.slice(1);\n  });\n\n  if (cspSrcs[\"default-src\"] === undefined)\n    throw new Error(\"Content Security Policies used with \" +\n                    \"browser-policy must specify a default-src.\");\n\n  // Copy default-src sources to other directives.\n  _.each(cspSrcs, function (sources, directive) {\n    cspSrcs[directive] = _.union(sources || [], cspSrcs[\"default-src\"] || []);\n  });\n};\n\nvar removeCspSrc = function (directive, src) {\n  cspSrcs[directive] = _.without(cspSrcs[directive] || [], src);\n};\n\n// Prepare for a change to cspSrcs. Ensure that we have a key in the dictionary\n// and clear any cached CSP.\nvar prepareForCspDirective = function (directive) {\n  cspSrcs = cspSrcs || {};\n  cachedCsp = null;\n  if (! _.has(cspSrcs, directive))\n    cspSrcs[directive] = _.clone(cspSrcs[\"default-src\"]);\n};\n\nvar setDefaultPolicy = function () {\n  // By default, unsafe inline scripts and styles are allowed, since we expect\n  // many apps will use them for analytics, etc. Unsafe eval is disallowed, and\n  // the only allowable content source is the same origin or data, except for\n  // connect which allows anything (since meteor.com apps make websocket\n  // connections to a lot of different origins).\n  BrowserPolicy.content.setPolicy(\"default-src 'self'; \" +\n                                  \"script-src 'self' 'unsafe-inline'; \" +\n                                  \"connect-src *; \" +\n                                  \"img-src data: 'self'; \" +\n                                  \"style-src 'self' 'unsafe-inline';\");\n};\n\nvar setWebAppInlineScripts = function (value) {\n  if (! BrowserPolicy._runningTest())\n    WebAppInternals.setInlineScriptsAllowed(value);\n};\n\n_.extend(BrowserPolicy.content, {\n  // Exported for tests and browser-policy-common.\n  _constructCsp: function () {\n    if (! cspSrcs || _.isEmpty(cspSrcs))\n      return null;\n\n    if (cachedCsp)\n      return cachedCsp;\n\n    var header = _.map(cspSrcs, function (srcs, directive) {\n      srcs = srcs || [];\n      if (_.isEmpty(srcs))\n        srcs = [noneKeyword];\n      var directiveCsp = _.uniq(srcs).join(\" \");\n      return directive + \" \" + directiveCsp + \";\";\n    });\n\n    header = header.join(\" \");\n    cachedCsp = header;\n    return header;\n  },\n  _reset: function () {\n    cachedCsp = null;\n    setDefaultPolicy();\n  },\n\n  setPolicy: function (csp) {\n    cachedCsp = null;\n    parseCsp(csp);\n    setWebAppInlineScripts(\n      BrowserPolicy.content._keywordAllowed(\"script-src\", unsafeInline)\n    );\n  },\n\n  _keywordAllowed: function (directive, keyword) {\n    return (cspSrcs[directive] &&\n            _.indexOf(cspSrcs[directive], keyword) !== -1);\n  },\n\n  // Helpers for creating content security policies\n\n  allowInlineScripts: function () {\n    prepareForCspDirective(\"script-src\");\n    cspSrcs[\"script-src\"].push(unsafeInline);\n    setWebAppInlineScripts(true);\n  },\n  disallowInlineScripts: function () {\n    prepareForCspDirective(\"script-src\");\n    removeCspSrc(\"script-src\", unsafeInline);\n    setWebAppInlineScripts(false);\n  },\n  allowEval: function () {\n    prepareForCspDirective(\"script-src\");\n    cspSrcs[\"script-src\"].push(unsafeEval);\n  },\n  disallowEval: function () {\n    prepareForCspDirective(\"script-src\");\n    removeCspSrc(\"script-src\", unsafeEval);\n  },\n  allowInlineStyles: function () {\n    prepareForCspDirective(\"style-src\");\n    cspSrcs[\"style-src\"].push(unsafeInline);\n  },\n  disallowInlineStyles: function () {\n    prepareForCspDirective(\"style-src\");\n    removeCspSrc(\"style-src\", unsafeInline);\n  },\n\n  // Functions for setting defaults\n  allowSameOriginForAll: function () {\n    BrowserPolicy.content.allowOriginForAll(selfKeyword);\n  },\n  allowDataUrlForAll: function () {\n    BrowserPolicy.content.allowOriginForAll(\"data:\");\n  },\n  allowOriginForAll: function (origin) {\n    prepareForCspDirective(\"default-src\");\n    _.each(_.keys(cspSrcs), function (directive) {\n      cspSrcs[directive].push(origin);\n    });\n  },\n  disallowAll: function () {\n    cachedCsp = null;\n    cspSrcs = {\n      \"default-src\": []\n    };\n    setWebAppInlineScripts(false);\n  }\n});\n\n// allow<Resource>Origin, allow<Resource>Data, allow<Resource>self, and\n// disallow<Resource> methods for each type of resource.\n_.each([\"script\", \"object\", \"img\", \"media\",\n        \"font\", \"connect\", \"style\"],\n       function (resource) {\n         var directive = resource + \"-src\";\n         var methodResource;\n         if (resource !== \"img\") {\n           methodResource = resource.charAt(0).toUpperCase() +\n             resource.slice(1);\n         } else {\n           methodResource = \"Image\";\n         }\n         var allowMethodName = \"allow\" + methodResource + \"Origin\";\n         var disallowMethodName = \"disallow\" + methodResource;\n         var allowDataMethodName = \"allow\" + methodResource + \"DataUrl\";\n         var allowSelfMethodName = \"allow\" + methodResource + \"SameOrigin\";\n\n         var disallow = function () {\n           cachedCsp = null;\n           cspSrcs[directive] = [];\n         };\n\n         BrowserPolicy.content[allowMethodName] = function (src) {\n           prepareForCspDirective(directive);\n           cspSrcs[directive].push(src);\n         };\n         if (resource === \"script\") {\n           BrowserPolicy.content[disallowMethodName] = function () {\n             disallow();\n             setWebAppInlineScripts(false);\n           };\n         } else {\n           BrowserPolicy.content[disallowMethodName] = disallow;\n         }\n         BrowserPolicy.content[allowDataMethodName] = function () {\n           prepareForCspDirective(directive);\n           cspSrcs[directive].push(\"data:\");\n         };\n         BrowserPolicy.content[allowSelfMethodName] = function () {\n           prepareForCspDirective(directive);\n           cspSrcs[directive].push(selfKeyword);\n         };\n       });\n\n\nsetDefaultPolicy();\n"]}