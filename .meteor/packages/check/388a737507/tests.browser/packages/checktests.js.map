{"version":3,"file":"/packages/check:tests.js","sources":["check/match_test.js"],"names":[],"mappings":";;;;;;;;AAAA,+C;AACA,2C;AACA,c;AACA,S;AACA,4B;AACA,iB;AACA,gB;AACA,K;AACA,wB;AACA,4C;AACA,I;AACA,yC;AACA,c;AACA,S;AACA,4B;AACA,iB;AACA,gB;AACA,K;AACA,uB;AACA,wC;AACA,6C;AACA,I;;AAEA,W;AACA,e;AACA,oB;AACA,iB;AACA,gB;AACA,oB;AACA,kB;AACA,uB;AACA,oB;AACA,qB;AACA,2B;AACA,gB;AACA,I;AACA,iC;AACA,gC;AACA,wE;AACA,6B;AACA,+B;AACA,+C;AACA,iD;AACA,kD;AACA,+B;AACA,sB;AACA,Y;AACA,kD;AACA,e;AACA,iC;AACA,wB;AACA,uB;AACA,yB;AACA,W;AACA,Y;AACA,c;AACA,6B;AACA,qD;AACA,qD;AACA,gD;AACA,+B;AACA,sB;AACA,Y;AACA,gD;AACA,e;AACA,iC;AACA,wB;AACA,uB;AACA,yB;AACA,W;AACA,Y;AACA,O;AACA,6B;AACA,6B;AACA,O;AACA,K;AACA,uE;AACA,mC;AACA,oC;AACA,iC;;AAEA,+B;AACA,wB;AACA,kC;AACA,kC;AACA,yD;;AAEA,sB;AACA,kB;AACA,6B;AACA,uB;AACA,+C;AACA,kC;AACA,2D;AACA,yD;AACA,yD;AACA,yB;AACA,2C;AACA,+C;AACA,gD;AACA,4E;AACA,a;AACA,qD;;AAEA,yB;AACA,uB;AACA,0B;AACA,0B;AACA,4D;AACA,yC;;AAEA,iE;AACA,+D;;AAEA,W;AACA,mB;AACA,Q;AACA,uB;AACA,kC;AACA,K;AACA,4C;AACA,c;AACA,uC;;;AAGA,kB;AACA,6B;AACA,4B;AACA,4B;AACA,iD;AACA,gD;AACA,+B;AACA,4B;AACA,8C;AACA,4B;AACA,iC;AACA,kC;AACA,2B;AACA,2B;AACA,uC;AACA,iC;;AAEA,oD;AACA,sC;AACA,iC;AACA,I;AACA,qB;AACA,sB;AACA,yB;AACA,oC;AACA,+B;AACA,I;AACA,wB;AACA,0B;AACA,G;;AAEA,0D;AACA,uD;AACA,2C;AACA,oD;AACA,I;AACA,qC;AACA,qE;AACA,gE;AACA,iE;AACA,gE;AACA,6D;AACA,yC;AACA,qB;AACA,sB;AACA,qC;AACA,kB;AACA,kC;AACA,+B;AACA,c;AACA,kC;AACA,qB;AACA,mD;AACA,6B;;AAEA,4D;AACA,S;AACA,6C;AACA,sD;AACA,iF;AACA,iB;AACA,yE;AACA,K;AACA,I;;AAEA,qD;AACA,gD;AACA,6C;AACA,uC;AACA,mD;AACA,uB;AACA,2C;AACA,sB;AACA,kB;AACA,4C;AACA,2C;AACA,sB;AACA,iB;AACA,yE;AACA,2C;AACA,wB;AACA,wB;AACA,qB;;;AAGA,mE;AACA,6E;AACA,8E;AACA,W;AACA,sC;AACA,sB;AACA,sB;AACA,iB;AACA,G;;AAEA,0D;AACA,uD;AACA,S;AACA,4B;AACA,mB;AACA,+E;AACA,oD;AACA,mC;AACA,mB;AACA,mC;AACA,4D;AACA,2C;AACA,uC;AACA,yB;AACA,oC;AACA,W;AACA,K;AACA,I;;AAEA,iG;AACA,4D;AACA,oH;AACA,6C;AACA,uD;AACA,uE;AACA,qF;AACA,gF;AACA,4B;AACA,qF;AACA,mD;AACA,iD;AACA,6B;AACA,2B;AACA,gD;;AAEA,e;AACA,+D;AACA,G","sourcesContent":["Tinytest.add(\"check - check\", function (test) {\n  var matches = function (value, pattern) {\n    var error;\n    try {\n      check(value, pattern);\n    } catch (e) {\n      error = e;\n    }\n    test.isFalse(error);\n    test.isTrue(Match.test(value, pattern));\n  };\n  var fails = function (value, pattern) {\n    var error;\n    try {\n      check(value, pattern);\n    } catch (e) {\n      error = e;\n    }\n    test.isTrue(error);\n    test.instanceOf(error, Match.Error);\n    test.isFalse(Match.test(value, pattern));\n  };\n\n  // Atoms.\n  var pairs = [\n    [\"foo\", String],\n    [\"\", String],\n    [0, Number],\n    [42.59, Number],\n    [NaN, Number],\n    [Infinity, Number],\n    [true, Boolean],\n    [false, Boolean],\n    [undefined, undefined],\n    [null, null]\n  ];\n  _.each(pairs, function (pair) {\n    matches(pair[0], Match.Any);\n    _.each([String, Number, Boolean, undefined, null], function (type) {\n      if (type === pair[1]) {\n        matches(pair[0], type);\n        matches(pair[0], Match.Optional(type));\n        matches(undefined, Match.Optional(type));\n        matches(pair[0], Match.Where(function () {\n          check(pair[0], type);\n          return true;\n        }));\n        matches(pair[0], Match.Where(function () {\n          try {\n            check(pair[0], type);\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }));\n      } else {\n        fails(pair[0], type);\n        matches(pair[0], Match.OneOf(type, pair[1]));\n        matches(pair[0], Match.OneOf(pair[1], type));\n        fails(pair[0], Match.Where(function () {\n          check(pair[0], type);\n          return true;\n        }));\n        fails(pair[0], Match.Where(function () {\n          try {\n            check(pair[0], type);\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }));\n      }\n      fails(pair[0], [type]);\n      fails(pair[0], Object);\n    });\n  });\n  fails(true, Match.OneOf(String, Number, undefined, null, [Boolean]));\n  fails(new String(\"foo\"), String);\n  fails(new Boolean(true), Boolean);\n  fails(new Number(123), Number);\n\n  matches([1, 2, 3], [Number]);\n  matches([], [Number]);\n  fails([1, 2, 3, \"4\"], [Number]);\n  fails([1, 2, 3, [4]], [Number]);\n  matches([1, 2, 3, \"4\"], [Match.OneOf(Number, String)]);\n\n  matches({}, Object);\n  matches({}, {});\n  matches({foo: 42}, Object);\n  fails({foo: 42}, {});\n  matches({a: 1, b:2}, {b: Number, a: Number});\n  fails({a: 1, b:2}, {b: Number});\n  matches({a: 1, b:2}, Match.ObjectIncluding({b: Number}));\n  fails({a: 1, b:2}, Match.ObjectIncluding({b: String}));\n  fails({a: 1, b:2}, Match.ObjectIncluding({c: String}));\n  fails({}, {a: Number});\n  matches({}, {a: Match.Optional(Number)});\n  matches({a: 1}, {a: Match.Optional(Number)});\n  fails({a: true}, {a: Match.Optional(Number)});\n  // Match.Optional means \"or undefined\" at the top level but \"or absent\" in\n  // objects.\n  fails({a: undefined}, {a: Match.Optional(Number)});\n\n  matches(/foo/, RegExp);\n  fails(/foo/, String);\n  matches(new Date, Date);\n  fails(new Date, Number);\n  matches(EJSON.newBinary(42), Match.Where(EJSON.isBinary));\n  fails([], Match.Where(EJSON.isBinary));\n\n  matches(42, Match.Where(function (x) { return x % 2 === 0; }));\n  fails(43, Match.Where(function (x) { return x % 2 === 0; }));\n\n  matches({\n    a: \"something\",\n    b: [\n      {x: 42, k: null},\n      {x: 43, k: true, p: [\"yay\"]}\n    ]\n  }, {a: String, b: [Match.ObjectIncluding({\n    x: Number,\n    k: Match.OneOf(null, Boolean)})]});\n\n\n  // Match.Integer\n  matches(-1, Match.Integer);\n  matches(0, Match.Integer);\n  matches(1, Match.Integer);\n  matches(-2147483648, Match.Integer); // INT_MIN\n  matches(2147483647, Match.Integer); // INT_MAX\n  fails(123.33, Match.Integer);\n  fails(.33, Match.Integer);\n  fails(1.348192308491824e+23, Match.Integer);\n  fails(NaN, Match.Integer);\n  fails(Infinity, Match.Integer);\n  fails(-Infinity, Match.Integer);\n  fails({}, Match.Integer);\n  fails([], Match.Integer);\n  fails(function () {}, Match.Integer);\n  fails(new Date, Match.Integer);\n\n  // Test that \"arguments\" is treated like an array.\n  var argumentsMatches = function () {\n    matches(arguments, [Number]);\n  };\n  argumentsMatches();\n  argumentsMatches(1);\n  argumentsMatches(1, 2);\n  var argumentsFails = function () {\n    fails(arguments, [Number]);\n  };\n  argumentsFails(\"123\");\n  argumentsFails(1, \"23\");\n});\n\nTinytest.add(\"check - argument checker\", function (test) {\n  var checksAllArguments = function (f /*arguments*/) {\n    Match._failIfArgumentsAreNotAllChecked(\n      f, {}, _.toArray(arguments).slice(1), \"test\");\n  };\n  checksAllArguments(function () {});\n  checksAllArguments(function (x) {check(x, Match.Any);}, undefined);\n  checksAllArguments(function (x) {check(x, Match.Any);}, null);\n  checksAllArguments(function (x) {check(x, Match.Any);}, false);\n  checksAllArguments(function (x) {check(x, Match.Any);}, true);\n  checksAllArguments(function (x) {check(x, Match.Any);}, 0);\n  checksAllArguments(function (a, b, c) {\n    check(a, String);\n    check(b, Boolean);\n    check(c, Match.Optional(Number));\n  }, \"foo\", true);\n  checksAllArguments(function () {\n    check(arguments, [Number]);\n  }, 1, 2, 4);\n  checksAllArguments(function(x) {\n    check(x, Number);\n    check(_.toArray(arguments).slice(1), [String]);\n  }, 1, \"foo\", \"bar\", \"baz\");\n\n  var doesntCheckAllArguments = function (f /*arguments*/) {\n    try {\n      Match._failIfArgumentsAreNotAllChecked(\n        f, {}, _.toArray(arguments).slice(1), \"test\");\n      test.fail({message: \"expected _failIfArgumentsAreNotAllChecked to throw\"});\n    } catch (e) {\n      test.equal(e.message, \"Did not check() all arguments during test\");\n    }\n  };\n\n  doesntCheckAllArguments(function () {}, undefined);\n  doesntCheckAllArguments(function () {}, null);\n  doesntCheckAllArguments(function () {}, 1);\n  doesntCheckAllArguments(function () {\n    check(_.toArray(arguments).slice(1), [String]);\n  }, 1, \"asdf\", \"foo\");\n  doesntCheckAllArguments(function (x, y) {\n    check(x, Boolean);\n  }, true, false);\n  // One \"true\" check doesn't count for all.\n  doesntCheckAllArguments(function (x, y) {\n    check(x, Boolean);\n  }, true, true);\n  // For non-primitives, we really do require that each arg gets checked.\n  doesntCheckAllArguments(function (x, y) {\n    check(x, [Boolean]);\n    check(x, [Boolean]);\n  }, [true], [true]);\n\n\n  // In an ideal world this test would fail, but we currently can't\n  // differentiate between \"two calls to check x, both of which are true\" and\n  // \"check x and check y, both of which are true\" (for any interned primitive\n  // type).\n  checksAllArguments(function (x, y) {\n    check(x, Boolean);\n    check(x, Boolean);\n  }, true, true);\n});\n\nTinytest.add(\"check - Match error path\", function (test) {\n  var match = function (value, pattern, expectedPath) {\n    try {\n      check(value, pattern);\n    } catch (err) {\n      // XXX just for FF 3.6, its JSON stringification prefers \"\\u000a\" to \"\\n\"\n      err.path = err.path.replace(/\\\\u000a/, \"\\\\n\");\n      if (err.path != expectedPath)\n        test.fail({\n          type: \"match-error-path\",\n          message: \"The path of Match.Error doesn't match.\",\n          pattern: JSON.stringify(pattern),\n          value: JSON.stringify(value),\n          path: err.path,\n          expectedPath: expectedPath\n        });\n    }\n  };\n\n  match({ foo: [ { bar: 3 }, {bar: \"something\"} ] }, { foo: [ { bar: Number } ] }, \"foo[1].bar\");\n  // Complicated case with arrays, $, whitespace and quotes!\n  match([{ $FoO: { \"bar baz\\n\\\"'\": 3 } }], [{ $FoO: { \"bar baz\\n\\\"'\": String } }], \"[0].$FoO[\\\"bar baz\\\\n\\\\\\\"'\\\"]\");\n  // Numbers only, can be accessed w/o quotes\n  match({ \"1231\": 123 }, { \"1231\": String }, \"[1231]\");\n  match({ \"1234abcd\": 123 }, { \"1234abcd\": String }, \"[\\\"1234abcd\\\"]\");\n  match({ $set: { people: \"nice\" } }, { $set: { people: [String] } }, \"$set.people\");\n  match({ _underscore: \"should work\" }, { _underscore: Number }, \"_underscore\");\n  // Nested array looks nice\n  match([[[\"something\", \"here\"], []], [[\"string\", 123]]], [[[String]]], \"[1][0][1]\");\n  // Object nested in arrays should look nice, too!\n  match([[[{ foo: \"something\" }, { foo: \"here\"}],\n          [{ foo: \"asdf\" }]],\n         [[{ foo: 123 }]]],\n        [[[{ foo: String }]]], \"[1][0][0].foo\");\n\n  // JS keyword\n  match({ \"return\": 0 }, { \"return\": String }, \"[\\\"return\\\"]\");\n});\n\n"]}