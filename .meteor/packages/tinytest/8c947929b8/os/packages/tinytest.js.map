{"version":3,"file":"/packages/tinytest.js","sources":["tinytest/tinytest.js","tinytest/model.js","tinytest/tinytest_server.js"],"names":[],"mappings":";;;;;;;;AAAA,gF;AACA,gF;AACA,gF;;AAEA,8E;AACA,kB;AACA,6B;AACA,yB;AACA,iC;AACA,8B;AACA,uC;AACA,iC;AACA,wB;AACA,E;;AAEA,qC;AACA,sB;AACA,oB;AACA,0B;AACA,Y;AACA,uB;AACA,iC;AACA,oC;AACA,iD;AACA,qC;AACA,K;AACA,qB;AACA,I;;AAEA,4B;AACA,oB;AACA,kC;AACA,I;;AAEA,wB;AACA,oB;;AAEA,kC;AACA,6D;AACA,+B;AACA,2C;AACA,K;;AAEA,oC;AACA,4B;AACA,kD;AACA,8B;AACA,iB;AACA,oC;AACA,8E;AACA,O;AACA,iC;AACA,K;AACA,4B;AACA,4B;;AAEA,2E;AACA,a;AACA,kC;AACA,2D;AACA,oE;AACA,0B;AACA,mC;AACA,4B;AACA,uD;AACA,mD;AACA,6B;AACA,oE;AACA,mE;AACA,sD;AACA,6C;AACA,2C;AACA,gB;AACA,S;AACA,O;AACA,K;;AAEA,kB;AACA,kE;AACA,qB;AACA,4E;AACA,qD;AACA,qD;AACA,O;AACA,mC;AACA,8B;AACA,I;;AAEA,qE;AACA,kE;AACA,I;AACA,oE;AACA,kE;AACA,mE;AACA,yC;AACA,mC;AACA,gC;AACA,I;;AAEA,kE;AACA,e;AACA,sB;AACA,mB;AACA,I;;AAEA,mE;;AAEA,gD;AACA,oD;AACA,oE;AACA,2E;AACA,O;;AAEA,gB;AACA,6C;AACA,wE;AACA,oC;AACA,0B;AACA,2B;AACA,qF;AACA,oF;AACA,oF;AACA,qF;AACA,gD;AACA,0C;AACA,sF;AACA,sF;AACA,4C;AACA,yF;AACA,sE;AACA,iD;AACA,2C;AACA,O;AACA,Y;AACA,+C;AACA,K;;AAEA,4B;AACA,wD;AACA,kG;AACA,U;AACA,gB;AACA,I;;AAEA,kD;AACA,gD;AACA,I;;AAEA,qC;AACA,6B;AACA,gB;AACA,Q;AACA,8D;AACA,I;;AAEA,+C;AACA,4B;AACA,gB;AACA,Q;AACA,mD;AACA,6D;AACA,I;;AAEA,qE;AACA,mE;AACA,sE;AACA,kE;AACA,6C;AACA,I;AACA,qB;AACA,sC;AACA,kE;AACA,oE;AACA,kC;AACA,0B;;AAEA,+B;AACA,qC;AACA,oB;AACA,Q;AACA,wC;AACA,qC;AACA,4C;AACA,Q;AACA,4C;AACA,2B;AACA,Q;AACA,2E;;AAEA,S;AACA,U;AACA,yB;AACA,yB;AACA,K;;AAEA,oC;AACA,yC;AACA,Q;AACA,kC;AACA,I;;AAEA,6B;AACA,U;AACA,gB;AACA,Q;AACA,8C;AACA,I;;AAEA,8B;AACA,U;AACA,8C;AACA,Q;AACA,gB;AACA,I;;AAEA,6B;AACA,mB;AACA,gB;AACA,Q;AACA,8C;AACA,I;;AAEA,gC;AACA,mB;AACA,8C;AACA,Q;AACA,gB;AACA,I;;AAEA,kC;AACA,wB;AACA,gB;AACA,Q;AACA,mD;AACA,I;;AAEA,4B;AACA,iB;AACA,gB;AACA,Q;AACA,6C;AACA,I;;AAEA,4B;AACA,qB;AACA,2B;AACA,+D;AACA,mC;AACA,oB;AACA,mC;AACA,wC;AACA,gC;AACA,sB;AACA,gB;AACA,S;AACA,Q;AACA,6D;AACA,a;AACA,gB;AACA,U;AACA,yE;AACA,K;AACA,I;;AAEA,kD;AACA,2C;AACA,uC;AACA,gB;AACA,Q;AACA,2D;AACA,sC;AACA,G;;AAEA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,yC;AACA,kB;AACA,mB;AACA,mB;AACA,8B;;AAEA,wD;AACA,+C;AACA,K;AACA,mC;AACA,gC;AACA,6B;AACA,E;;AAEA,8B;AACA,iE;AACA,qE;AACA,wD;AACA,oE;AACA,oB;;AAEA,0B;AACA,oC;AACA,sB;AACA,8D;AACA,oD;AACA,qB;AACA,O;AACA,uB;AACA,kB;AACA,M;;AAEA,uC;AACA,8E;AACA,6E;AACA,2D;AACA,oB;AACA,+C;AACA,wB;AACA,M;;AAEA,2D;AACA,oD;AACA,2D;AACA,yD;AACA,yD;;AAEA,8B;AACA,W;AACA,yB;AACA,0C;AACA,+B;AACA,2B;AACA,a;AACA,gB;AACA,6B;AACA,6B;AACA,yB;AACA,S;AACA,mB;AACA,2B;AACA,yB;AACA,O;AACA,O;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,2B;AACA,kB;AACA,kB;AACA,0B;AACA,E;;AAEA,iC;AACA,4B;AACA,oB;AACA,gC;AACA,sB;AACA,2E;AACA,2B;AACA,iC;AACA,kC;AACA,I;;AAEA,8C;AACA,oB;AACA,mD;AACA,G;AACA,G;;AAEA,Y;AACA,8B;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,oD;AACA,kB;AACA,yB;AACA,2B;AACA,gC;AACA,sC;AACA,sD;AACA,0C;AACA,yB;AACA,K;AACA,E;;AAEA,6B;;AAEA,qC;AACA,oB;AACA,uD;AACA,gE;AACA,qB;AACA,O;AACA,K;AACA,gB;AACA,I;;AAEA,wD;AACA,oB;AACA,gC;AACA,4C;AACA,iC;AACA,qB;AACA,kC;AACA,sB;AACA,wB;AACA,gD;AACA,gE;AACA,mC;AACA,+B;AACA,yB;;AAEA,8D;AACA,qC;AACA,4B;AACA,4B;AACA,oB;AACA,uD;AACA,qD;AACA,W;AACA,W;;AAEA,mC;AACA,yB;AACA,Y;AACA,iC;AACA,K;AACA,I;;AAEA,8B;AACA,oB;AACA,4D;AACA,qE;AACA,gE;AACA,sB;AACA,8B;AACA,2C;AACA,6B;AACA,sC;AACA,oC;AACA,8B;AACA,mC;AACA,gD;AACA,oB;;AAEA,8B;AACA,mB;AACA,Y;AACA,yB;;AAEA,0C;AACA,mC;AACA,6B;AACA,iD;AACA,kB;AACA,yB;AACA,gD;AACA,2B;AACA,W;AACA,U;;AAEA,kB;AACA,S;AACA,K;AACA,I;;AAEA,+D;AACA,iE;AACA,yC;AACA,wC;AACA,oB;AACA,+C;AACA,c;AACA,4D;AACA,kD;AACA,I;;AAEA,mC;AACA,oB;AACA,c;AACA,8E;AACA,Q;AACA,sB;AACA,mB;AACA,gC;AACA,2B;AACA,oB;AACA,O;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,c;;AAEA,sC;AACA,gD;AACA,E;;AAEA,2C;AACA,sD;AACA,E;;AAEA,+D;AACA,+D;AACA,2D;AACA,4C;AACA,E;AACA,kE;AACA,4D;AACA,0B;AACA,E;;AAEA,gE;AACA,mE;AACA,qC;AACA,E;AACA,+D;AACA,gD;AACA,oC;AACA,E;;;;;;;;;;;;;;;;;;;ACjhBA,wE;AACA,oE;;;;;;;;;;;;;;;;;;;ACDA,kC;AACA,uB;AACA,uB;;AAEA,wE;AACA,uB;AACA,kB;AACA,mC;AACA,kC;AACA,M;AACA,oC;AACA,2B;AACA,iE;AACA,K;AACA,oC;AACA,0D;AACA,qC;AACA,U;AACA,+D;AACA,G;AACA,e;AACA,G;;AAEA,gB;AACA,gD;AACA,yB;AACA,gD;AACA,mB;;AAEA,qC;AACA,mC;AACA,4D;AACA,4B;;AAEA,8B;;AAEA,sC;AACA,4B;AACA,iE;AACA,oF;AACA,wB;AACA,O;AACA,iC;AACA,sB;AACA,gC;AACA,sD;AACA,2E;AACA,S;AACA,uC;AACA,8C;AACA,M;;AAEA,iC;AACA,yB;AACA,M;;AAEA,yD;;AAEA,kB;AACA,I;AACA,6C;AACA,yB;AACA,oD;AACA,qE;AACA,sB;AACA,oB;AACA,O;AACA,gC;AACA,gC;AACA,G;AACA,G","sourcesContent":["/******************************************************************************/\n/* TestCaseResults                                                            */\n/******************************************************************************/\n\nTestCaseResults = function (test_case, onEvent, onException, stop_at_offset) {\n  var self = this;\n  self.test_case = test_case;\n  self.onEvent = onEvent;\n  self.expecting_failure = false;\n  self.current_fail_count = 0;\n  self.stop_at_offset = stop_at_offset;\n  self.onException = onException;\n  self.id = Random.id();\n};\n\n_.extend(TestCaseResults.prototype, {\n  ok: function (doc) {\n    var self = this;\n    var ok = {type: \"ok\"};\n    if (doc)\n      ok.details = doc;\n    if (self.expecting_failure) {\n      ok.details = ok.details || {};\n      ok.details[\"was_expecting_failure\"] = true;\n      self.expecting_failure = false;\n    }\n    self.onEvent(ok);\n  },\n\n  expect_fail: function () {\n    var self = this;\n    self.expecting_failure = true;\n  },\n\n  fail: function (doc) {\n    var self = this;\n\n    if (typeof doc === \"string\") {\n      // Some very old code still tries to call fail() with a\n      // string. Don't do this!\n      doc = { type: \"fail\", message: doc };\n    }\n\n    if (self.stop_at_offset === 0) {\n      if (Meteor.isClient) {\n        // Only supported on the browser for now..\n        var now = (+new Date);\n        debugger;\n        if ((+new Date) - now < 100)\n          alert(\"To use this feature, first enable your browser's debugger.\");\n      }\n      self.stop_at_offset = null;\n    }\n    if (self.stop_at_offset)\n      self.stop_at_offset--;\n\n    // Get filename and line number of failure if we're using v8 (Chrome or\n    // Node).\n    if (Error.captureStackTrace) {\n      var savedPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = function(_, stack){ return stack; };\n      var err = new Error;\n      Error.captureStackTrace(err);\n      var stack = err.stack;\n      Error.prepareStackTrace = savedPrepareStackTrace;\n      for (var i = stack.length - 1; i >= 0; --i) {\n        var frame = stack[i];\n        // Heuristic: use the OUTERMOST line which is in a :tests.js\n        // file (this is less likely to be a test helper function).\n        if (frame.getFileName().match(/:tests\\.js/)) {\n          doc.filename = frame.getFileName();\n          doc.line = frame.getLineNumber();\n          break;\n        }\n      }\n    }\n\n    self.onEvent({\n        type: (self.expecting_failure ? \"expected_fail\" : \"fail\"),\n        details: doc,\n        cookie: {name: self.test_case.name, offset: self.current_fail_count,\n                 groupPath: self.test_case.groupPath,\n                 shortName: self.test_case.shortName}\n    });\n    self.expecting_failure = false;\n    self.current_fail_count++;\n  },\n\n  // Call this to fail the test with an exception. Use this to record\n  // exceptions that occur inside asynchronous callbacks in tests.\n  //\n  // It should only be used with asynchronous tests, and if you call\n  // this function, you should make sure that (1) the test doesn't\n  // call its callback (onComplete function); (2) the test function\n  // doesn't directly raise an exception.\n  exception: function (exception) {\n    this.onException(exception);\n  },\n\n  // returns a unique ID for this test run, for convenience use by\n  // your tests\n  runId: function () {\n    return this.id;\n  },\n\n  // === Following patterned after http://vowsjs.org/#reference ===\n\n  // XXX eliminate 'message' and 'not' arguments\n  equal: function (actual, expected, message, not) {\n    /* If expected is a DOM node, do a literal '===' comparison with\n     * actual. Otherwise do a deep comparison, as implemented by _.isEqual.\n     */\n\n    var matched;\n    // XXX remove cruft specific to liverange\n    if (typeof expected === \"object\" && expected && expected.nodeType) {\n      matched = expected === actual;\n      expected = \"[Node]\";\n      actual = \"[Unknown]\";\n    } else if (typeof Uint8Array !== 'undefined' && expected instanceof Uint8Array) {\n      // I have no idea why but _.isEqual on Chrome horks completely on Uint8Arrays.\n      // and the symptom is the chrome renderer taking up an entire CPU and freezing\n      // your web page, but not pausing anywhere in _.isEqual.  I don't understand it\n      // but we fall back to a manual comparison\n      if (!(actual instanceof Uint8Array))\n        this.fail({type: \"assert_equal\", message: \"found object is not a typed array\",\n                   expected: \"A typed array\", actual: actual.constructor.toString()});\n      if (expected.length !== actual.length)\n        this.fail({type: \"assert_equal\", message: \"lengths of typed arrays do not match\",\n                   expected: expected.length, actual: actual.length});\n      for (var i = 0; i < expected.length; i++) {\n        this.equal(actual[i], expected[i]);\n      }\n    } else {\n      matched = EJSON.equals(expected, actual);\n    }\n\n    if (matched === !!not) {\n      this.fail({type: \"assert_equal\", message: message,\n                 expected: JSON.stringify(expected), actual: JSON.stringify(actual), not: !!not});\n    } else\n      this.ok();\n  },\n\n  notEqual: function (actual, expected, message) {\n    this.equal(actual, expected, message, true);\n  },\n\n  instanceOf: function (obj, klass) {\n    if (obj instanceof klass)\n      this.ok();\n    else\n      this.fail({type: \"instanceOf\"}); // XXX what other data?\n  },\n\n  matches: function (actual, regexp, message) {\n    if (regexp.test(actual))\n      this.ok();\n    else\n      this.fail({type: \"matches\", message: message,\n                 actual: actual, regexp: regexp.toString()});\n  },\n\n  // XXX nodejs assert.throws can take an expected error, as a class,\n  // regular expression, or predicate function.  However, with its \n  // implementation if a constructor (class) is passed in and `actual`\n  // fails the instanceof test, the constructor is then treated as\n  // a predicate and called with `actual` (!)\n  //\n  // expected can be:\n  //  undefined: accept any exception.\n  //  regexp: accept an exception with message passing the regexp.\n  //  function: call the function as a predicate with the exception.\n  throws: function (f, expected) {\n    var actual, predicate;\n\n    if (expected === undefined)\n      predicate = function (actual) {\n        return true;\n      };\n    else if (expected instanceof RegExp)\n      predicate = function (actual) {\n        return expected.test(actual.message)\n      };\n    else if (typeof expected === 'function')\n      predicate = expected;\n    else\n      throw new Error('expected should be a predicate function or regexp');\n\n    try {\n      f();\n    } catch (exception) {\n      actual = exception;\n    }\n\n    if (actual && predicate(actual))\n      this.ok({message: actual.message});\n    else\n      this.fail({type: \"throws\"});\n  },\n\n  isTrue: function (v, msg) {\n    if (v)\n      this.ok();\n    else\n      this.fail({type: \"true\", message: msg});\n  },\n\n  isFalse: function (v, msg) {\n    if (v)\n      this.fail({type: \"true\", message: msg});\n    else\n      this.ok();\n  },\n\n  isNull: function (v, msg) {\n    if (v === null)\n      this.ok();\n    else\n      this.fail({type: \"null\", message: msg});\n  },\n\n  isNotNull: function (v, msg) {\n    if (v === null)\n      this.fail({type: \"true\", message: msg});\n    else\n      this.ok();\n  },\n\n  isUndefined: function (v, msg) {\n    if (v === undefined)\n      this.ok();\n    else\n      this.fail({type: \"undefined\", message: msg});\n  },\n\n  isNaN: function (v, msg) {\n    if (isNaN(v))\n      this.ok();\n    else\n      this.fail({type: \"NaN\", message: msg});\n  },\n\n  include: function (s, v) {\n    var pass = false;\n    if (s instanceof Array)\n      pass = _.any(s, function(it) {return _.isEqual(v, it);});\n    else if (typeof s === \"object\")\n      pass = v in s;\n    else if (typeof s === \"string\")\n      for (var i = 0; i < s.length; i++)\n        if (s.charAt(i) === v) {\n          pass = true;\n          break;\n        }\n    else\n      /* fail -- not something that contains other things */;\n    if (pass)\n      this.ok();\n    else {\n      this.fail({type: \"include\", sequence: s, should_contain_value: v});\n    }\n  },\n\n  // XXX should change to lengthOf to match vowsjs\n  length: function (obj, expected_length) {\n    if (obj.length === expected_length)\n      this.ok();\n    else\n      this.fail({type: \"length\", expected: expected_length,\n                 actual: obj.length});\n  }\n\n});\n\n/******************************************************************************/\n/* TestCase                                                                   */\n/******************************************************************************/\n\nTestCase = function (name, func, async) {\n  var self = this;\n  self.name = name;\n  self.func = func;\n  self.async = async || false;\n\n  var nameParts = _.map(name.split(\" - \"), function(s) {\n    return s.replace(/^\\s*|\\s*$/g, \"\"); // trim\n  });\n  self.shortName = nameParts.pop();\n  nameParts.unshift(\"tinytest\");\n  self.groupPath = nameParts;\n};\n\n_.extend(TestCase.prototype, {\n  // Run the test asynchronously, delivering results via onEvent;\n  // then call onComplete() on success, or else onException(e) if the\n  // test raised (or voluntarily reported) an exception.\n  run: function (onEvent, onComplete, onException, stop_at_offset) {\n    var self = this;\n\n    var completed = false;\n    var markComplete = function () {\n      if (completed) {\n        Meteor._debug(\"*** Test error -- test '\" + self.name +\n                      \"' returned multiple times.\");\n        return false;\n      }\n      completed = true;\n      return true;\n    };\n\n    var wrappedOnEvent = function (e) {\n      // If this trace prints, it means you ran some test.* function after the\n      // test finished! Another symptom will be that the test will display as\n      // \"waiting\" even when it counts as passed or failed.\n      if (completed)\n        console.trace(\"event after complete!\");\n      return onEvent(e);\n    };\n\n    var results = new TestCaseResults(self, wrappedOnEvent,\n                                      function (e) {\n                                        if (markComplete())\n                                          onException(e);\n                                      }, stop_at_offset);\n\n    Meteor.defer(function () {\n      try {\n        if (self.async) {\n          self.func(results, function () {\n            if (markComplete())\n              onComplete();\n          });\n        } else {\n          self.func(results);\n          if (markComplete())\n            onComplete();\n        }\n      } catch (e) {\n        if (markComplete())\n          onException(e);\n      }\n    });\n  }\n});\n\n/******************************************************************************/\n/* TestManager                                                                */\n/******************************************************************************/\n\nTestManager = function () {\n  var self = this;\n  self.tests = {};\n  self.ordered_tests = [];\n};\n\n_.extend(TestManager.prototype, {\n  addCase: function (test) {\n    var self = this;\n    if (test.name in self.tests)\n      throw new Error(\n        \"Every test needs a unique name, but there are two tests named '\" +\n          test.name + \"'\");\n    self.tests[test.name] = test;\n    self.ordered_tests.push(test);\n  },\n\n  createRun: function (onReport, pathPrefix) {\n    var self = this;\n    return new TestRun(self, onReport, pathPrefix);\n  }\n});\n\n// singleton\nTestManager = new TestManager;\n\n/******************************************************************************/\n/* TestRun                                                                    */\n/******************************************************************************/\n\nTestRun = function (manager, onReport, pathPrefix) {\n  var self = this;\n  self.manager = manager;\n  self.onReport = onReport;\n  self.next_sequence_number = 0;\n  self._pathPrefix = pathPrefix || [];\n  _.each(self.manager.ordered_tests, function (test) {\n    if (self._prefixMatch(test.groupPath))\n      self._report(test);\n  });\n};\n\n_.extend(TestRun.prototype, {\n\n  _prefixMatch: function (testPath) {\n    var self = this;\n    for (var i = 0; i < self._pathPrefix.length; i++) {\n      if (!testPath[i] || self._pathPrefix[i] !== testPath[i]) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  _runOne: function (test, onComplete, stop_at_offset) {\n    var self = this;\n    var startTime = (+new Date);\n    if (self._prefixMatch(test.groupPath)) {\n      test.run(function (event) {\n        /* onEvent */\n        self._report(test, event);\n      }, function () {\n        /* onComplete */\n        var totalTime = (+new Date) - startTime;\n        self._report(test, {type: \"finish\", timeMs: totalTime});\n        onComplete && onComplete();\n      }, function (exception) {\n        /* onException */\n\n        // XXX you want the \"name\" and \"message\" fields on the\n        // exception, to start with..\n        self._report(test, {\n          type: \"exception\",\n          details: {\n            message: exception.message, // XXX empty???\n            stack: exception.stack // XXX portability\n          }\n        });\n\n        onComplete && onComplete();\n      }, stop_at_offset);\n    } else {\n      onComplete && onComplete();\n    }\n  },\n\n  run: function (onComplete) {\n    var self = this;\n    // create array of arrays of tests; synchronous tests in\n    // different groups are run in parallel on client, async tests or\n    // tests in different groups are run in sequence, as are all\n    // tests on server\n    var testGroups = _.values(\n      _.groupBy(self.manager.ordered_tests,\n                function(t) {\n                  if (Meteor.isServer)\n                    return \"SERVER\";\n                  if (t.async)\n                    return \"ASYNC\";\n                  return t.name.split(\" - \")[0];\n                }));\n\n    if (! testGroups.length) {\n      onComplete();\n    } else {\n      var groupsDone = 0;\n\n      _.each(testGroups, function(tests) {\n        var runNext = function () {\n          if (tests.length) {\n            self._runOne(tests.shift(), runNext);\n          } else {\n            groupsDone++;\n            if (groupsDone >= testGroups.length)\n              onComplete();\n          }\n        };\n\n        runNext();\n      });\n    }\n  },\n\n  // An alternative to run(). Given the 'cookie' attribute of a\n  // failure record, try to rerun that particular test up to that\n  // failure, and then open the debugger.\n  debug: function (cookie, onComplete) {\n    var self = this;\n    var test = self.manager.tests[cookie.name];\n    if (!test)\n      throw new Error(\"No such test '\" + cookie.name + \"'\");\n    self._runOne(test, onComplete, cookie.offset);\n  },\n\n  _report: function (test, event) {\n    var self = this;\n    if (event)\n      var events = [_.extend({sequence: self.next_sequence_number++}, event)];\n    else\n      var events = [];\n    self.onReport({\n      groupPath: test.groupPath,\n      test: test.shortName,\n      events: events\n    });\n  }\n});\n\n/******************************************************************************/\n/* Public API                                                                 */\n/******************************************************************************/\n\nTinytest = {};\n\nTinytest.add = function (name, func) {\n  TestManager.addCase(new TestCase(name, func));\n};\n\nTinytest.addAsync = function (name, func) {\n  TestManager.addCase(new TestCase(name, func, true));\n};\n\n// Run every test, asynchronously. Runs the test in the current\n// process only (if called on the server, runs the tests on the\n// server, and likewise for the client.) Report results via\n// onReport. Call onComplete when it's done.\n//\nTinytest._runTests = function (onReport, onComplete, pathPrefix) {\n  var testRun = TestManager.createRun(onReport, pathPrefix);\n  testRun.run(onComplete);\n};\n\n// Run just one test case, and stop the debugger at a particular\n// error, all as indicated by 'cookie', which will have come from a\n// failure event output by _runTests.\n//\nTinytest._debugTest = function (cookie, onReport, onComplete) {\n  var testRun = TestManager.createRun(onReport);\n  testRun.debug(cookie, onComplete);\n};\n","Meteor._ServerTestResultsSubscription = 'tinytest_results_subscription';\nMeteor._ServerTestResultsCollection = 'tinytest_results_collection';\n","var Fiber = Npm.require('fibers');\nvar handlesForRun = {};\nvar reportsForRun = {};\n\nMeteor.publish(Meteor._ServerTestResultsSubscription, function (runId) {\n  check(runId, String);\n  var self = this;\n  if (!_.has(handlesForRun, runId))\n    handlesForRun[runId] = [self];\n  else\n    handlesForRun[runId].push(self);\n  self.onStop(function () {\n    handlesForRun[runId] = _.without(handlesForRun[runId], self);\n  });\n  if (_.has(reportsForRun, runId)) {\n    self.added(Meteor._ServerTestResultsCollection, runId,\n               reportsForRun[runId]);\n  } else {\n    self.added(Meteor._ServerTestResultsCollection, runId, {});\n  }\n  self.ready();\n});\n\nMeteor.methods({\n  'tinytest/run': function (runId, pathPrefix) {\n    check(runId, String);\n    check(pathPrefix, Match.Optional([String]));\n    this.unblock();\n\n    // XXX using private API === lame\n    var path = Npm.require('path');\n    var Future = Npm.require(path.join('fibers', 'future'));\n    var future = new Future;\n\n    reportsForRun[runId] = {};\n\n    var onReport = function (report) {\n      if (! Fiber.current) {\n        Meteor._debug(\"Trying to report a test not in a fiber! \"+\n                      \"You probably forgot to wrap a callback in bindEnvironment.\");\n        console.trace();\n      }\n      var dummyKey = Random.id();\n      var fields = {};\n      fields[dummyKey] = report;\n      _.each(handlesForRun[runId], function (handle) {\n        handle.changed(Meteor._ServerTestResultsCollection, runId, fields);\n      });\n      // Save for future subscriptions.\n      reportsForRun[runId][dummyKey] = report;\n    };\n\n    var onComplete = function() {\n      future['return']();\n    };\n\n    Tinytest._runTests(onReport, onComplete, pathPrefix);\n\n    future.wait();\n  },\n  'tinytest/clearResults': function (runId) {\n    check(runId, String);\n    _.each(handlesForRun[runId], function (handle) {\n      // XXX this doesn't actually notify the client that it has been\n      // unsubscribed.\n      handle.stop();\n    });\n    delete handlesForRun[runId];\n    delete reportsForRun[runId];\n  }\n});\n"]}