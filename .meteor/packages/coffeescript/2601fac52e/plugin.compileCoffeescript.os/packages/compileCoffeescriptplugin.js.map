{"version":3,"file":"/packages/compileCoffeescript:plugin.js","sources":["compileCoffeescript/plugin/compile-coffeescript.js"],"names":[],"mappings":";;;;;;;;;;AAAA,2B;AACA,+B;AACA,0C;AACA,kC;AACA,0C;;AAEA,oD;AACA,qC;AACA,kB;AACA,iC;;AAEA,2E;AACA,W;AACA,8E;AACA,2E;AACA,6E;AACA,mC;AACA,6E;AACA,8C;AACA,kB;AACA,oB;AACA,c;AACA,4E;AACA,yE;AACA,+E;AACA,6E;AACA,8E;AACA,iC;AACA,8E;AACA,6E;AACA,2E;AACA,0B;;AAEA,0C;AACA,wB;AACA,8C;AACA,e;AACA,e;;AAEA,2E;AACA,6E;AACA,+D;AACA,qC;AACA,e;;AAEA,yE;AACA,2D;AACA,kB;AACA,oC;AACA,wC;AACA,qB;AACA,c;AACA,6E;AACA,O;AACA,M;;AAEA,oC;AACA,uC;AACA,2B;AACA,uD;AACA,Y;AACA,6E;AACA,0E;AACA,2B;AACA,wB;AACA,U;AACA,2B;AACA,K;AACA,U;AACA,G;;AAEA,0B;AACA,E;;AAEA,oD;AACA,4C;;AAEA,8E;AACA,qE;AACA,4E;AACA,0E;AACA,6E;AACA,8E;AACA,+E;AACA,+E;AACA,c;AACA,I;AACA,oE;AACA,kF;AACA,gD;AACA,sD;;AAEA,4E;AACA,e;AACA,wF;AACA,gB;AACA,+E;AACA,4E;AACA,yE;AACA,8D;AACA,uC;AACA,Y;AACA,yE;AACA,gF;AACA,yD;AACA,4D;AACA,oB;AACA,K;AACA,K;AACA,U;AACA,mB;AACA,4C;AACA,I;AACA,E;;AAEA,kD;AACA,mD;AACA,iD;;AAEA,iB;AACA,e;AACA,oC;AACA,2B;AACA,2B;AACA,oB;AACA,4E;AACA,iB;AACA,uD;AACA,oC;AACA,0D;AACA,+C;AACA,I;;AAEA,O;AACA,iD;AACA,e;AACA,sE;AACA,oB;AACA,mC;AACA,2D;AACA,e;AACA,M;AACA,G;;AAEA,2E;AACA,oE;;AAEA,6B;AACA,qB;AACA,sC;AACA,+B;AACA,sC;AACA,K;AACA,E;;AAEA,8C;AACA,oC;AACA,C;;AAEA,gD;AACA,2D;AACA,2D","sourcesContent":["var fs = Npm.require('fs');\nvar path = Npm.require('path');\nvar coffee = Npm.require('coffee-script');\nvar _ = Npm.require('underscore');\nvar sourcemap = Npm.require('source-map');\n\nvar stripExportedVars = function (source, exports) {\n  if (!exports || _.isEmpty(exports))\n    return source;\n  var lines = source.split(\"\\n\");\n\n  // We make the following assumptions, based on the output of CoffeeScript\n  // 1.6.3.\n  //   - The var declaration in question is not indented and is the first such\n  //     var declaration.  (CoffeeScript only produces one var line at each\n  //     scope and there's only one top-level scope.)  All relevant variables\n  //     are actually on this line.\n  //   - The user hasn't used a ###-comment containing a line that looks like\n  //     a var line, to produce something like\n  //        /* bla\n  //        var foo;\n  //        */\n  //     before an actual var line.  (ie, we do NOT attempt to figure out if\n  //     we're inside a /**/ comment, which is produced by ### comments.)\n  //   - The var in question is not assigned to in the declaration, nor are any\n  //     other vars on this line. (CoffeeScript does produce some assignments\n  //     but only for internal helpers generated by CoffeeScript, and they end\n  //     up on subsequent lines.)\n  // XXX relax these assumptions by doing actual JS parsing (eg with jsparse).\n  //     I'd do this now, but there's no easy way to \"unparse\" a jsparse AST.\n  //     Or alternatively, hack the compiler to allow us to specify unbound\n  //     symbols directly.\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var match = /^var (.+)([,;])$/.exec(line);\n    if (!match)\n      continue;\n\n    // If there's an assignment on this line, we assume that there are ONLY\n    // assignments and that the var we are looking for is not declared. (Part\n    // of our strong assumption about the layout of this code.)\n    if (match[1].indexOf('=') !== -1)\n      continue;\n\n    // We want to replace the line with something no shorter, so that all\n    // records in the source map continue to point at valid\n    // characters.\n    var replaceLine = function (x) {\n      if (x.length >= lines[i].length) {\n        lines[i] = x;\n      } else {\n        lines[i] = x + new Array(1 + (lines[i].length - x.length)).join(' ');\n      }\n    };\n\n    var vars = match[1].split(', ');\n    vars = _.difference(vars, exports);\n    if (!_.isEmpty(vars)) {\n      replaceLine(\"var \" + vars.join(', ') + match[2]);\n    } else {\n      // We got rid of all the vars on this line. Drop the whole line if this\n      // didn't continue to the next line, otherwise keep just the 'var '.\n      if (match[2] === ';')\n        replaceLine('');\n      else\n        replaceLine('var');\n    }\n    break;\n  }\n\n  return lines.join('\\n');\n};\n\nvar addSharedHeader = function (source, sourceMap) {\n  var sourceMapJSON = JSON.parse(sourceMap);\n\n  // We want the symbol \"share\" to be visible to all CoffeeScript files in the\n  // package (and shared between them), but not visible to JavaScript\n  // files. (That's because we don't want to introduce two competing ways to\n  // make package-local variables into JS (\"share\" vs assigning to non-var\n  // variables).) The following hack accomplishes that: \"__coffeescriptShare\"\n  // will be visible at the package level and \"share\" at the file level.  This\n  // should work both in \"package\" mode where __coffeescriptShare will be added\n  // as a var in the package closure, and in \"app\" mode where it will end up as\n  // a global.\n  //\n  // This ends in a newline to make the source map easier to adjust.\n  var header = (\"__coffeescriptShare = typeof __coffeescriptShare === 'object' \" +\n                \"? __coffeescriptShare : {}; \" +\n                \"var share = __coffeescriptShare;\\n\");\n\n  // If the file begins with \"use strict\", we need to keep that as the first\n  // statement.\n  source = source.replace(/^(?:((['\"])use strict\\2;)\\n)?/, function (match, useStrict) {\n    if (match) {\n      // There's a \"use strict\"; we keep this as the first statement and insert\n      // our header at the end of the line that it's on. This doesn't change\n      // line numbers or the part of the line that previous may have been\n      // annotated, so we don't need to update the source map.\n      return useStrict + \"  \" + header;\n    } else {\n      // There's no use strict, so we can just add the header at the very\n      // beginning. This adds a line to the file, so we update the source map to\n      // add a single un-annotated line to the beginning.\n      sourceMapJSON.mappings = \";\" + sourceMapJSON.mappings;\n      return header;\n    }\n  });\n  return {\n    source: source,\n    sourceMap: JSON.stringify(sourceMapJSON)\n  };\n};\n\nvar handler = function (compileStep, isLiterate) {\n  var source = compileStep.read().toString('utf8');\n  var outputFile = compileStep.inputPath + \".js\";\n\n  var options = {\n    bare: true,\n    filename: compileStep.inputPath,\n    literate: !!isLiterate,\n    // Return a source map.\n    sourceMap: true,\n    // Include the original source in the source map (sourcesContent field).\n    inline: true,\n    // This becomes the \"file\" field of the source map.\n    generatedFile: \"/\" + outputFile,\n    // This becomes the \"sources\" field of the source map.\n    sourceFiles: [compileStep.pathForSourceMap]\n  };\n\n  try {\n    var output = coffee.compile(source, options);\n  } catch (e) {\n    // XXX better error handling, once the Plugin interface support it\n    throw new Error(\n      compileStep.inputPath + ':' +\n      (e.location ? (e.location.first_line + ': ') : ' ') +\n      e.message\n    );\n  }\n\n  var stripped = stripExportedVars(output.js, compileStep.declaredExports);\n  var sourceWithMap = addSharedHeader(stripped, output.v3SourceMap);\n\n  compileStep.addJavaScript({\n    path: outputFile,\n    sourcePath: compileStep.inputPath,\n    data: sourceWithMap.source,\n    sourceMap: sourceWithMap.sourceMap\n  });\n};\n\nvar literateHandler = function (compileStep) {\n  return handler(compileStep, true);\n}\n\nPlugin.registerSourceHandler(\"coffee\", handler);\nPlugin.registerSourceHandler(\"litcoffee\", literateHandler);\nPlugin.registerSourceHandler(\"coffee.md\", literateHandler);\n\n"]}