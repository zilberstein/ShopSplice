{"version":3,"file":"/packages/appcache.js","sources":["appcache/appcache-server.js"],"names":[],"mappings":";;;;;;;;AAAA,mC;AACA,2B;AACA,+B;;AAEA,qB;AACA,Y;AACA,W;AACA,a;AACA,oB;AACA,Y;AACA,O;AACA,iB;AACA,U;AACA,E;;AAEA,gC;AACA,Y;AACA,W;AACA,a;AACA,oB;AACA,O;AACA,iB;AACA,U;AACA,E;;AAEA,yB;AACA,qD;AACA,kC;AACA,G;;AAEA,mB;AACA,6B;AACA,8C;AACA,kC;AACA,6B;AACA,0C;AACA,0C;AACA,W;AACA,O;AACA,mD;AACA,wC;AACA,O;AACA,yC;AACA,4C;AACA,0D;AACA,W;AACA,O;AACA,Y;AACA,qE;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,wC;AACA,+C;AACA,E;;AAEA,gD;AACA,8B;AACA,sC;AACA,M;AACA,gB;AACA,G;;AAEA,qD;AACA,oC;AACA,kB;AACA,G;;AAEA,+D;AACA,kE;AACA,gE;AACA,mE;AACA,mE;AACA,mE;AACA,iE;AACA,oE;AACA,e;;AAEA,uD;AACA,uB;AACA,c;AACA,W;AACA,G;;AAEA,sC;;AAEA,uE;AACA,oE;AACA,mE;AACA,qD;AACA,I;AACA,qE;AACA,wD;;AAEA,8C;;AAEA,oD;AACA,+D;AACA,oE;AACA,iE;AACA,6C;;AAEA,2B;AACA,kE;AACA,sC;AACA,wC;AACA,G;;AAEA,mB;;AAEA,8B;AACA,yB;AACA,6D;AACA,sC;AACA,+C;AACA,+B;AACA,8D;AACA,oE;AACA,gD;AACA,Q;AACA,sE;AACA,gE;AACA,gB;AACA,8B;AACA,wC;;AAEA,uB;AACA,K;AACA,K;AACA,mB;;AAEA,4B;AACA,2B;AACA,oE;AACA,I;AACA,gE;AACA,qE;AACA,mE;AACA,kE;AACA,oE;AACA,uC;AACA,6D;AACA,sC;AACA,+C;AACA,8B;AACA,qD;AACA,mC;AACA,K;AACA,K;;AAEA,mB;;AAEA,2B;AACA,oE;AACA,kC;AACA,qC;AACA,S;AACA,c;AACA,4C;AACA,iD;AACA,M;AACA,0B;AACA,mC;AACA,K;AACA,I;AACA,yB;;AAEA,8C;AACA,kC;;AAEA,uD;AACA,+C;AACA,uB;AACA,G;;AAEA,4B;AACA,oB;AACA,6D;AACA,4D;AACA,iC;AACA,K;AACA,K;AACA,oC;AACA,kB;AACA,2E;AACA,iC;AACA,sD;AACA,c;AACA,8E;AACA,yE;AACA,4C;AACA,M;AACA,G;AACA,E;;AAEA,Y","sourcesContent":["var crypto = Npm.require('crypto');\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\n\nvar knownBrowsers = [\n  'android',\n  'chrome',\n  'chromium',\n  'chromeMobileIOS',\n  'firefox',\n  'ie',\n  'mobileSafari',\n  'safari'\n];\n\nvar browsersEnabledByDefault = [\n  'android',\n  'chrome',\n  'chromium',\n  'chromeMobileIOS',\n  'ie',\n  'mobileSafari',\n  'safari'\n];\n\nvar enabledBrowsers = {};\n_.each(browsersEnabledByDefault, function (browser) {\n  enabledBrowsers[browser] = true;\n});\n\nMeteor.AppCache = {\n  config: function(options) {\n    _.each(options, function (value, option) {\n      if (option === 'browsers') {\n        enabledBrowsers = {};\n        _.each(value, function (browser) {\n          enabledBrowsers[browser] = true;\n        });\n      }\n      else if (_.contains(knownBrowsers, option)) {\n        enabledBrowsers[option] = value;\n      }\n      else if (option === 'onlineOnly') {\n        _.each(value, function (urlPrefix) {\n          RoutePolicy.declare(urlPrefix, 'static-online');\n        });\n      }\n      else {\n        throw new Error('Invalid AppCache config option: ' + option);\n      }\n    });\n  }\n};\n\nvar browserEnabled = function(request) {\n  return enabledBrowsers[request.browser.name];\n};\n\nWebApp.addHtmlAttributeHook(function (request) {\n  if (browserEnabled(request))\n    return 'manifest=\"/app.manifest\"';\n  else\n    return null;\n});\n\nWebApp.connectHandlers.use(function(req, res, next) {\n  if (req.url !== '/app.manifest') {\n    return next();\n  }\n\n  // Browsers will get confused if we unconditionally serve the\n  // manifest and then disable the app cache for that browser.  If\n  // the app cache had previously been enabled for a browser, it\n  // will continue to fetch the manifest as long as it's available,\n  // even if we now are not including the manifest attribute in the\n  // app HTML.  (Firefox for example will continue to display \"this\n  // website is asking to store data on your computer for offline\n  // use\").  Returning a 404 gets the browser to really turn off the\n  // app cache.\n\n  if (!browserEnabled(WebApp.categorizeRequest(req))) {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  var manifest = \"CACHE MANIFEST\\n\\n\";\n\n  // After the browser has downloaded the app files from the server and\n  // has populated the browser's application cache, the browser will\n  // *only* connect to the server and reload the application if the\n  // *contents* of the app manifest file has changed.\n  //\n  // So to ensure that the client updates if client resources change,\n  // include a hash of client resources in the manifest.\n\n  manifest += \"# \" + WebApp.clientHash + \"\\n\";\n\n  // When using the autoupdate package, also include\n  // AUTOUPDATE_VERSION.  Otherwise the client will get into an\n  // infinite loop of reloads when the browser doesn't fetch the new\n  // app HTML which contains the new version, and autoupdate will\n  // reload again trying to get the new code.\n\n  if (Package.autoupdate) {\n    var version = Package.autoupdate.Autoupdate.autoupdateVersion;\n    if (version !== WebApp.clientHash)\n      manifest += \"# \" + version + \"\\n\";\n  }\n\n  manifest += \"\\n\";\n\n  manifest += \"CACHE:\" + \"\\n\";\n  manifest += \"/\" + \"\\n\";\n  _.each(WebApp.clientProgram.manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url)) {\n      manifest += resource.url;\n      // If the resource is not already cacheable (has a query\n      // parameter, presumably with a hash or version of some sort),\n      // put a version with a hash in the cache.\n      //\n      // Avoid putting a non-cacheable asset into the cache, otherwise\n      // the user can't modify the asset until the cache headers\n      // expire.\n      if (!resource.cacheable)\n        manifest += \"?\" + resource.hash;\n\n      manifest += \"\\n\";\n    }\n  });\n  manifest += \"\\n\";\n\n  manifest += \"FALLBACK:\\n\";\n  manifest += \"/ /\" + \"\\n\";\n  // Add a fallback entry for each uncacheable asset we added above.\n  //\n  // This means requests for the bare url (/image.png instead of\n  // /image.png?hash) will work offline. Online, however, the browser\n  // will send a request to the server. Users can remove this extra\n  // request to the server and have the asset served from cache by\n  // specifying the full URL with hash in their code (manually, with\n  // some sort of URL rewriting helper)\n  _.each(WebApp.clientProgram.manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url) &&\n        !resource.cacheable) {\n      manifest += resource.url + \" \" + resource.url +\n        \"?\" + resource.hash + \"\\n\";\n    }\n  });\n\n  manifest += \"\\n\";\n\n  manifest += \"NETWORK:\\n\";\n  // TODO adding the manifest file to NETWORK should be unnecessary?\n  // Want more testing to be sure.\n  manifest += \"/app.manifest\" + \"\\n\";\n  _.each(\n    [].concat(\n      RoutePolicy.urlPrefixesFor('network'),\n      RoutePolicy.urlPrefixesFor('static-online')\n    ),\n    function (urlPrefix) {\n      manifest += urlPrefix + \"\\n\";\n    }\n  );\n  manifest += \"*\" + \"\\n\";\n\n  // content length needs to be based on bytes\n  var body = new Buffer(manifest);\n\n  res.setHeader('Content-Type', 'text/cache-manifest');\n  res.setHeader('Content-Length', body.length);\n  return res.end(body);\n});\n\nvar sizeCheck = function() {\n  var totalSize = 0;\n  _.each(WebApp.clientProgram.manifest, function (resource) {\n    if (resource.cacheable && resource.where === 'client') {\n      totalSize += resource.size;\n    }\n  });\n  if (totalSize > 5 * 1024 * 1024) {\n    Meteor._debug(\n      \"** You are using the appcache package but the total size of the\\n\" +\n      \"** cached resources is \" +\n      (totalSize / 1024 / 1024).toFixed(1) + \"MB.\\n\" +\n      \"**\\n\" +\n      \"** This is over the recommended maximum of 5 MB and may break your\\n\" +\n      \"** app in some browsers! See http://docs.meteor.com/#appcache\\n\" +\n      \"** for more information and fixes.\\n\"\n    );\n  }\n};\n\nsizeCheck();\n"]}