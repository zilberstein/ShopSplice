{"version":3,"file":"/packages/showdown.js","sources":["showdown/showdown.js"],"names":[],"mappings":";;;;;;;;AAAA,G;AACA,iD;AACA,G;AACA,mC;AACA,G;AACA,yD;AACA,oD;AACA,G;AACA,0D;AACA,yC;AACA,G;AACA,uC;AACA,G;AACA,Y;AACA,Y;AACA,Y;AACA,G;AACA,iC;AACA,G;AACA,C;AACA,G;AACA,gE;AACA,oC;AACA,G;AACA,6D;AACA,0D;AACA,kE;AACA,gD;AACA,G;AACA,+D;AACA,+D;AACA,+D;AACA,G;AACA,6D;AACA,gE;AACA,mE;AACA,8D;AACA,gE;AACA,oD;AACA,G;AACA,+D;AACA,kE;AACA,8D;AACA,8D;AACA,qB;AACA,G;AACA,C;AACA,C;AACA,G;AACA,mB;AACA,G;AACA,qC;AACA,G;AACA,+C;AACA,0C;AACA,G;AACA,kB;AACA,G;AACA,oD;AACA,gC;AACA,G;AACA,C;AACA,C;AACA,G;AACA,sB;AACA,G;AACA,8D;AACA,e;AACA,C;AACA,G;AACA,a;AACA,G;AACA,8C;AACA,0B;AACA,G;AACA,kC;AACA,C;AACA,G;AACA,Y;AACA,G;AACA,C;AACA,mD;AACA,Y;AACA,c;AACA,mB;AACA,C;AACA,gE;AACA,0C;AACA,sB;AACA,C;AACA,C;AACA,iC;AACA,G;AACA,mE;AACA,iE;AACA,+E;AACA,+B;AACA,G;AACA,C;AACA,wE;AACA,wE;AACA,iE;AACA,e;AACA,uB;AACA,yB;AACA,8B;AACA,C;AACA,iC;AACA,iE;AACA,6D;AACA,oC;AACA,iC;AACA,C;AACA,iC;AACA,+C;AACA,sC;AACA,kC;AACA,C;AACA,6B;AACA,mD;AACA,iD;AACA,C;AACA,8D;AACA,gC;AACA,C;AACA,gC;AACA,sB;AACA,C;AACA,wD;AACA,kE;AACA,kE;AACA,iC;AACA,uC;AACA,C;AACA,mD;AACA,+B;AACA,C;AACA,6C;AACA,qC;AACA,C;AACA,8B;AACA,C;AACA,qC;AACA,C;AACA,oC;AACA,kC;AACA,C;AACA,8B;AACA,iC;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,6C;AACA,G;AACA,oE;AACA,oB;AACA,G;AACA,C;AACA,2D;AACA,C;AACA,I;AACA,4B;AACA,+D;AACA,a;AACA,oC;AACA,a;AACA,6B;AACA,a;AACA,kC;AACA,a;AACA,Q;AACA,uE;AACA,W;AACA,6B;AACA,W;AACA,a;AACA,gC;AACA,c;AACA,U;AACA,uB;AACA,I;AACA,gI;AACA,sC;AACA,0B;AACA,4E;AACA,a;AACA,qD;AACA,sD;AACA,kB;AACA,oB;AACA,8C;AACA,K;AACA,I;AACA,qD;AACA,c;AACA,I;AACA,I;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,uC;AACA,0D;AACA,oC;AACA,C;AACA,yB;AACA,wE;AACA,wE;AACA,4E;AACA,sE;AACA,gB;AACA,mH;AACA,2G;AACA,C;AACA,yC;AACA,Y;AACA,c;AACA,+C;AACA,e;AACA,a;AACA,I;AACA,4E;AACA,4C;AACA,6E;AACA,0E;AACA,C;AACA,0D;AACA,I;AACA,4B;AACA,uB;AACA,qC;AACA,sC;AACA,wB;AACA,oD;AACA,0D;AACA,oC;AACA,qC;AACA,uC;AACA,sE;AACA,wB;AACA,I;AACA,wK;AACA,C;AACA,I;AACA,kE;AACA,I;AACA,C;AACA,I;AACA,4B;AACA,uB;AACA,qC;AACA,sC;AACA,wB;AACA,oD;AACA,yD;AACA,sC;AACA,qC;AACA,uC;AACA,sE;AACA,wB;AACA,I;AACA,kK;AACA,C;AACA,4E;AACA,gD;AACA,C;AACA,I;AACA,wB;AACA,uB;AACA,0C;AACA,Y;AACA,+B;AACA,wB;AACA,mB;AACA,oC;AACA,U;AACA,4C;AACA,I;AACA,mB;AACA,I;AACA,yF;AACA,C;AACA,+C;AACA,C;AACA,I;AACA,wB;AACA,uB;AACA,0C;AACA,4C;AACA,M;AACA,qB;AACA,K;AACA,U;AACA,4C;AACA,I;AACA,mB;AACA,I;AACA,yF;AACA,C;AACA,mE;AACA,C;AACA,I;AACA,wB;AACA,M;AACA,0C;AACA,I;AACA,uB;AACA,4C;AACA,O;AACA,oB;AACA,Y;AACA,Q;AACA,K;AACA,U;AACA,4C;AACA,I;AACA,mB;AACA,I;AACA,8F;AACA,C;AACA,uE;AACA,oC;AACA,c;AACA,E;AACA,C;AACA,4C;AACA,qB;AACA,C;AACA,sB;AACA,8C;AACA,0C;AACA,E;AACA,+B;AACA,4C;AACA,E;AACA,uE;AACA,qE;AACA,E;AACA,mB;AACA,G;AACA,C;AACA,sC;AACA,G;AACA,2D;AACA,kD;AACA,G;AACA,0B;AACA,C;AACA,yB;AACA,gC;AACA,gE;AACA,gE;AACA,gE;AACA,C;AACA,wB;AACA,6B;AACA,8B;AACA,C;AACA,qE;AACA,uE;AACA,wE;AACA,sC;AACA,+B;AACA,+B;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,qC;AACA,G;AACA,qE;AACA,kD;AACA,G;AACA,C;AACA,4B;AACA,sD;AACA,uC;AACA,C;AACA,2D;AACA,4C;AACA,yB;AACA,0B;AACA,C;AACA,0D;AACA,8D;AACA,mD;AACA,4B;AACA,oC;AACA,iC;AACA,C;AACA,oB;AACA,4C;AACA,C;AACA,c;AACA,E;AACA,C;AACA,8D;AACA,G;AACA,sE;AACA,2E;AACA,G;AACA,C;AACA,iE;AACA,2D;AACA,0E;AACA,C;AACA,mD;AACA,4D;AACA,uC;AACA,c;AACA,K;AACA,C;AACA,c;AACA,E;AACA,C;AACA,kC;AACA,G;AACA,qD;AACA,G;AACA,I;AACA,0D;AACA,I;AACA,C;AACA,I;AACA,wB;AACA,oC;AACA,M;AACA,K;AACA,Q;AACA,oD;AACA,O;AACA,iC;AACA,O;AACA,K;AACA,M;AACA,C;AACA,kC;AACA,6D;AACA,C;AACA,M;AACA,wB;AACA,M;AACA,gD;AACA,2B;AACA,I;AACA,yG;AACA,C;AACA,I;AACA,gE;AACA,I;AACA,C;AACA,I;AACA,wB;AACA,oC;AACA,O;AACA,M;AACA,S;AACA,oD;AACA,O;AACA,mC;AACA,M;AACA,K;AACA,M;AACA,4B;AACA,U;AACA,uC;AACA,6B;AACA,U;AACA,gB;AACA,iC;AACA,2B;AACA,6B;AACA,oE;AACA,gC;AACA,M;AACA,I;AACA,sB;AACA,I;AACA,0H;AACA,C;AACA,I;AACA,wD;AACA,gE;AACA,yB;AACA,I;AACA,C;AACA,I;AACA,wB;AACA,qC;AACA,M;AACA,6D;AACA,M;AACA,gD;AACA,uB;AACA,I;AACA,qE;AACA,C;AACA,c;AACA,E;AACA,C;AACA,iE;AACA,+B;AACA,uB;AACA,uB;AACA,kC;AACA,gB;AACA,iB;AACA,E;AACA,kB;AACA,uB;AACA,wD;AACA,2D;AACA,I;AACA,qB;AACA,G;AACA,sC;AACA,0B;AACA,yC;AACA,+B;AACA,K;AACA,I;AACA,S;AACA,6C;AACA,2C;AACA,c;AACA,Y;AACA,wB;AACA,K;AACA,I;AACA,I;AACA,E;AACA,mC;AACA,yC;AACA,E;AACA,oB;AACA,wC;AACA,wC;AACA,yC;AACA,G;AACA,E;AACA,qC;AACA,E;AACA,gB;AACA,E;AACA,C;AACA,C;AACA,iC;AACA,G;AACA,kD;AACA,G;AACA,C;AACA,I;AACA,kE;AACA,I;AACA,C;AACA,I;AACA,wB;AACA,mC;AACA,O;AACA,6B;AACA,M;AACA,C;AACA,iC;AACA,4D;AACA,C;AACA,M;AACA,uB;AACA,M;AACA,6C;AACA,qB;AACA,I;AACA,qF;AACA,C;AACA,I;AACA,mE;AACA,iC;AACA,C;AACA,I;AACA,wB;AACA,mC;AACA,O;AACA,6B;AACA,M;AACA,gD;AACA,2B;AACA,U;AACA,sC;AACA,gC;AACA,U;AACA,e;AACA,gC;AACA,0B;AACA,4B;AACA,W;AACA,+B;AACA,K;AACA,I;AACA,qB;AACA,I;AACA,0G;AACA,C;AACA,c;AACA,E;AACA,C;AACA,gE;AACA,uB;AACA,sB;AACA,kC;AACA,gB;AACA,iB;AACA,C;AACA,yB;AACA,E;AACA,kB;AACA,uB;AACA,wD;AACA,0D;AACA,I;AACA,qB;AACA,G;AACA,sC;AACA,0B;AACA,yC;AACA,+B;AACA,K;AACA,I;AACA,S;AACA,uB;AACA,I;AACA,I;AACA,E;AACA,6C;AACA,mC;AACA,mE;AACA,C;AACA,kE;AACA,wB;AACA,C;AACA,sB;AACA,wC;AACA,wC;AACA,yC;AACA,K;AACA,E;AACA,kB;AACA,E;AACA,gB;AACA,E;AACA,C;AACA,C;AACA,kC;AACA,C;AACA,0B;AACA,a;AACA,a;AACA,M;AACA,a;AACA,a;AACA,I;AACA,mD;AACA,+G;AACA,C;AACA,mD;AACA,+G;AACA,C;AACA,uB;AACA,gB;AACA,iB;AACA,wC;AACA,S;AACA,qB;AACA,I;AACA,C;AACA,I;AACA,wB;AACA,uC;AACA,U;AACA,iC;AACA,U;AACA,kD;AACA,O;AACA,0B;AACA,I;AACA,C;AACA,4D;AACA,+B;AACA,4B;AACA,iH;AACA,M;AACA,C;AACA,wB;AACA,gD;AACA,G;AACA,c;AACA,E;AACA,C;AACA,mE;AACA,uB;AACA,C;AACA,gC;AACA,G;AACA,gE;AACA,G;AACA,C;AACA,6D;AACA,iD;AACA,e;AACA,C;AACA,0D;AACA,C;AACA,I;AACA,qB;AACA,+B;AACA,kB;AACA,+C;AACA,qD;AACA,W;AACA,K;AACA,W;AACA,kB;AACA,qD;AACA,K;AACA,W;AACA,W;AACA,iE;AACA,Y;AACA,4B;AACA,M;AACA,K;AACA,M;AACA,I;AACA,iH;AACA,C;AACA,qB;AACA,8D;AACA,kB;AACA,2D;AACA,C;AACA,qE;AACA,2D;AACA,6C;AACA,yC;AACA,E;AACA,uE;AACA,kE;AACA,oE;AACA,0C;AACA,uC;AACA,+D;AACA,kB;AACA,M;AACA,U;AACA,uH;AACA,iE;AACA,mB;AACA,kB;AACA,C;AACA,2D;AACA,qE;AACA,2D;AACA,iD;AACA,yC;AACA,0E;AACA,kB;AACA,M;AACA,G;AACA,C;AACA,8B;AACA,+B;AACA,C;AACA,c;AACA,E;AACA,C;AACA,yC;AACA,G;AACA,6E;AACA,gC;AACA,G;AACA,sE;AACA,sE;AACA,6D;AACA,I;AACA,sE;AACA,yB;AACA,I;AACA,wC;AACA,yC;AACA,sB;AACA,I;AACA,wE;AACA,wC;AACA,I;AACA,sE;AACA,oE;AACA,kE;AACA,kE;AACA,kE;AACA,iD;AACA,C;AACA,iB;AACA,C;AACA,+B;AACA,8C;AACA,C;AACA,0C;AACA,mB;AACA,C;AACA,I;AACA,gC;AACA,oC;AACA,6C;AACA,+C;AACA,0C;AACA,c;AACA,4C;AACA,yB;AACA,I;AACA,yH;AACA,oC;AACA,kB;AACA,0B;AACA,2B;AACA,C;AACA,qD;AACA,2C;AACA,K;AACA,U;AACA,gC;AACA,qC;AACA,kD;AACA,gC;AACA,K;AACA,C;AACA,sC;AACA,I;AACA,I;AACA,C;AACA,8B;AACA,wC;AACA,C;AACA,iB;AACA,kB;AACA,E;AACA,C;AACA,C;AACA,qC;AACA,G;AACA,2C;AACA,K;AACA,C;AACA,I;AACA,4B;AACA,e;AACA,mF;AACA,Q;AACA,sG;AACA,W;AACA,O;AACA,K;AACA,0D;AACA,uB;AACA,I;AACA,C;AACA,4E;AACA,e;AACA,E;AACA,yF;AACA,+B;AACA,uB;AACA,sB;AACA,G;AACA,kD;AACA,kC;AACA,uE;AACA,0E;AACA,C;AACA,8D;AACA,C;AACA,2C;AACA,I;AACA,I;AACA,C;AACA,8B;AACA,+B;AACA,C;AACA,c;AACA,E;AACA,C;AACA,iC;AACA,yC;AACA,2D;AACA,E;AACA,C;AACA,C;AACA,oC;AACA,G;AACA,0D;AACA,I;AACA,wE;AACA,gE;AACA,K;AACA,gD;AACA,K;AACA,yB;AACA,K;AACA,gE;AACA,K;AACA,6D;AACA,iE;AACA,+C;AACA,G;AACA,iE;AACA,K;AACA,8B;AACA,K;AACA,gB;AACA,K;AACA,qC;AACA,G;AACA,C;AACA,I;AACA,wB;AACA,oE;AACA,sC;AACA,kC;AACA,Y;AACA,0D;AACA,K;AACA,+B;AACA,S;AACA,yB;AACA,I;AACA,C;AACA,4D;AACA,qC;AACA,e;AACA,yD;AACA,wD;AACA,uB;AACA,mC;AACA,M;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,mC;AACA,G;AACA,+D;AACA,6D;AACA,6C;AACA,G;AACA,iD;AACA,0C;AACA,oC;AACA,C;AACA,yC;AACA,mC;AACA,mC;AACA,C;AACA,uD;AACA,kD;AACA,C;AACA,kC;AACA,M;AACA,C;AACA,S;AACA,C;AACA,gB;AACA,C;AACA,8B;AACA,M;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,yC;AACA,C;AACA,4B;AACA,2D;AACA,0B;AACA,C;AACA,mD;AACA,kB;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,sC;AACA,C;AACA,I;AACA,wB;AACA,qC;AACA,K;AACA,mD;AACA,uC;AACA,gD;AACA,uB;AACA,M;AACA,I;AACA,yB;AACA,I;AACA,C;AACA,4D;AACA,4B;AACA,gB;AACA,C;AACA,kD;AACA,iD;AACA,C;AACA,0E;AACA,C;AACA,+B;AACA,8B;AACA,C;AACA,oE;AACA,0C;AACA,I;AACA,sC;AACA,6E;AACA,oB;AACA,mC;AACA,8B;AACA,mB;AACA,oD;AACA,sC;AACA,kC;AACA,iB;AACA,Q;AACA,I;AACA,gE;AACA,M;AACA,c;AACA,E;AACA,C;AACA,C;AACA,uC;AACA,G;AACA,Y;AACA,mD;AACA,G;AACA,C;AACA,sC;AACA,kC;AACA,kC;AACA,C;AACA,oC;AACA,6B;AACA,C;AACA,I;AACA,mB;AACA,I;AACA,yB;AACA,6B;AACA,sB;AACA,C;AACA,wC;AACA,sC;AACA,uB;AACA,I;AACA,oC;AACA,6B;AACA,0C;AACA,iB;AACA,uB;AACA,I;AACA,C;AACA,G;AACA,C;AACA,I;AACA,0B;AACA,I;AACA,wB;AACA,6B;AACA,8C;AACA,gD;AACA,6C;AACA,2E;AACA,0D;AACA,I;AACA,G;AACA,C;AACA,+B;AACA,E;AACA,C;AACA,C;AACA,4C;AACA,+E;AACA,E;AACA,0E;AACA,4C;AACA,oE;AACA,E;AACA,qB;AACA,mD;AACA,E;AACA,c;AACA,E;AACA,C;AACA,C;AACA,+C;AACA,G;AACA,yB;AACA,wE;AACA,0B;AACA,G;AACA,C;AACA,yD;AACA,iC;AACA,I;AACA,8C;AACA,2D;AACA,I;AACA,uE;AACA,sE;AACA,C;AACA,2D;AACA,4E;AACA,c;AACA,E;AACA,C;AACA,C;AACA,oC;AACA,C;AACA,mF;AACA,C;AACA,0C;AACA,C;AACA,I;AACA,wB;AACA,K;AACA,gB;AACA,K;AACA,Y;AACA,O;AACA,sC;AACA,K;AACA,K;AACA,iC;AACA,I;AACA,qF;AACA,4B;AACA,4D;AACA,I;AACA,I;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,2C;AACA,G;AACA,oD;AACA,G;AACA,oE;AACA,gE;AACA,iE;AACA,G;AACA,8E;AACA,iF;AACA,4E;AACA,G;AACA,qE;AACA,6C;AACA,G;AACA,C;AACA,+C;AACA,yB;AACA,sC;AACA,8B;AACA,+D;AACA,G;AACA,C;AACA,gB;AACA,mD;AACA,gD;AACA,2B;AACA,I;AACA,C;AACA,0B;AACA,C;AACA,0C;AACA,mB;AACA,2C;AACA,iD;AACA,yB;AACA,8C;AACA,0B;AACA,wC;AACA,W;AACA,iC;AACA,iC;AACA,sB;AACA,O;AACA,I;AACA,a;AACA,K;AACA,C;AACA,qD;AACA,iF;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,6C;AACA,G;AACA,yD;AACA,G;AACA,kC;AACA,4B;AACA,yC;AACA,kD;AACA,I;AACA,I;AACA,c;AACA,E;AACA,C;AACA,C;AACA,gC;AACA,G;AACA,mD;AACA,G;AACA,C;AACA,gD;AACA,+C;AACA,C;AACA,yE;AACA,C;AACA,6B;AACA,+B;AACA,C;AACA,c;AACA,E;AACA,C;AACA,8B;AACA,sD;AACA,4D;AACA,uC;AACA,C;AACA,0B;AACA,oE;AACA,C;AACA,uC;AACA,oC;AACA,C;AACA,+D;AACA,mC;AACA,+B;AACA,yB;AACA,0E;AACA,C;AACA,+C;AACA,qD;AACA,C;AACA,uB;AACA,I;AACA,I;AACA,C;AACA,uB;AACA,+D;AACA,gC;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,G;AACA,iC;AACA,G;AACA,C;AACA,C;AACA,uE;AACA,0D;AACA,+C;AACA,8E;AACA,C;AACA,uB;AACA,sC;AACA,G;AACA,C;AACA,0C;AACA,uD;AACA,C;AACA,c;AACA,E;AACA,C;AACA,C;AACA,0D;AACA,0C;AACA,mC;AACA,E;AACA,C;AACA,+B;AACA,C;AACA,U;AACA,+D","sourcesContent":["//\r\n// showdown.js -- A javascript port of Markdown.\r\n//\r\n// Copyright (c) 2007 John Fraser.\r\n//\r\n// Original Markdown Copyright (c) 2004-2005 John Gruber\r\n//   <http://daringfireball.net/projects/markdown/>\r\n//\r\n// Redistributable under a BSD-style open source license.\r\n// See license.txt for more information.\r\n//\r\n// The full source distribution is at:\r\n//\r\n//\t\t\t\tA A L\r\n//\t\t\t\tT C A\r\n//\t\t\t\tT K B\r\n//\r\n//   <http://www.attacklab.net/>\r\n//\r\n\r\n//\r\n// Wherever possible, Showdown is a straight, line-by-line port\r\n// of the Perl version of Markdown.\r\n//\r\n// This is not a normal parser design; it's basically just a\r\n// series of string substitutions.  It's hard to read and\r\n// maintain this way,  but keeping Showdown close to the original\r\n// design makes it easier to port new features.\r\n//\r\n// More importantly, Showdown behaves like markdown.pl in most\r\n// edge cases.  So web applications can do client-side preview\r\n// in Javascript, and then build identical HTML on the server.\r\n//\r\n// This port needs the new RegExp functionality of ECMA 262,\r\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\r\n// should do fine.  Even with the new regular expression features,\r\n// We do a lot of work to emulate Perl's regex functionality.\r\n// The tricky changes in this file mostly have the \"attacklab:\"\r\n// label.  Major or self-explanatory changes don't.\r\n//\r\n// Smart diff tools like Araxis Merge will be able to match up\r\n// this file with markdown.pl in a useful way.  A little tweaking\r\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\r\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\r\n// and line endings.\r\n//\r\n\r\n\r\n//\r\n// Showdown usage:\r\n//\r\n//   var text = \"Markdown *rocks*.\";\r\n//\r\n//   var converter = new Showdown.converter();\r\n//   var html = converter.makeHtml(text);\r\n//\r\n//   alert(html);\r\n//\r\n// Note: move the sample code to the bottom of this\r\n// file before uncommenting it.\r\n//\r\n\r\n\r\n//\r\n// Showdown namespace\r\n//\r\n// METEOR CHANGE: remove \"var\" so that this isn't file-local.\r\nShowdown = {};\r\n\r\n//\r\n// converter\r\n//\r\n// Wraps all \"globals\" so that the only thing\r\n// exposed is makeHtml().\r\n//\r\nShowdown.converter = function() {\r\n\r\n//\r\n// Globals:\r\n//\r\n\r\n// Global hashes, used by various utility routines\r\nvar g_urls;\r\nvar g_titles;\r\nvar g_html_blocks;\r\n\r\n// Used to track when we're inside an ordered or unordered list\r\n// (see _ProcessListItems() for details):\r\nvar g_list_level = 0;\r\n\r\n\r\nthis.makeHtml = function(text) {\r\n//\r\n// Main function. The order in which other subs are called here is\r\n// essential. Link and image substitutions need to happen before\r\n// _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>\r\n// and <img> tags get encoded.\r\n//\r\n\r\n\t// Clear the global hashes. If we don't clear these, you get conflicts\r\n\t// from other articles when generating a page which contains more than\r\n\t// one article (e.g. an index page that shows the N most recent\r\n\t// articles):\r\n\tg_urls = new Array();\r\n\tg_titles = new Array();\r\n\tg_html_blocks = new Array();\r\n\r\n\t// attacklab: Replace ~ with ~T\r\n\t// This lets us use tilde as an escape char to avoid md5 hashes\r\n\t// The choice of character is arbitray; anything that isn't\r\n    // magic in Markdown will work.\r\n\ttext = text.replace(/~/g,\"~T\");\r\n\r\n\t// attacklab: Replace $ with ~D\r\n\t// RegExp interprets $ as a special character\r\n\t// when it's in a replacement string\r\n\ttext = text.replace(/\\$/g,\"~D\");\r\n\r\n\t// Standardize line endings\r\n\ttext = text.replace(/\\r\\n/g,\"\\n\"); // DOS to Unix\r\n\ttext = text.replace(/\\r/g,\"\\n\"); // Mac to Unix\r\n\r\n\t// Make sure text begins and ends with a couple of newlines:\r\n\ttext = \"\\n\\n\" + text + \"\\n\\n\";\r\n\r\n\t// Convert all tabs to spaces.\r\n\ttext = _Detab(text);\r\n\r\n\t// Strip any lines consisting only of spaces and tabs.\r\n\t// This makes subsequent regexen easier to write, because we can\r\n\t// match consecutive blank lines with /\\n+/ instead of something\r\n\t// contorted like /[ \\t]*\\n+/ .\r\n\ttext = text.replace(/^[ \\t]+$/mg,\"\");\r\n\r\n\t// Turn block-level HTML blocks into hash entries\r\n\ttext = _HashHTMLBlocks(text);\r\n\r\n\t// Strip link definitions, store in hashes.\r\n\ttext = _StripLinkDefinitions(text);\r\n\r\n\ttext = _RunBlockGamut(text);\r\n\r\n\ttext = _UnescapeSpecialChars(text);\r\n\r\n\t// attacklab: Restore dollar signs\r\n\ttext = text.replace(/~D/g,\"$$\");\r\n\r\n\t// attacklab: Restore tildes\r\n\ttext = text.replace(/~T/g,\"~\");\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _StripLinkDefinitions = function(text) {\r\n//\r\n// Strips link definitions from text, stores the URLs and titles in\r\n// hash references.\r\n//\r\n\r\n\t// Link defs are in the form: ^[id]: url \"optional title\"\r\n\r\n\t/*\r\n\t\tvar text = text.replace(/\r\n\t\t\t\t^[ ]{0,3}\\[(.+)\\]:  // id = $1  attacklab: g_tab_width - 1\r\n\t\t\t\t  [ \\t]*\r\n\t\t\t\t  \\n?\t\t\t\t// maybe *one* newline\r\n\t\t\t\t  [ \\t]*\r\n\t\t\t\t<?(\\S+?)>?\t\t\t// url = $2\r\n\t\t\t\t  [ \\t]*\r\n\t\t\t\t  \\n?\t\t\t\t// maybe one newline\r\n\t\t\t\t  [ \\t]*\r\n\t\t\t\t(?:\r\n\t\t\t\t  (\\n*)\t\t\t\t// any lines skipped = $3 attacklab: lookbehind removed\r\n\t\t\t\t  [\"(]\r\n\t\t\t\t  (.+?)\t\t\t\t// title = $4\r\n\t\t\t\t  [\")]\r\n\t\t\t\t  [ \\t]*\r\n\t\t\t\t)?\t\t\t\t\t// title is optional\r\n\t\t\t\t(?:\\n+|$)\r\n\t\t\t  /gm,\r\n\t\t\t  function(){...});\r\n\t*/\r\n\tvar text = text.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|\\Z)/gm,\r\n\t\tfunction (wholeMatch,m1,m2,m3,m4) {\r\n\t\t\tm1 = m1.toLowerCase();\r\n\t\t\tg_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive\r\n\t\t\tif (m3) {\r\n\t\t\t\t// Oops, found blank lines, so it's not a title.\r\n\t\t\t\t// Put back the parenthetical statement we stole.\r\n\t\t\t\treturn m3+m4;\r\n\t\t\t} else if (m4) {\r\n\t\t\t\tg_titles[m1] = m4.replace(/\"/g,\"&quot;\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Completely remove the definition from the text\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t);\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _HashHTMLBlocks = function(text) {\r\n\t// attacklab: Double up blank lines to reduce lookaround\r\n\ttext = text.replace(/\\n/g,\"\\n\\n\");\r\n\r\n\t// Hashify HTML blocks:\r\n\t// We only want to do this for block-level HTML tags, such as headers,\r\n\t// lists, and tables. That's because we still want to wrap <p>s around\r\n\t// \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\r\n\t// phrase emphasis, and spans. The list of tags we're looking for is\r\n\t// hard-coded:\r\n\tvar block_tags_a = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del\"\r\n\tvar block_tags_b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math\"\r\n\r\n\t// First, look for nested blocks, e.g.:\r\n\t//   <div>\r\n\t//     <div>\r\n\t//     tags for inner block must be indented.\r\n\t//     </div>\r\n\t//   </div>\r\n\t//\r\n\t// The outermost tags must start at the left margin for this to match, and\r\n\t// the inner nested divs must be indented.\r\n\t// We need to do this before the next, more liberal match, because the next\r\n\t// match will start at the first `<div>` and stop at the first `</div>`.\r\n\r\n\t// attacklab: This regex can be expensive when it fails.\r\n\t/*\r\n\t\tvar text = text.replace(/\r\n\t\t(\t\t\t\t\t\t// save in $1\r\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\r\n\t\t\t<($block_tags_a)\t// start tag = $2\r\n\t\t\t\\b\t\t\t\t\t// word break\r\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\r\n\t\t\t[^\\r]*?\\n\t\t\t// any number of lines, minimally matching\r\n\t\t\t</\\2>\t\t\t\t// the matching end tag\r\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\r\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\r\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\r\n\t\t/gm,function(){...}};\r\n\t*/\r\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm,hashElement);\r\n\r\n\t//\r\n\t// Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\r\n\t//\r\n\r\n\t/*\r\n\t\tvar text = text.replace(/\r\n\t\t(\t\t\t\t\t\t// save in $1\r\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\r\n\t\t\t<($block_tags_b)\t// start tag = $2\r\n\t\t\t\\b\t\t\t\t\t// word break\r\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\r\n\t\t\t[^\\r]*?\t\t\t\t// any number of lines, minimally matching\r\n\t\t\t.*</\\2>\t\t\t\t// the matching end tag\r\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\r\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\r\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\r\n\t\t/gm,function(){...}};\r\n\t*/\r\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\\b[^\\r]*?.*<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm,hashElement);\r\n\r\n\t// Special case just for <hr />. It was easier to make a special case than\r\n\t// to make the other regex more complicated.  \r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t\t\t\t\t// save in $1\r\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\r\n\t\t\t[ ]{0,3}\r\n\t\t\t(<(hr)\t\t\t\t// start tag = $2\r\n\t\t\t\\b\t\t\t\t\t// word break\r\n\t\t\t([^<>])*?\t\t\t// \r\n\t\t\t\\/?>)\t\t\t\t// the matching end tag\r\n\t\t\t[ \\t]*\r\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\r\n\t\t)\r\n\t\t/g,hashElement);\r\n\t*/\r\n\ttext = text.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,hashElement);\r\n\r\n\t// Special case for standalone HTML comments:\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t\t\t\t\t// save in $1\r\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\r\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\r\n\t\t\t<!\r\n\t\t\t(--[^\\r]*?--\\s*)+\r\n\t\t\t>\r\n\t\t\t[ \\t]*\r\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\r\n\t\t)\r\n\t\t/g,hashElement);\r\n\t*/\r\n\ttext = text.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g,hashElement);\r\n\r\n\t// PHP and ASP-style processor instructions (<?...?> and <%...%>)\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(?:\r\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\r\n\t\t)\r\n\t\t(\t\t\t\t\t\t// save in $1\r\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\r\n\t\t\t(?:\r\n\t\t\t\t<([?%])\t\t\t// $2\r\n\t\t\t\t[^\\r]*?\r\n\t\t\t\t\\2>\r\n\t\t\t)\r\n\t\t\t[ \\t]*\r\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\r\n\t\t)\r\n\t\t/g,hashElement);\r\n\t*/\r\n\ttext = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,hashElement);\r\n\r\n\t// attacklab: Undo double lines (see comment at top of this function)\r\n\ttext = text.replace(/\\n\\n/g,\"\\n\");\r\n\treturn text;\r\n}\r\n\r\nvar hashElement = function(wholeMatch,m1) {\r\n\tvar blockText = m1;\r\n\r\n\t// Undo double lines\r\n\tblockText = blockText.replace(/\\n\\n/g,\"\\n\");\r\n\tblockText = blockText.replace(/^\\n/,\"\");\r\n\t\r\n\t// strip trailing blank lines\r\n\tblockText = blockText.replace(/\\n+$/g,\"\");\r\n\t\r\n\t// Replace the element text with a marker (\"~KxK\" where x is its key)\r\n\tblockText = \"\\n\\n~K\" + (g_html_blocks.push(blockText)-1) + \"K\\n\\n\";\r\n\t\r\n\treturn blockText;\r\n};\r\n\r\nvar _RunBlockGamut = function(text) {\r\n//\r\n// These are all the transformations that form block-level\r\n// tags like paragraphs, headers, and list items.\r\n//\r\n\ttext = _DoHeaders(text);\r\n\r\n\t// Do Horizontal Rules:\r\n\tvar key = hashBlock(\"<hr />\");\r\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm,key);\r\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm,key);\r\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\_[ ]?){3,}[ \\t]*$/gm,key);\r\n\r\n\ttext = _DoLists(text);\r\n\ttext = _DoCodeBlocks(text);\r\n\ttext = _DoBlockQuotes(text);\r\n\r\n\t// We already ran _HashHTMLBlocks() before, in Markdown(), but that\r\n\t// was to escape raw HTML in the original Markdown source. This time,\r\n\t// we're escaping the markup we've just created, so that we don't wrap\r\n\t// <p> tags around block-level tags.\r\n\ttext = _HashHTMLBlocks(text);\r\n\ttext = _FormParagraphs(text);\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _RunSpanGamut = function(text) {\r\n//\r\n// These are all the transformations that occur *within* block-level\r\n// tags like paragraphs, headers, and list items.\r\n//\r\n\r\n\ttext = _DoCodeSpans(text);\r\n\ttext = _EscapeSpecialCharsWithinTagAttributes(text);\r\n\ttext = _EncodeBackslashEscapes(text);\r\n\r\n\t// Process anchor and image tags. Images must come first,\r\n\t// because ![foo][f] looks like an anchor.\r\n\ttext = _DoImages(text);\r\n\ttext = _DoAnchors(text);\r\n\r\n\t// Make links out of things like `<http://example.com/>`\r\n\t// Must come after _DoAnchors(), because you can use < and >\r\n\t// delimiters in inline links like [this](<url>).\r\n\ttext = _DoAutoLinks(text);\r\n\ttext = _EncodeAmpsAndAngles(text);\r\n\ttext = _DoItalicsAndBold(text);\r\n\r\n\t// Do hard breaks:\r\n\ttext = text.replace(/  +\\n/g,\" <br />\\n\");\r\n\r\n\treturn text;\r\n}\r\n\r\nvar _EscapeSpecialCharsWithinTagAttributes = function(text) {\r\n//\r\n// Within tags -- meaning between < and > -- encode [\\ ` * _] so they\r\n// don't conflict with their use in Markdown for code, italics and strong.\r\n//\r\n\r\n\t// Build a regex to find HTML tags and comments.  See Friedl's \r\n\t// \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\r\n\tvar regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\r\n\r\n\ttext = text.replace(regex, function(wholeMatch) {\r\n\t\tvar tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g,\"$1`\");\r\n\t\ttag = escapeCharacters(tag,\"\\\\`*_\");\r\n\t\treturn tag;\r\n\t});\r\n\r\n\treturn text;\r\n}\r\n\r\nvar _DoAnchors = function(text) {\r\n//\r\n// Turn Markdown link shortcuts into XHTML <a> tags.\r\n//\r\n\t//\r\n\t// First, handle reference-style links: [link text] [id]\r\n\t//\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t\t\t\t\t\t// wrap whole match in $1\r\n\t\t\t\\[\r\n\t\t\t(\r\n\t\t\t\t(?:\r\n\t\t\t\t\t\\[[^\\]]*\\]\t\t// allow brackets nested one level\r\n\t\t\t\t\t|\r\n\t\t\t\t\t[^\\[]\t\t\t// or anything else\r\n\t\t\t\t)*\r\n\t\t\t)\r\n\t\t\t\\]\r\n\r\n\t\t\t[ ]?\t\t\t\t\t// one optional space\r\n\t\t\t(?:\\n[ ]*)?\t\t\t\t// one optional newline followed by spaces\r\n\r\n\t\t\t\\[\r\n\t\t\t(.*?)\t\t\t\t\t// id = $3\r\n\t\t\t\\]\r\n\t\t)()()()()\t\t\t\t\t// pad remaining backreferences\r\n\t\t/g,_DoAnchors_callback);\r\n\t*/\r\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeAnchorTag);\r\n\r\n\t//\r\n\t// Next, inline-style links: [link text](url \"optional title\")\r\n\t//\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t\t(\t\t\t\t\t\t// wrap whole match in $1\r\n\t\t\t\t\\[\r\n\t\t\t\t(\r\n\t\t\t\t\t(?:\r\n\t\t\t\t\t\t\\[[^\\]]*\\]\t// allow brackets nested one level\r\n\t\t\t\t\t|\r\n\t\t\t\t\t[^\\[\\]]\t\t\t// or anything else\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t\\]\r\n\t\t\t\\(\t\t\t\t\t\t// literal paren\r\n\t\t\t[ \\t]*\r\n\t\t\t()\t\t\t\t\t\t// no id, so leave $3 empty\r\n\t\t\t<?(.*?)>?\t\t\t\t// href = $4\r\n\t\t\t[ \\t]*\r\n\t\t\t(\t\t\t\t\t\t// $5\r\n\t\t\t\t(['\"])\t\t\t\t// quote char = $6\r\n\t\t\t\t(.*?)\t\t\t\t// Title = $7\r\n\t\t\t\t\\6\t\t\t\t\t// matching quote\r\n\t\t\t\t[ \\t]*\t\t\t\t// ignore any spaces/tabs between closing quote and )\r\n\t\t\t)?\t\t\t\t\t\t// title is optional\r\n\t\t\t\\)\r\n\t\t)\r\n\t\t/g,writeAnchorTag);\r\n\t*/\r\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?(.*?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeAnchorTag);\r\n\r\n\t//\r\n\t// Last, handle reference-style shortcuts: [link text]\r\n\t// These must come last in case you've also got [link test][1]\r\n\t// or [link test](/foo)\r\n\t//\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t \t\t\t\t\t// wrap whole match in $1\r\n\t\t\t\\[\r\n\t\t\t([^\\[\\]]+)\t\t\t\t// link text = $2; can't contain '[' or ']'\r\n\t\t\t\\]\r\n\t\t)()()()()()\t\t\t\t\t// pad rest of backreferences\r\n\t\t/g, writeAnchorTag);\r\n\t*/\r\n\ttext = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\r\n\r\n\treturn text;\r\n}\r\n\r\nvar writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\r\n\tif (m7 == undefined) m7 = \"\";\r\n\tvar whole_match = m1;\r\n\tvar link_text   = m2;\r\n\tvar link_id\t = m3.toLowerCase();\r\n\tvar url\t\t= m4;\r\n\tvar title\t= m7;\r\n\t\r\n\tif (url == \"\") {\r\n\t\tif (link_id == \"\") {\r\n\t\t\t// lower-case and turn embedded newlines into spaces\r\n\t\t\tlink_id = link_text.toLowerCase().replace(/ ?\\n/g,\" \");\r\n\t\t}\r\n\t\turl = \"#\"+link_id;\r\n\t\t\r\n\t\tif (g_urls[link_id] != undefined) {\r\n\t\t\turl = g_urls[link_id];\r\n\t\t\tif (g_titles[link_id] != undefined) {\r\n\t\t\t\ttitle = g_titles[link_id];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (whole_match.search(/\\(\\s*\\)$/m)>-1) {\r\n\t\t\t\t// Special case for explicit empty url\r\n\t\t\t\turl = \"\";\r\n\t\t\t} else {\r\n\t\t\t\treturn whole_match;\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n\t\r\n\turl = escapeCharacters(url,\"*_\");\r\n\tvar result = \"<a href=\\\"\" + url + \"\\\"\";\r\n\t\r\n\tif (title != \"\") {\r\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\r\n\t\ttitle = escapeCharacters(title,\"*_\");\r\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\r\n\t}\r\n\t\r\n\tresult += \">\" + link_text + \"</a>\";\r\n\t\r\n\treturn result;\r\n}\r\n\r\n\r\nvar _DoImages = function(text) {\r\n//\r\n// Turn Markdown image shortcuts into <img> tags.\r\n//\r\n\r\n\t//\r\n\t// First, handle reference-style labeled images: ![alt text][id]\r\n\t//\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\r\n\t\t\t!\\[\r\n\t\t\t(.*?)\t\t\t\t// alt text = $2\r\n\t\t\t\\]\r\n\r\n\t\t\t[ ]?\t\t\t\t// one optional space\r\n\t\t\t(?:\\n[ ]*)?\t\t\t// one optional newline followed by spaces\r\n\r\n\t\t\t\\[\r\n\t\t\t(.*?)\t\t\t\t// id = $3\r\n\t\t\t\\]\r\n\t\t)()()()()\t\t\t\t// pad rest of backreferences\r\n\t\t/g,writeImageTag);\r\n\t*/\r\n\ttext = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeImageTag);\r\n\r\n\t//\r\n\t// Next, handle inline images:  ![alt text](url \"optional title\")\r\n\t// Don't forget: encode * and _\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\r\n\t\t\t!\\[\r\n\t\t\t(.*?)\t\t\t\t// alt text = $2\r\n\t\t\t\\]\r\n\t\t\t\\s?\t\t\t\t\t// One optional whitespace character\r\n\t\t\t\\(\t\t\t\t\t// literal paren\r\n\t\t\t[ \\t]*\r\n\t\t\t()\t\t\t\t\t// no id, so leave $3 empty\r\n\t\t\t<?(\\S+?)>?\t\t\t// src url = $4\r\n\t\t\t[ \\t]*\r\n\t\t\t(\t\t\t\t\t// $5\r\n\t\t\t\t(['\"])\t\t\t// quote char = $6\r\n\t\t\t\t(.*?)\t\t\t// title = $7\r\n\t\t\t\t\\6\t\t\t\t// matching quote\r\n\t\t\t\t[ \\t]*\r\n\t\t\t)?\t\t\t\t\t// title is optional\r\n\t\t\\)\r\n\t\t)\r\n\t\t/g,writeImageTag);\r\n\t*/\r\n\ttext = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeImageTag);\r\n\r\n\treturn text;\r\n}\r\n\r\nvar writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\r\n\tvar whole_match = m1;\r\n\tvar alt_text   = m2;\r\n\tvar link_id\t = m3.toLowerCase();\r\n\tvar url\t\t= m4;\r\n\tvar title\t= m7;\r\n\r\n\tif (!title) title = \"\";\r\n\t\r\n\tif (url == \"\") {\r\n\t\tif (link_id == \"\") {\r\n\t\t\t// lower-case and turn embedded newlines into spaces\r\n\t\t\tlink_id = alt_text.toLowerCase().replace(/ ?\\n/g,\" \");\r\n\t\t}\r\n\t\turl = \"#\"+link_id;\r\n\t\t\r\n\t\tif (g_urls[link_id] != undefined) {\r\n\t\t\turl = g_urls[link_id];\r\n\t\t\tif (g_titles[link_id] != undefined) {\r\n\t\t\t\ttitle = g_titles[link_id];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn whole_match;\r\n\t\t}\r\n\t}\t\r\n\t\r\n\talt_text = alt_text.replace(/\"/g,\"&quot;\");\r\n\turl = escapeCharacters(url,\"*_\");\r\n\tvar result = \"<img src=\\\"\" + url + \"\\\" alt=\\\"\" + alt_text + \"\\\"\";\r\n\r\n\t// attacklab: Markdown.pl adds empty title attributes to images.\r\n\t// Replicate this bug.\r\n\r\n\t//if (title != \"\") {\r\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\r\n\t\ttitle = escapeCharacters(title,\"*_\");\r\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\r\n\t//}\r\n\t\r\n\tresult += \" />\";\r\n\t\r\n\treturn result;\r\n}\r\n\r\n\r\nvar _DoHeaders = function(text) {\r\n\r\n\t// Setext-style headers:\r\n\t//\tHeader 1\r\n\t//\t========\r\n\t//  \r\n\t//\tHeader 2\r\n\t//\t--------\r\n\t//\r\n\ttext = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\r\n\t\tfunction(wholeMatch,m1){return hashBlock('<h1 id=\"' + headerId(m1) + '\">' + _RunSpanGamut(m1) + \"</h1>\");});\r\n\r\n\ttext = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\r\n\t\tfunction(matchFound,m1){return hashBlock('<h2 id=\"' + headerId(m1) + '\">' + _RunSpanGamut(m1) + \"</h2>\");});\r\n\r\n\t// atx-style headers:\r\n\t//  # Header 1\r\n\t//  ## Header 2\r\n\t//  ## Header 2 with closing hashes ##\r\n\t//  ...\r\n\t//  ###### Header 6\r\n\t//\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t\t^(\\#{1,6})\t\t\t\t// $1 = string of #'s\r\n\t\t\t[ \\t]*\r\n\t\t\t(.+?)\t\t\t\t\t// $2 = Header text\r\n\t\t\t[ \\t]*\r\n\t\t\t\\#*\t\t\t\t\t\t// optional closing #'s (not counted)\r\n\t\t\t\\n+\r\n\t\t/gm, function() {...});\r\n\t*/\r\n\r\n\ttext = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\r\n\t\tfunction(wholeMatch,m1,m2) {\r\n\t\t\tvar h_level = m1.length;\r\n\t\t\treturn hashBlock(\"<h\" + h_level + ' id=\"' + headerId(m2) + '\">' + _RunSpanGamut(m2) + \"</h\" + h_level + \">\");\r\n\t\t});\r\n\r\n\tfunction headerId(m) {\r\n\t\treturn m.replace(/[^\\w]/g, '').toLowerCase();\r\n\t}\r\n\treturn text;\r\n}\r\n\r\n// This declaration keeps Dojo compressor from outputting garbage:\r\nvar _ProcessListItems;\r\n\r\nvar _DoLists = function(text) {\r\n//\r\n// Form HTML ordered (numbered) and unordered (bulleted) lists.\r\n//\r\n\r\n\t// attacklab: add sentinel to hack around khtml/safari bug:\r\n\t// http://bugs.webkit.org/show_bug.cgi?id=11231\r\n\ttext += \"~0\";\r\n\r\n\t// Re-usable pattern to match any entirel ul or ol list:\r\n\r\n\t/*\r\n\t\tvar whole_list = /\r\n\t\t(\t\t\t\t\t\t\t\t\t// $1 = whole list\r\n\t\t\t(\t\t\t\t\t\t\t\t// $2\r\n\t\t\t\t[ ]{0,3}\t\t\t\t\t// attacklab: g_tab_width - 1\r\n\t\t\t\t([*+-]|\\d+[.])\t\t\t\t// $3 = first list item marker\r\n\t\t\t\t[ \\t]+\r\n\t\t\t)\r\n\t\t\t[^\\r]+?\r\n\t\t\t(\t\t\t\t\t\t\t\t// $4\r\n\t\t\t\t~0\t\t\t\t\t\t\t// sentinel for workaround; should be $\r\n\t\t\t|\r\n\t\t\t\t\\n{2,}\r\n\t\t\t\t(?=\\S)\r\n\t\t\t\t(?!\t\t\t\t\t\t\t// Negative lookahead for another list item marker\r\n\t\t\t\t\t[ \\t]*\r\n\t\t\t\t\t(?:[*+-]|\\d+[.])[ \\t]+\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t)/g\r\n\t*/\r\n\tvar whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\r\n\r\n\tif (g_list_level) {\r\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2) {\r\n\t\t\tvar list = m1;\r\n\t\t\tvar list_type = (m2.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\r\n\r\n\t\t\t// Turn double returns into triple returns, so that we can make a\r\n\t\t\t// paragraph for the last item in a list, if necessary:\r\n\t\t\tlist = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\r\n\t\t\tvar result = _ProcessListItems(list);\r\n\t\r\n\t\t\t// Trim any trailing whitespace, to put the closing `</$list_type>`\r\n\t\t\t// up on the preceding line, to get it past the current stupid\r\n\t\t\t// HTML block parser. This is a hack to work around the terrible\r\n\t\t\t// hack that is the HTML block parser.\r\n\t\t\tresult = result.replace(/\\s+$/,\"\");\r\n\t\t\tresult = \"<\"+list_type+\">\" + result + \"</\"+list_type+\">\\n\";\r\n\t\t\treturn result;\r\n\t\t});\r\n\t} else {\r\n\t\twhole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\r\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {\r\n\t\t\tvar runup = m1;\r\n\t\t\tvar list = m2;\r\n\r\n\t\t\tvar list_type = (m3.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\r\n\t\t\t// Turn double returns into triple returns, so that we can make a\r\n\t\t\t// paragraph for the last item in a list, if necessary:\r\n\t\t\tvar list = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\r\n\t\t\tvar result = _ProcessListItems(list);\r\n\t\t\tresult = runup + \"<\"+list_type+\">\\n\" + result + \"</\"+list_type+\">\\n\";\t\r\n\t\t\treturn result;\r\n\t\t});\r\n\t}\r\n\r\n\t// attacklab: strip sentinel\r\n\ttext = text.replace(/~0/,\"\");\r\n\r\n\treturn text;\r\n}\r\n\r\n_ProcessListItems = function(list_str) {\r\n//\r\n//  Process the contents of a single ordered or unordered list, splitting it\r\n//  into individual list items.\r\n//\r\n\t// The $g_list_level global keeps track of when we're inside a list.\r\n\t// Each time we enter a list, we increment it; when we leave a list,\r\n\t// we decrement. If it's zero, we're not in a list anymore.\r\n\t//\r\n\t// We do this because when we're not inside a list, we want to treat\r\n\t// something like this:\r\n\t//\r\n\t//    I recommend upgrading to version\r\n\t//    8. Oops, now this line is treated\r\n\t//    as a sub-list.\r\n\t//\r\n\t// As a single paragraph, despite the fact that the second line starts\r\n\t// with a digit-period-space sequence.\r\n\t//\r\n\t// Whereas when we're inside a list (or sub-list), that line will be\r\n\t// treated as the start of a sub-list. What a kludge, huh? This is\r\n\t// an aspect of Markdown's syntax that's hard to parse perfectly\r\n\t// without resorting to mind-reading. Perhaps the solution is to\r\n\t// change the syntax rules such that sub-lists must start with a\r\n\t// starting cardinal number; e.g. \"1.\" or \"a.\".\r\n\r\n\tg_list_level++;\r\n\r\n\t// trim trailing blank lines:\r\n\tlist_str = list_str.replace(/\\n{2,}$/,\"\\n\");\r\n\r\n\t// attacklab: add sentinel to emulate \\z\r\n\tlist_str += \"~0\";\r\n\r\n\t/*\r\n\t\tlist_str = list_str.replace(/\r\n\t\t\t(\\n)?\t\t\t\t\t\t\t// leading line = $1\r\n\t\t\t(^[ \\t]*)\t\t\t\t\t\t// leading whitespace = $2\r\n\t\t\t([*+-]|\\d+[.]) [ \\t]+\t\t\t// list marker = $3\r\n\t\t\t([^\\r]+?\t\t\t\t\t\t// list item text   = $4\r\n\t\t\t(\\n{1,2}))\r\n\t\t\t(?= \\n* (~0 | \\2 ([*+-]|\\d+[.]) [ \\t]+))\r\n\t\t/gm, function(){...});\r\n\t*/\r\n\tlist_str = list_str.replace(/(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm,\r\n\t\tfunction(wholeMatch,m1,m2,m3,m4){\r\n\t\t\tvar item = m4;\r\n\t\t\tvar leading_line = m1;\r\n\t\t\tvar leading_space = m2;\r\n\r\n\t\t\tif (leading_line || (item.search(/\\n{2,}/)>-1)) {\r\n\t\t\t\titem = _RunBlockGamut(_Outdent(item));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Recursion for sub-lists:\r\n\t\t\t\titem = _DoLists(_Outdent(item));\r\n\t\t\t\titem = item.replace(/\\n$/,\"\"); // chomp(item)\r\n\t\t\t\titem = _RunSpanGamut(item);\r\n\t\t\t}\r\n\r\n\t\t\treturn  \"<li>\" + item + \"</li>\\n\";\r\n\t\t}\r\n\t);\r\n\r\n\t// attacklab: strip sentinel\r\n\tlist_str = list_str.replace(/~0/g,\"\");\r\n\r\n\tg_list_level--;\r\n\treturn list_str;\r\n}\r\n\r\n\r\nvar _DoCodeBlocks = function(text) {\r\n//\r\n//  Process Markdown `<pre><code>` blocks.\r\n//  \r\n\r\n\t/*\r\n\t\ttext = text.replace(text,\r\n\t\t\t/(?:\\n\\n|^)\r\n\t\t\t(\t\t\t\t\t\t\t\t// $1 = the code block -- one or more lines, starting with a space/tab\r\n\t\t\t\t(?:\r\n\t\t\t\t\t(?:[ ]{4}|\\t)\t\t\t// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\r\n\t\t\t\t\t.*\\n+\r\n\t\t\t\t)+\r\n\t\t\t)\r\n\t\t\t(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))\t// attacklab: g_tab_width\r\n\t\t/g,function(){...});\r\n\t*/\r\n\r\n\t// attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n\ttext += \"~0\";\r\n\t\r\n\ttext = text.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\r\n\t\tfunction(wholeMatch,m1,m2) {\r\n\t\t\tvar codeblock = m1;\r\n\t\t\tvar nextChar = m2;\r\n\t\t\r\n\t\t\tcodeblock = _EncodeCode( _Outdent(codeblock));\r\n\t\t\tcodeblock = _Detab(codeblock);\r\n\t\t\tcodeblock = codeblock.replace(/^\\n+/g,\"\"); // trim leading newlines\r\n\t\t\tcodeblock = codeblock.replace(/\\n+$/g,\"\"); // trim trailing whitespace\r\n\r\n\t\t\tcodeblock = \"<pre><code>\" + codeblock + \"\\n</code></pre>\";\r\n\r\n\t\t\treturn hashBlock(codeblock) + nextChar;\r\n\t\t}\r\n\t);\r\n\r\n\t// attacklab: strip sentinel\r\n\ttext = text.replace(/~0/,\"\");\r\n\r\n\treturn text;\r\n}\r\n\r\nvar hashBlock = function(text) {\r\n\ttext = text.replace(/(^\\n+|\\n+$)/g,\"\");\r\n\treturn \"\\n\\n~K\" + (g_html_blocks.push(text)-1) + \"K\\n\\n\";\r\n}\r\n\r\n\r\nvar _DoCodeSpans = function(text) {\r\n//\r\n//   *  Backtick quotes are used for <code></code> spans.\r\n// \r\n//   *  You can use multiple backticks as the delimiters if you want to\r\n//\t include literal backticks in the code span. So, this input:\r\n//\t \r\n//\t\t Just type ``foo `bar` baz`` at the prompt.\r\n//\t \r\n//\t   Will translate to:\r\n//\t \r\n//\t\t <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\r\n//\t \r\n//\tThere's no arbitrary limit to the number of backticks you\r\n//\tcan use as delimters. If you need three consecutive backticks\r\n//\tin your code, use four for delimiters, etc.\r\n//\r\n//  *  You can use spaces to get literal backticks at the edges:\r\n//\t \r\n//\t\t ... type `` `bar` `` ...\r\n//\t \r\n//\t   Turns to:\r\n//\t \r\n//\t\t ... type <code>`bar`</code> ...\r\n//\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t\t(^|[^\\\\])\t\t\t\t\t// Character before opening ` can't be a backslash\r\n\t\t\t(`+)\t\t\t\t\t\t// $2 = Opening run of `\r\n\t\t\t(\t\t\t\t\t\t\t// $3 = The code block\r\n\t\t\t\t[^\\r]*?\r\n\t\t\t\t[^`]\t\t\t\t\t// attacklab: work around lack of lookbehind\r\n\t\t\t)\r\n\t\t\t\\2\t\t\t\t\t\t\t// Matching closer\r\n\t\t\t(?!`)\r\n\t\t/gm, function(){...});\r\n\t*/\r\n\r\n\ttext = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\r\n\t\tfunction(wholeMatch,m1,m2,m3,m4) {\r\n\t\t\tvar c = m3;\r\n\t\t\tc = c.replace(/^([ \\t]*)/g,\"\");\t// leading whitespace\r\n\t\t\tc = c.replace(/[ \\t]*$/g,\"\");\t// trailing whitespace\r\n\t\t\tc = _EncodeCode(c);\r\n\t\t\treturn m1+\"<code>\"+c+\"</code>\";\r\n\t\t});\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _EncodeCode = function(text) {\r\n//\r\n// Encode/escape certain characters inside Markdown code runs.\r\n// The point is that in code, these characters are literals,\r\n// and lose their special Markdown meanings.\r\n//\r\n\t// Encode all ampersands; HTML entities are not\r\n\t// entities within a Markdown code span.\r\n\ttext = text.replace(/&/g,\"&amp;\");\r\n\r\n\t// Do the angle bracket song and dance:\r\n\ttext = text.replace(/</g,\"&lt;\");\r\n\ttext = text.replace(/>/g,\"&gt;\");\r\n\r\n\t// Now, escape characters that are magic in Markdown:\r\n\ttext = escapeCharacters(text,\"\\*_{}[]\\\\\",false);\r\n\r\n// jj the line above breaks this:\r\n//---\r\n\r\n//* Item\r\n\r\n//   1. Subitem\r\n\r\n//            special char: *\r\n//---\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _DoItalicsAndBold = function(text) {\r\n\r\n\t// <strong> must go first:\r\n\ttext = text.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g,\r\n\t\t\"<strong>$2</strong>\");\r\n\r\n\ttext = text.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g,\r\n\t\t\"<em>$2</em>\");\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _DoBlockQuotes = function(text) {\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t(\t\t\t\t\t\t\t\t// Wrap whole match in $1\r\n\t\t\t(\r\n\t\t\t\t^[ \\t]*>[ \\t]?\t\t\t// '>' at the start of a line\r\n\t\t\t\t.+\\n\t\t\t\t\t// rest of the first line\r\n\t\t\t\t(.+\\n)*\t\t\t\t\t// subsequent consecutive lines\r\n\t\t\t\t\\n*\t\t\t\t\t\t// blanks\r\n\t\t\t)+\r\n\t\t)\r\n\t\t/gm, function(){...});\r\n\t*/\r\n\r\n\ttext = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\r\n\t\tfunction(wholeMatch,m1) {\r\n\t\t\tvar bq = m1;\r\n\r\n\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\r\n\t\t\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n\r\n\t\t\tbq = bq.replace(/^[ \\t]*>[ \\t]?/gm,\"~0\");\t// trim one level of quoting\r\n\r\n\t\t\t// attacklab: clean up hack\r\n\t\t\tbq = bq.replace(/~0/g,\"\");\r\n\r\n\t\t\tbq = bq.replace(/^[ \\t]+$/gm,\"\");\t\t// trim whitespace-only lines\r\n\t\t\tbq = _RunBlockGamut(bq);\t\t\t\t// recurse\r\n\t\t\t\r\n\t\t\tbq = bq.replace(/(^|\\n)/g,\"$1  \");\r\n\t\t\t// These leading spaces screw with <pre> content, so we need to fix that:\r\n\t\t\tbq = bq.replace(\r\n\t\t\t\t\t/(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\r\n\t\t\t\tfunction(wholeMatch,m1) {\r\n\t\t\t\t\tvar pre = m1;\r\n\t\t\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\r\n\t\t\t\t\tpre = pre.replace(/^  /mg,\"~0\");\r\n\t\t\t\t\tpre = pre.replace(/~0/g,\"\");\r\n\t\t\t\t\treturn pre;\r\n\t\t\t\t});\r\n\t\t\t\r\n\t\t\treturn hashBlock(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\");\r\n\t\t});\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _FormParagraphs = function(text) {\r\n//\r\n//  Params:\r\n//    $text - string to process with html <p> tags\r\n//\r\n\r\n\t// Strip leading and trailing lines:\r\n\ttext = text.replace(/^\\n+/g,\"\");\r\n\ttext = text.replace(/\\n+$/g,\"\");\r\n\r\n\tvar grafs = text.split(/\\n{2,}/g);\r\n\tvar grafsOut = new Array();\r\n\r\n\t//\r\n\t// Wrap <p> tags.\r\n\t//\r\n\tvar end = grafs.length;\r\n\tfor (var i=0; i<end; i++) {\r\n\t\tvar str = grafs[i];\r\n\r\n\t\t// if this is an HTML marker, copy it\r\n\t\tif (str.search(/~K(\\d+)K/g) >= 0) {\r\n\t\t\tgrafsOut.push(str);\r\n\t\t}\r\n\t\telse if (str.search(/\\S/) >= 0) {\r\n\t\t\tstr = _RunSpanGamut(str);\r\n\t\t\tstr = str.replace(/^([ \\t]*)/g,\"<p>\");\r\n\t\t\tstr += \"</p>\"\r\n\t\t\tgrafsOut.push(str);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\t// Unhashify HTML blocks\r\n\t//\r\n\tend = grafsOut.length;\r\n\tfor (var i=0; i<end; i++) {\r\n\t\t// if this is a marker for an html block...\r\n\t\twhile (grafsOut[i].search(/~K(\\d+)K/) >= 0) {\r\n\t\t\tvar blockText = g_html_blocks[RegExp.$1];\r\n\t\t\tblockText = blockText.replace(/\\$/g,\"$$$$\"); // Escape any dollar signs\r\n\t\t\tgrafsOut[i] = grafsOut[i].replace(/~K\\d+K/,blockText);\r\n\t\t}\r\n\t}\r\n\r\n\treturn grafsOut.join(\"\\n\\n\");\r\n}\r\n\r\n\r\nvar _EncodeAmpsAndAngles = function(text) {\r\n// Smart processing for ampersands and angle brackets that need to be encoded.\r\n\t\r\n\t// Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\r\n\t//   http://bumppo.net/projects/amputator/\r\n\ttext = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g,\"&amp;\");\r\n\t\r\n\t// Encode naked <'s\r\n\ttext = text.replace(/<(?![a-z\\/?\\$!])/gi,\"&lt;\");\r\n\t\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _EncodeBackslashEscapes = function(text) {\r\n//\r\n//   Parameter:  String.\r\n//   Returns:\tThe string, with after processing the following backslash\r\n//\t\t\t   escape sequences.\r\n//\r\n\r\n\t// attacklab: The polite way to do this is with the new\r\n\t// escapeCharacters() function:\r\n\t//\r\n\t// \ttext = escapeCharacters(text,\"\\\\\",true);\r\n\t// \ttext = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\r\n\t//\r\n\t// ...but we're sidestepping its use of the (slow) RegExp constructor\r\n\t// as an optimization for Firefox.  This function gets called a LOT.\r\n\r\n\ttext = text.replace(/\\\\(\\\\)/g,escapeCharacters_callback);\r\n\ttext = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g,escapeCharacters_callback);\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _DoAutoLinks = function(text) {\r\n\r\n\ttext = text.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi,\"<a href=\\\"$1\\\">$1</a>\");\r\n\r\n\t// Email addresses: <address@domain.foo>\r\n\r\n\t/*\r\n\t\ttext = text.replace(/\r\n\t\t\t<\r\n\t\t\t(?:mailto:)?\r\n\t\t\t(\r\n\t\t\t\t[-.\\w]+\r\n\t\t\t\t\\@\r\n\t\t\t\t[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\r\n\t\t\t)\r\n\t\t\t>\r\n\t\t/gi, _DoAutoLinks_callback());\r\n\t*/\r\n\ttext = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\r\n\t\tfunction(wholeMatch,m1) {\r\n\t\t\treturn _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\r\n\t\t}\r\n\t);\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _EncodeEmailAddress = function(addr) {\r\n//\r\n//  Input: an email address, e.g. \"foo@example.com\"\r\n//\r\n//  Output: the email address as a mailto link, with each character\r\n//\tof the address encoded as either a decimal or hex entity, in\r\n//\tthe hopes of foiling most address harvesting spam bots. E.g.:\r\n//\r\n//\t<a href=\"&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;\r\n//\t   x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;\">&#102;&#111;&#111;\r\n//\t   &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>\r\n//\r\n//  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk\r\n//  mailing list: <http://tinyurl.com/yu7ue>\r\n//\r\n\r\n\t// attacklab: why can't javascript speak hex?\r\n\tfunction char2hex(ch) {\r\n\t\tvar hexDigits = '0123456789ABCDEF';\r\n\t\tvar dec = ch.charCodeAt(0);\r\n\t\treturn(hexDigits.charAt(dec>>4) + hexDigits.charAt(dec&15));\r\n\t}\r\n\r\n\tvar encode = [\r\n\t\tfunction(ch){return \"&#\"+ch.charCodeAt(0)+\";\";},\r\n\t\tfunction(ch){return \"&#x\"+char2hex(ch)+\";\";},\r\n\t\tfunction(ch){return ch;}\r\n\t];\r\n\r\n\taddr = \"mailto:\" + addr;\r\n\r\n\taddr = addr.replace(/./g, function(ch) {\r\n\t\tif (ch == \"@\") {\r\n\t\t   \t// this *must* be encoded. I insist.\r\n\t\t\tch = encode[Math.floor(Math.random()*2)](ch);\r\n\t\t} else if (ch !=\":\") {\r\n\t\t\t// leave ':' alone (to spot mailto: later)\r\n\t\t\tvar r = Math.random();\r\n\t\t\t// roughly 10% raw, 45% hex, 45% dec\r\n\t\t\tch =  (\r\n\t\t\t\t\tr > .9  ?\tencode[2](ch)   :\r\n\t\t\t\t\tr > .45 ?\tencode[1](ch)   :\r\n\t\t\t\t\t\t\t\tencode[0](ch)\r\n\t\t\t\t);\r\n\t\t}\r\n\t\treturn ch;\r\n\t});\r\n\r\n\taddr = \"<a href=\\\"\" + addr + \"\\\">\" + addr + \"</a>\";\r\n\taddr = addr.replace(/\">.+:/g,\"\\\">\"); // strip the mailto: from the visible part\r\n\r\n\treturn addr;\r\n}\r\n\r\n\r\nvar _UnescapeSpecialChars = function(text) {\r\n//\r\n// Swap back in all the special characters we've hidden.\r\n//\r\n\ttext = text.replace(/~E(\\d+)E/g,\r\n\t\tfunction(wholeMatch,m1) {\r\n\t\t\tvar charCodeToReplace = parseInt(m1);\r\n\t\t\treturn String.fromCharCode(charCodeToReplace);\r\n\t\t}\r\n\t);\r\n\treturn text;\r\n}\r\n\r\n\r\nvar _Outdent = function(text) {\r\n//\r\n// Remove one level of line-leading tabs or spaces\r\n//\r\n\r\n\t// attacklab: hack around Konqueror 3.5.4 bug:\r\n\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n\r\n\ttext = text.replace(/^(\\t|[ ]{1,4})/gm,\"~0\"); // attacklab: g_tab_width\r\n\r\n\t// attacklab: clean up hack\r\n\ttext = text.replace(/~0/g,\"\")\r\n\r\n\treturn text;\r\n}\r\n\r\nvar _Detab = function(text) {\r\n// attacklab: Detab's completely rewritten for speed.\r\n// In perl we could fix it by anchoring the regexp with \\G.\r\n// In javascript we're less fortunate.\r\n\r\n\t// expand first n-1 tabs\r\n\ttext = text.replace(/\\t(?=\\t)/g,\"    \"); // attacklab: g_tab_width\r\n\r\n\t// replace the nth with two sentinels\r\n\ttext = text.replace(/\\t/g,\"~A~B\");\r\n\r\n\t// use the sentinel to anchor our regex so it doesn't explode\r\n\ttext = text.replace(/~B(.+?)~A/g,\r\n\t\tfunction(wholeMatch,m1,m2) {\r\n\t\t\tvar leadingText = m1;\r\n\t\t\tvar numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width\r\n\r\n\t\t\t// there *must* be a better way to do this:\r\n\t\t\tfor (var i=0; i<numSpaces; i++) leadingText+=\" \";\r\n\r\n\t\t\treturn leadingText;\r\n\t\t}\r\n\t);\r\n\r\n\t// clean up sentinels\r\n\ttext = text.replace(/~A/g,\"    \");  // attacklab: g_tab_width\r\n\ttext = text.replace(/~B/g,\"\");\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\n//\r\n//  attacklab: Utility functions\r\n//\r\n\r\n\r\nvar escapeCharacters = function(text, charsToEscape, afterBackslash) {\r\n\t// First we have to escape the escape characters so that\r\n\t// we can build a character class out of them\r\n\tvar regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g,\"\\\\$1\") + \"])\";\r\n\r\n\tif (afterBackslash) {\r\n\t\tregexString = \"\\\\\\\\\" + regexString;\r\n\t}\r\n\r\n\tvar regex = new RegExp(regexString,\"g\");\r\n\ttext = text.replace(regex,escapeCharacters_callback);\r\n\r\n\treturn text;\r\n}\r\n\r\n\r\nvar escapeCharacters_callback = function(wholeMatch,m1) {\r\n\tvar charCodeToEscape = m1.charCodeAt(0);\r\n\treturn \"~E\"+charCodeToEscape+\"E\";\r\n}\r\n\r\n} // end of Showdown.converter\r\n\r\n// export\r\nif (typeof exports != 'undefined') exports.Showdown = Showdown;"]}