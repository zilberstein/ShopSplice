{"version":3,"file":"/packages/compileStylus:plugin.js","sources":["compileStylus/plugin/compile-stylus.js"],"names":[],"mappings":";;;;;;;;;;AAAA,2B;AACA,mC;AACA,6B;AACA,0C;;AAEA,6D;AACA,mE;AACA,6C;AACA,gE;AACA,qE;AACA,qE;AACA,4D;AACA,W;AACA,G;;AAEA,qB;AACA,6C;AACA,e;AACA,2C;AACA,0B;;AAEA,O;AACA,uB;AACA,e;AACA,uB;AACA,oD;AACA,O;AACA,W;AACA,G;AACA,6B;AACA,yC;AACA,a;AACA,K;AACA,G","sourcesContent":["var fs = Npm.require('fs');\nvar stylus = Npm.require('stylus');\nvar nib = Npm.require('nib');\nvar Future = Npm.require('fibers/future');\n\nPlugin.registerSourceHandler(\"styl\", function (compileStep) {\n  // XXX annoying that this is replicated in .css, .less, and .styl\n  if (! compileStep.archMatches('browser')) {\n    // XXX in the future, might be better to emit some kind of a\n    // warning if a stylesheet is included on the server, rather than\n    // silently ignoring it. but that would mean you can't stick .css\n    // at the top level of your app, which is kind of silly.\n    return;\n  }\n\n  var f = new Future;\n  stylus(compileStep.read().toString('utf8'))\n    .use(nib())\n    .set('filename', compileStep.inputPath)\n    .render(f.resolver());\n\n  try {\n    var css = f.wait();\n  } catch (e) {\n    compileStep.error({\n      message: \"Stylus compiler error: \" + e.message\n    });\n    return;\n  }\n  compileStep.addStylesheet({\n    path: compileStep.inputPath + \".css\",\n    data: css\n  });\n});\n"]}