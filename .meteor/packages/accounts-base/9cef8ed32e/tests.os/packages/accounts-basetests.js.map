{"version":3,"file":"/packages/accounts-base:tests.js","sources":["accounts-base/accounts_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,wE;AACA,+E;AACA,gB;AACA,kE;AACA,2B;AACA,kC;AACA,K;AACA,G;;;AAGA,8B;AACA,0C;AACA,wC;AACA,c;AACA,G;;AAEA,sF;AACA,kG;AACA,iD;AACA,G;;AAEA,6F;AACA,+B;;AAEA,oC;AACA,4D;AACA,sE;AACA,8E;AACA,wB;AACA,sC;AACA,oD;;AAEA,kE;AACA,wD;AACA,4D;AACA,4C;AACA,uC;AACA,yB;AACA,0E;AACA,wB;AACA,sC;AACA,8C;AACA,mD;AACA,6D;AACA,0C;AACA,oD;;AAEA,Y;AACA,4B;AACA,G;;AAEA,0F;AACA,6B;AACA,6B;;AAEA,8D;AACA,4D;AACA,qD;AACA,4D;AACA,qD;AACA,+F;AACA,mF;AACA,sF;AACA,mF;AACA,sF;;AAEA,Y;AACA,4B;AACA,4B;AACA,G;;AAEA,4F;AACA,uD;AACA,qC;;AAEA,sE;AACA,4D;AACA,uE;AACA,+E;AACA,wB;AACA,sC;AACA,mD;;AAEA,wD;AACA,0D;AACA,mC;AACA,4D;AACA,uE;AACA,yB;AACA,2E;AACA,wB;;AAEA,Y;AACA,4B;AACA,G;;;AAGA,mE;AACA,gB;AACA,yB;AACA,I;;AAEA,uE;AACA,sC;AACA,iC;AACA,U;AACA,I;AACA,gD;;AAEA,iD;AACA,8C;AACA,gD;;AAEA,oE;AACA,2B;AACA,2B;AACA,mC;AACA,Y;AACA,M;AACA,K;;AAEA,Y;AACA,iC;;AAEA,G;;AAEA,gE;AACA,2B;AACA,2B;AACA,2B;AACA,gB;AACA,gD;AACA,+C;AACA,I;;AAEA,uE;AACA,sC;AACA,iC;AACA,U;AACA,I;AACA,gD;;AAEA,iD;AACA,8C;AACA,4C;;AAEA,mD;AACA,oE;AACA,2B;AACA,2B;AACA,mC;AACA,Y;AACA,M;AACA,K;;AAEA,+B;AACA,2B;AACA,2B;AACA,uC;AACA,M;AACA,K;;AAEA,2B;AACA,2B;AACA,uC;AACA,M;AACA,K;;;AAGA,yB;AACA,uC;AACA,uC;AACA,I;AACA,+C;AACA,+C;;AAEA,Y;AACA,iC;AACA,kC;AACA,G;;AAEA,uD;AACA,kF;AACA,yC;AACA,kD;AACA,mB;AACA,e;AACA,yC;AACA,kC;AACA,W;AACA,uC;AACA,2B;AACA,kB;AACA,U;AACA,2B;AACA,mB;AACA,Q;AACA,K;AACA,K;AACA,sD;AACA,iC;AACA,wD;AACA,2D;AACA,uB;AACA,qB;AACA,O;AACA,K;AACA,K;AACA,gD;AACA,G;;;AAGA,kB;AACA,0C;AACA,+B;AACA,uB;AACA,W;AACA,yC;AACA,qE;AACA,sC;AACA,wC;AACA,8E;AACA,uB;AACA,W;;AAEA,2E;AACA,2B;AACA,Q;AACA,gB;AACA,M;AACA,G;AACA,E","sourcesContent":["// XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({foo: \"bar\"});\n  });\n});\n\n\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\n\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', {id: Random.id()}).id;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id();\n\n  // create an account with facebook\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, llama: 50},\n    {profile: {foo: 1000, bar: 2}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50);\n  // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id();\n\n  // users that have different service ids get different users\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId1}, {profile: {foo: 1}}).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId2}, {profile: {bar: 2}}).id;\n  test.equal(Meteor.users.find({\"services.weibo.id\": {$in: [weiboId1, weiboId2]}}).count(), 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).profile.foo, 1);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).emails, undefined);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).profile.bar, 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).emails, undefined);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = ''+twitterIdOld;\n\n  // create an account with twitter using the old ID format of integer\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdOld, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.twitter.id\": twitterIdOld}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42);\n\n  // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdNew, monkey: 42}, {profile: {foo: 1}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.twitter.id\": twitterIdNew}).fetch();\n  test.length(users, 1);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\n\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var result = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(result.id);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username);\n\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  });\n\n  // cleanup\n  Meteor.users.remove(result.id);\n\n});\n\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{address: email1, verified: false},\n             {address: email2, verified: true}]\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var result = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(result.id);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails);\n\n  // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  });\n\n  // now with only one of them.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email1}]}\n    );\n  });\n\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email2}]}\n    );\n  });\n\n\n  // a third email works.\n  var result3 = Accounts.insertUserDoc(\n      {}, {emails: [{address: email3}]}\n  );\n  var user3 = Meteor.users.findOne(result3.id);\n  test.equal(typeof user3.createdAt, 'object');\n\n  // cleanup\n  Meteor.users.remove(result.id);\n  Meteor.users.remove(result3.id);\n});\n\n// More token expiration tests are in accounts-password\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = { username: Random.id() };\n  var result = Accounts.insertUserDoc({ profile: {\n    name: 'Foo Bar'\n  } }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(result.id, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        token: Random.id(),\n        when: date\n      }, {\n        token: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(result.id).observe({\n    changed: function (newUser) {\n      if (newUser.services && newUser.services.resume &&\n          _.isEmpty(newUser.services.resume.loginTokens)) {\n        observe.stop();\n        onComplete();\n      }\n    }\n  });\n  Accounts._expireTokens(new Date(), result.id);\n});\n\n\nTinytest.addAsync(\n  'accounts - connection data cleaned up',\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // onClose callbacks are called in order, so we run after the\n        // close callback in accounts.\n        serverConn.onClose(function () {\n          test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n          onComplete();\n        });\n\n        test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n"]}