{"version":3,"file":"/packages/facts.js","sources":["facts/facts.js"],"names":[],"mappings":";;;;;;;;AAAA,W;;AAEA,kD;;AAEA,sB;AACA,8E;AACA,gC;AACA,wC;AACA,iC;AACA,I;;AAEA,8C;AACA,6C;AACA,0B;AACA,I;;AAEA,yE;AACA,2B;AACA,0B;AACA,+B;;AAEA,+D;AACA,sC;AACA,+B;AACA,4C;AACA,kD;AACA,mE;AACA,S;AACA,a;AACA,K;;AAEA,2C;AACA,mC;AACA,oC;AACA,2C;AACA,0B;AACA,mD;AACA,gD;AACA,4D;AACA,O;AACA,I;;AAEA,mE;AACA,6E;AACA,Y;AACA,4B;AACA,yC;AACA,gD;AACA,qB;AACA,uC;AACA,oB;AACA,e;AACA,O;AACA,oC;AACA,oD;AACA,qD;AACA,S;AACA,8B;AACA,kE;AACA,S;AACA,kB;AACA,wB;AACA,K;AACA,Q;AACA,8D;;AAEA,qD;AACA,+B;AACA,I;AACA,4C;AACA,uB;AACA,yC;AACA,yB;AACA,mD;AACA,O;AACA,qB;AACA,I;;AAEA,uE;AACA,sE;AACA,oD;AACA,8C;AACA,wD;AACA,I;AACA,gD;AACA,2B;AACA,8B;AACA,8B;AACA,K;AACA,I;AACA,C","sourcesContent":["Facts = {};\n\nvar serverFactsCollection = 'meteor_Facts_server';\n\nif (Meteor.isServer) {\n  // By default, we publish facts to no user if autopublish is off, and to all\n  // users if autopublish is on.\n  var userIdFilter = function (userId) {\n    return !!Package.autopublish;\n  };\n\n  // XXX make this take effect at runtime too?\n  Facts.setUserIdFilter = function (filter) {\n    userIdFilter = filter;\n  };\n\n  // XXX Use a minimongo collection instead and hook up an observeChanges\n  // directly to a publish.\n  var factsByPackage = {};\n  var activeSubscriptions = [];\n\n  Facts.incrementServerFact = function (pkg, fact, increment) {\n    if (!_.has(factsByPackage, pkg)) {\n      factsByPackage[pkg] = {};\n      factsByPackage[pkg][fact] = increment;\n      _.each(activeSubscriptions, function (sub) {\n        sub.added(serverFactsCollection, pkg, factsByPackage[pkg]);\n      });\n      return;\n    }\n\n    var packageFacts = factsByPackage[pkg];\n    if (!_.has(packageFacts, fact))\n      factsByPackage[pkg][fact] = 0;\n    factsByPackage[pkg][fact] += increment;\n    var changedField = {};\n    changedField[fact] = factsByPackage[pkg][fact];\n    _.each(activeSubscriptions, function (sub) {\n      sub.changed(serverFactsCollection, pkg, changedField);\n    });\n  };\n\n  // Deferred, because we have an unordered dependency on livedata.\n  // XXX is this safe? could somebody try to connect before Meteor.publish is\n  // called?\n  Meteor.defer(function () {\n    // XXX Also publish facts-by-package.\n    Meteor.publish(\"meteor_facts\", function () {\n      var sub = this;\n      if (!userIdFilter(this.userId)) {\n        sub.ready();\n        return;\n      }\n      activeSubscriptions.push(sub);\n      _.each(factsByPackage, function (facts, pkg) {\n        sub.added(serverFactsCollection, pkg, facts);\n      });\n      sub.onStop(function () {\n        activeSubscriptions = _.without(activeSubscriptions, sub);\n      });\n      sub.ready();\n    }, {is_auto: true});\n  });\n} else {\n  Facts.server = new Meteor.Collection(serverFactsCollection);\n\n  Template.serverFacts.factsByPackage = function () {\n    return Facts.server.find();\n  };\n  Template.serverFacts.facts = function () {\n    var factArray = [];\n    _.each(this, function (value, name) {\n      if (name !== '_id')\n        factArray.push({name: name, value: value});\n    });\n    return factArray;\n  };\n\n  // Subscribe when the template is first made, and unsubscribe when it\n  // is removed. If for some reason puts two copies of the template on\n  // the screen at once, we'll subscribe twice. Meh.\n  Template.serverFacts.created = function () {\n    this._stopHandle = Meteor.subscribe(\"meteor_facts\");\n  };\n  Template.serverFacts.destroyed = function () {\n    if (this._stopHandle) {\n      this._stopHandle.stop();\n      this._stopHandle = null;\n    }\n  };\n}\n"]}