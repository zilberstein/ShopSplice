{"version":3,"file":"/packages/test-helpers.js","sources":["test-helpers/try_all_permutations.js","test-helpers/async_multi.js","test-helpers/event_simulation.js","test-helpers/seeded_random.js","test-helpers/canonicalize_html.js","test-helpers/onscreendiv.js","test-helpers/wrappedfrag.js","test-helpers/current_style.js","test-helpers/reactivevar.js","test-helpers/callback_logger.js"],"names":[],"mappings":";;;;;;;;AAAA,0D;AACA,E;AACA,oE;AACA,oE;AACA,kE;AACA,qE;AACA,8B;AACA,E;AACA,M;AACA,kC;AACA,+D;AACA,gC;AACA,E;AACA,qC;AACA,6C;AACA,E;AACA,oE;AACA,sE;AACA,8D;AACA,mE;AACA,yC;AACA,E;AACA,M;AACA,yC;AACA,iC;AACA,6C;AACA,U;AACA,E;AACA,qE;AACA,kE;AACA,yC;AACA,qC;;AAEA,oC;AACA,mD;;AAEA,sB;AACA,kB;;AAEA,qC;AACA,sC;AACA,4C;AACA,Y;AACA,kC;AACA,oC;AACA,oB;;AAEA,oB;AACA,qC;AACA,mC;AACA,U;AACA,8B;AACA,oB;AACA,K;AACA,I;;AAEA,6C;AACA,uB;AACA,wB;AACA,U;AACA,kD;AACA,kC;AACA,0B;AACA,mE;AACA,qB;AACA,O;AACA,K;AACA,I;;AAEA,oB;AACA,E;;;;;;;;;;;;;;;;;;;ACtEA,gE;AACA,sC;;AAEA,kE;AACA,gE;AACA,kE;AACA,O;AACA,uE;AACA,0B;AACA,oE;AACA,E;AACA,yE;AACA,6E;AACA,kF;AACA,qF;AACA,4E;AACA,qD;AACA,E;AACA,4D;AACA,sD;AACA,8E;AACA,E;AACA,iF;AACA,2E;AACA,8E;AACA,+D;;AAEA,uC;AACA,E;AACA,gC;AACA,6B;AACA,qB;AACA,uC;AACA,uB;AACA,W;AACA,E;AACA,8E;AACA,E;AACA,O;AACA,6B;AACA,qB;AACA,M;AACA,M;;AAEA,sD;AACA,kB;;AAEA,mB;AACA,+B;AACA,sB;AACA,oB;AACA,uB;AACA,E;;AAEA,wC;AACA,sC;AACA,oB;;AAEA,2C;AACA,kC;AACA,Q;AACA,0C;;AAEA,oB;AACA,uE;AACA,uB;;AAEA,uC;AACA,oB;AACA,e;;AAEA,2C;AACA,a;AACA,wC;AACA,qB;AACA,4B;AACA,mC;AACA,S;AACA,c;AACA,wD;AACA,O;;AAEA,yB;AACA,6B;AACA,M;AACA,I;;AAEA,qB;AACA,oB;AACA,uB;AACA,2B;AACA,I;;AAEA,uB;AACA,oB;AACA,sB;AACA,uB;AACA,kB;AACA,K;AACA,iB;AACA,I;;AAEA,gC;AACA,oB;AACA,yD;AACA,uB;AACA,wB;AACA,K;AACA,G;AACA,G;;AAEA,yC;AACA,wE;AACA,uB;;AAEA,uD;AACA,mC;AACA,qB;;AAEA,+B;AACA,mC;AACA,gB;AACA,qB;AACA,Y;AACA,2D;AACA,qC;AACA,oB;AACA,W;;AAEA,mD;AACA,4B;AACA,2E;AACA,yB;AACA,W;AACA,iB;AACA,oB;;AAEA,a;AACA,6D;AACA,6B;AACA,0B;AACA,sC;AACA,qC;AACA,4E;AACA,iB;AACA,S;AACA,kB;AACA,O;AACA,M;;AAEA,c;AACA,K;AACA,E;;AAEA,kE;AACA,+D;AACA,4D;AACA,6B;AACA,qB;AACA,qC;AACA,4B;AACA,e;AACA,gB;AACA,a;AACA,K;AACA,mD;AACA,e;AACA,a;AACA,K;AACA,oC;AACA,I;AACA,W;AACA,E;;AAEA,yD;AACA,2B;AACA,qB;AACA,iC;AACA,a;AACA,M;AACA,sC;AACA,wC;AACA,Y;AACA,Q;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACzLA,8C;AACA,8C;;AAEA,6B;AACA,0C;AACA,mC;AACA,sB;AACA,0B;AACA,U;AACA,yC;AACA,sB;AACA,oC;AACA,G;AACA,E;;AAEA,+B;AACA,gD;AACA,gC;AACA,iB;AACA,e;AACA,e;;AAEA,8C;AACA,sC;AACA,wD;AACA,E;;AAEA,8B;AACA,c;AACA,sC;AACA,0D;AACA,E;;AAEA,+B;AACA,iB;AACA,8E;AACA,M;AACA,iC;AACA,E;;;;;;;;;;;;;;;;;;;ACtCA,mE;AACA,uC;AACA,kC;;AAEA,wB;AACA,wD;AACA,E;AACA,0C;AACA,oB;AACA,E;AACA,iD;AACA,4B;AACA,E;AACA,4D;AACA,6B;AACA,qD;AACA,E;AACA,0D;AACA,mB;AACA,uD;AACA,0B;AACA,oE;AACA,Q;AACA,0B;AACA,E;AACA,oD;AACA,qD;AACA,E;;;;;;;;;;;;;;;;;;;AC3BA,mC;AACA,e;AACA,gD;AACA,kC;AACA,kC;AACA,0C;AACA,4B;AACA,2C;AACA,+B;AACA,8B;AACA,+B;AACA,gC;AACA,oE;AACA,6E;AACA,qE;AACA,0D;AACA,2C;AACA,uC;AACA,uC;AACA,uC;AACA,oC;AACA,2C;AACA,oB;AACA,gC;AACA,0C;AACA,qC;AACA,uB;AACA,+D;AACA,qB;AACA,sD;AACA,2B;AACA,iB;AACA,uB;AACA,2C;AACA,kC;AACA,8B;AACA,sC;AACA,K;;AAEA,yC;AACA,K;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;;AC1CA,8D;AACA,+D;AACA,0B;AACA,E;AACA,gD;AACA,E;AACA,6D;AACA,uC;;AAEA,oC;AACA,oC;AACA,iC;AACA,sC;AACA,oC;;AAEA,qC;AACA,wE;AACA,sC;;AAEA,c;AACA,kC;AACA,E;;AAEA,+B;AACA,4C;AACA,4B;AACA,E;;AAEA,sD;AACA,kD;AACA,yC;AACA,0C;AACA,E;;AAEA,0B;AACA,yC;AACA,oD;AACA,E;;AAEA,qB;AACA,yC;AACA,kB;AACA,E;;AAEA,+C;AACA,iD;AACA,8C;AACA,yC;AACA,kB;AACA,0B;AACA,8C;;AAEA,+B;AACA,6B;AACA,K;AACA,E;;AAEA,mC;AACA,2C;AACA,4C;AACA,E;;AAEA,kD;AACA,uD;AACA,sD;AACA,gB;AACA,kD;AACA,mC;AACA,kB;AACA,8B;AACA,uC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACxEA,+D;AACA,4D;AACA,8D;AACA,8B;;AAEA,oC;AACA,oC;AACA,8B;AACA,sC;AACA,iC;;AAEA,mB;AACA,E;;AAEA,4C;AACA,4C;AACA,E;;AAEA,yC;AACA,0C;AACA,E;;AAEA,yC;AACA,oD;AACA,2D;AACA,c;AACA,E;;AAEA,4C;AACA,uB;AACA,mD;AACA,qD;AACA,uC;AACA,+B;AACA,+B;AACA,2B;AACA,K;AACA,K;AACA,c;AACA,E;;AAEA,yC;AACA,mB;AACA,E;;;;;;;;;;;;;;;;;;;AC3CA,4E;AACA,sC;AACA,uB;AACA,0B;AACA,uC;AACA,kB;AACA,kD;AACA,U;AACA,mE;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACVA,gE;AACA,+D;AACA,oB;AACA,E;AACA,8C;AACA,+D;AACA,kE;AACA,gD;AACA,+D;AACA,0B;AACA,E;AACA,oC;AACA,4C;;AAEA,sC;AACA,sC;AACA,yC;;AAEA,6D;AACA,+B;AACA,mC;AACA,E;;AAEA,wC;AACA,sB;AACA,qB;AACA,E;;AAEA,gD;AACA,mD;AACA,+B;AACA,iE;AACA,W;;AAEA,yB;;AAEA,uB;AACA,E;;AAEA,iD;AACA,gD;AACA,mD;AACA,E;;;;;;;;;;;;;;;;;;;AC1CA,0E;AACA,6E;AACA,yE;AACA,gF;AACA,8E;AACA,8E;AACA,uE;;AAEA,2D;;AAEA,mB;;AAEA,8E;AACA,gF;AACA,a;;AAEA,iE;AACA,uD;AACA,c;AACA,e;AACA,gD;AACA,oD;AACA,uB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,qD;AACA,kB;AACA,iB;AACA,oB;AACA,wB;AACA,iD;AACA,sC;AACA,sC;AACA,2D;AACA,uB;AACA,gC;AACA,4B;AACA,yC;AACA,c;AACA,O;AACA,M;AACA,K;AACA,E;;AAEA,kD;AACA,kB;AACA,uB;AACA,2B;AACA,wB;AACA,W;AACA,E;;AAEA,uE;AACA,kB;AACA,kC;AACA,6B;AACA,yE;AACA,W;AACA,G;AACA,iC;AACA,kD;AACA,sC;AACA,E;;AAEA,2E;AACA,kB;AACA,wC;AACA,6B;AACA,C;;AAEA,mE;AACA,kB;AACA,mB;AACA,2B;AACA,+B;AACA,yC;AACA,6B;AACA,gB;AACA,oC;AACA,qC;AACA,c;AACA,O;AACA,K;AACA,yB;AACA,G;AACA,E;;AAEA,kE;AACA,kB;;AAEA,4C;;AAEA,wC;AACA,sB;AACA,iB;AACA,sB;AACA,qC;AACA,2C;AACA,yC;AACA,0B;AACA,qB;AACA,c;AACA,O;AACA,K;AACA,e;AACA,gF;AACA,Q;AACA,G;AACA,E;;AAEA,4D;AACA,kB;AACA,kC;AACA,E;;AAEA,uD;AACA,kB;AACA,mB;AACA,yC;AACA,6B;AACA,gB;AACA,4B;AACA,oD;AACA,0B;AACA,K;AACA,yB;AACA,G;AACA,6B;AACA,E","sourcesContent":["// Given some functions, run them in every possible order.\n//\n// In simplest usage, takes one argument, an array of functions. Run\n// those functions in every possible order. Or, if the first element\n// of the array is an integer N, with the remaining elements being\n// functions (N <= the number of functions), run every permutation of\n// N functions from the array.\n//\n// Eg:\n// try_all_permutations([A, B, C])\n// => runs A, B, C; A, C, B; B, A, C; B, C, A; C, A, B; C, B, A\n// (semicolons for clarity only)\n//\n// try_all_permutations([2, A, B, C])\n// => runs A, B; A, C; B, A; B, C; C, A; C, B\n//\n// If more than one argument A_1, A_2 ... A_n is passed, each should\n// be an array as described above. Compute the possible orderings O_1,\n// O_2 ... O_n per above, and run the Cartesian product of the\n// sets. (Except that unlike a proper Cartesian product, a set with\n// zero elements will simply be ignored.)\n//\n// Eg:\n// try_all_permutations([X], [A, B], [Y])\n// => runs X, A, B, Y; X, B, A, Y\n// try_all_permutations([X], [A, B], [], [Y])\n// => same\n//\n// If a function is passed instead of an array, it will be treated as\n// an array with one argument. In other words, these are the same:\n// try_all_permutations([X], [A, B], [Y])\n// try_all_permutations(X, [A, B], Y)\n\ntry_all_permutations = function () {\n  var args = Array.prototype.slice.call(arguments);\n\n  var current_set = 0;\n  var chosen = [];\n\n  var expand_next_set = function () {\n    if (current_set === args.length) {\n      _.each(chosen, function (f) { f(); });\n    } else {\n      var set = args[current_set];\n      if (typeof set === \"function\")\n        set = [set];\n\n      current_set++;\n      if (typeof set[0] === \"number\")\n        pick(set[0], set.slice(1));\n      else\n        pick(set.length, set);\n      current_set--;\n    }\n  };\n\n  var pick = function (how_many, remaining) {\n    if (how_many === 0)\n      expand_next_set();\n    else {\n      for (var i = 0; i < remaining.length; i++) {\n        chosen.push(remaining[i]);\n        pick(how_many - 1,\n             remaining.slice(0, i).concat(remaining.slice(i + 1)));\n        chosen.pop();\n      }\n    }\n  };\n\n  expand_next_set();\n};\n","// This depends on tinytest, so it's a little weird to put it in\n// test-helpers, but it'll do for now.\n\n// Provides the testAsyncMulti helper, which creates an async test\n// (using Tinytest.addAsync) that tracks parallel and sequential\n// asynchronous calls.  Specifically, the two features it provides\n// are:\n// 1) Executing an array of functions sequentially when those functions\n//    contain async calls.\n// 2) Keeping track of when callbacks are outstanding, via \"expect\".\n//\n// To use, pass an array of functions that take arguments (test, expect).\n// (There is no onComplete callback; completion is determined automatically.)\n// Expect takes a callback closure and wraps it, returning a new callback closure,\n// and making a note that there is a callback oustanding.  Pass this returned closure\n// to async functions as the callback, and the machinery in the wrapper will\n// record the fact that the callback has been called.\n//\n// A second form of expect takes data arguments to test for.\n// Essentially, expect(\"foo\", \"bar\") is equivalent to:\n// expect(function(arg1, arg2) { test.equal([arg1, arg2], [\"foo\", \"bar\"]); }).\n//\n// You cannot \"nest\" expect or call it from a callback!  Even if you have a chain\n// of callbacks, you need to call expect at the \"top level\" (synchronously)\n// but the callback you wrap has to be the last/innermost one.  This sometimes\n// leads to some code contortions and should probably be fixed.\n\n// Example: (at top level of test file)\n//\n// testAsyncMulti(\"test name\", [\n//   function(test, expect) {\n//     ... tests here\n//     Meteor.defer(expect(function() {\n//       ... tests here\n//     }));\n//\n//     call_something_async('foo', 'bar', expect('baz')); // implicit callback\n//\n//   },\n//   function(test, expect) {\n//     ... more tests\n//   }\n// ]);\n\nvar ExpectationManager = function (test, onComplete) {\n  var self = this;\n\n  self.test = test;\n  self.onComplete = onComplete;\n  self.closed = false;\n  self.dead = false;\n  self.outstanding = 0;\n};\n\n_.extend(ExpectationManager.prototype, {\n  expect: function (/* arguments */) {\n    var self = this;\n\n    if (typeof arguments[0] === \"function\")\n      var expected = arguments[0];\n    else\n      var expected = _.toArray(arguments);\n\n    if (self.closed)\n      throw new Error(\"Too late to add more expectations to the test\");\n    self.outstanding++;\n\n    return function (/* arguments */) {\n      if (self.dead)\n        return;\n\n      if (typeof expected === \"function\") {\n        try {\n          expected.apply({}, arguments);\n        } catch (e) {\n          if (self.cancel())\n            self.test.exception(e);\n        }\n      } else {\n        self.test.equal(_.toArray(arguments), expected);\n      }\n\n      self.outstanding--;\n      self._check_complete();\n    };\n  },\n\n  done: function () {\n    var self = this;\n    self.closed = true;\n    self._check_complete();\n  },\n\n  cancel: function () {\n    var self = this;\n    if (! self.dead) {\n      self.dead = true;\n      return true;\n    }\n    return false;\n  },\n\n  _check_complete: function () {\n    var self = this;\n    if (!self.outstanding && self.closed && !self.dead) {\n      self.dead = true;\n      self.onComplete();\n    }\n  }\n});\n\ntestAsyncMulti = function (name, funcs) {\n  // XXX Tests on remote browsers are _slow_. We need a better solution.\n  var timeout = 180000;\n\n  Tinytest.addAsync(name, function (test, onComplete) {\n    var remaining = _.clone(funcs);\n    var context = {};\n\n    var runNext = function () {\n      var func = remaining.shift();\n      if (!func)\n        onComplete();\n      else {\n        var em = new ExpectationManager(test, function () {\n          Meteor.clearTimeout(timer);\n          runNext();\n        });\n\n        var timer = Meteor.setTimeout(function () {\n          if (em.cancel()) {\n            test.fail({type: \"timeout\", message: \"Async batch timed out\"});\n            onComplete();\n          }\n          return;\n        }, timeout);\n\n        try {\n          func.apply(context, [test, _.bind(em.expect, em)]);\n        } catch (exception) {\n          if (em.cancel())\n            test.exception(exception);\n          Meteor.clearTimeout(timer);\n          // Because we called test.exception, we're not to call onComplete.\n          return;\n        }\n        em.done();\n      }\n    };\n\n    runNext();\n  });\n};\n\n// Call `fn` periodically until it returns true.  If it does, call\n// `success`.  If it doesn't before the timeout, call `failed`.\nsimplePoll = function (fn, success, failed, timeout, step) {\n  timeout = timeout || 10000;\n  step = step || 100;\n  var start = (new Date()).valueOf();\n  var helper = function () {\n    if (fn()) {\n      success();\n      return;\n    }\n    if (start + timeout < (new Date()).valueOf()) {\n      failed();\n      return;\n    }\n    Meteor.setTimeout(helper, step);\n  };\n  helper();\n};\n\npollUntil = function (expect, f, timeout, step, noFail) {\n  noFail = noFail || false;\n  step = step || 100;\n  var expectation = expect(true);\n  simplePoll(\n    f,\n    function () { expectation(true) },\n    function () { expectation(noFail) },\n    timeout,\n    step\n  );\n};\n","simulateEvent = function (node, event, args) {\n  node = (node instanceof $ ? node[0] : node);\n\n  if (document.createEvent) {\n    var e = document.createEvent(\"Event\");\n    e.initEvent(event, true, true);\n    _.extend(e, args);\n    node.dispatchEvent(e);\n  } else {\n    var e = document.createEventObject();\n    _.extend(e, args);\n    node.fireEvent(\"on\" + event, e);\n  }\n};\n\nfocusElement = function(elem) {\n  // This sequence is for benefit of IE 8 and 9;\n  // test there before changing.\n  window.focus();\n  elem.focus();\n  elem.focus();\n\n  // focus() should set document.activeElement\n  if (document.activeElement !== elem)\n    throw new Error(\"focus() didn't set activeElement\");\n};\n\nblurElement = function(elem) {\n  elem.blur();\n  if (document.activeElement === elem)\n    throw new Error(\"blur() didn't affect activeElement\");\n};\n\nclickElement = function(elem) {\n  if (elem.click)\n    elem.click(); // supported by form controls cross-browser; most native way\n  else\n    simulateEvent(elem, 'click');\n};\n","SeededRandom = function(seed) { // seed may be a string or any type\n  if (! (this instanceof SeededRandom))\n    return new SeededRandom(seed);\n\n  seed = seed || \"seed\";\n  this.gen = Random.create(seed).alea; // from random.js\n};\nSeededRandom.prototype.next = function() {\n  return this.gen();\n};\nSeededRandom.prototype.nextBoolean = function() {\n  return this.next() >= 0.5;\n};\nSeededRandom.prototype.nextIntBetween = function(min, max) {\n  // inclusive of min and max\n  return Math.floor(this.next() * (max-min+1)) + min;\n};\nSeededRandom.prototype.nextIdentifier = function(optLen) {\n  var letters = [];\n  var len = (typeof optLen === \"number\" ? optLen : 12);\n  for(var i=0; i<len; i++)\n    letters.push(String.fromCharCode(this.nextIntBetween(97, 122)));\n  var x;\n  return letters.join('');\n};\nSeededRandom.prototype.nextChoice = function(list) {\n  return list[this.nextIntBetween(0, list.length-1)];\n};\n","canonicalizeHtml = function(html) {\n  var h = html;\n  // kill IE-specific comments inserted by Spark\n  h = h.replace(/<!--IE-->/g, '');\n  // ignore exact text of comments\n  h = h.replace(/<!--.*?-->/g, '<!---->');\n  // make all tags lowercase\n  h = h.replace(/<\\/?(\\w+)/g, function(m) {\n    return m.toLowerCase(); });\n  // kill \\n and \\r characters\n  h = h.replace(/[\\n\\r]/g, '');\n  // make tag attributes uniform\n  h = h.replace(/<(\\w+)\\s+(.*?)\\s*>/g, function(m, tagName, attrs) {\n    // Drop expando property used by Sizzle (part of jQuery) which leaks into\n    // attributes in IE8. Note that its value always contains spaces.\n    attrs = attrs.replace(/sizcache[0-9]+=\"[^\"]*\"/g, ' ');\n    attrs = attrs.replace(/\\s*=\\s*/g, '=');\n    attrs = attrs.replace(/^\\s+/g, '');\n    attrs = attrs.replace(/\\s+$/g, '');\n    attrs = attrs.replace(/\\s+/g, ' ');\n    var attrList = attrs.split(' ');\n    // put attributes in alphabetical order\n    attrList.sort();\n    var tagContents = [tagName];\n    for(var i=0; i<attrList.length; i++) {\n      var a = attrList[i].split('=');\n      if (a.length < 2)\n        a.push(a[0]); // things like checked=checked, in theory\n      var key = a[0];\n      // Drop another expando property used by Sizzle.\n      if (key === 'sizset')\n        continue;\n      var value = a[1];\n      value = value.replace(/[\"'`]/g, '\"');\n      if (value.charAt(0) !== '\"')\n        value = '\"'+value+'\"';\n      tagContents.push(key+'='+value);\n    }\n\n    return '<'+tagContents.join(' ')+'>';\n  });\n  return h;\n};\n","// OnscreenDiv is an object that appends a DIV to the document\n// body and keeps track of it, providing methods that query it,\n// mutate, and destroy it.\n//\n// By default the DIV has style 'display: none'.\n//\n// In general, methods of OnscreenDiv operate on the contents\n// of the DIV excluding the DIV itself.\n\n// Constructor, with optional 'new':\n// var d = [new] OnscreenDiv([frag])\nOnscreenDiv = function(optFrag) {\n  if (! (this instanceof OnscreenDiv))\n    return new OnscreenDiv(optFrag);\n\n  this.div = DomUtils.htmlToFragment(\n    '<div class=\"OnscreenDiv\" style=\"display: none\"></div>').firstChild;\n  document.body.appendChild(this.div);\n\n  if (optFrag)\n    this.div.appendChild(optFrag);\n};\n\n// get the innerHTML of the DIV\nOnscreenDiv.prototype.rawHtml = function() {\n  return this.div.innerHTML;\n};\n\n// get the innerHTML with some sanitization that tries\n// to produce predictable results across browsers.\nOnscreenDiv.prototype.html = function() {\n  return canonicalizeHtml(this.rawHtml());\n};\n\n// get the text of the DIV\nOnscreenDiv.prototype.text = function() {\n  return this.div.innerText || this.div.textContent;\n};\n\n// get the DIV itself\nOnscreenDiv.prototype.node = function() {\n  return this.div;\n};\n\n// remove the DIV from the document and trigger\n// \"fast GC\" -- i.e., after the next Deps.flush()\n// the DIV will be fully cleaned up by LiveUI.\nOnscreenDiv.prototype.kill = function() {\n  var self = this;\n  if (self.div.parentNode)\n    self.div.parentNode.removeChild(self.div);\n\n  Deps.afterFlush(function () {\n    Spark.finalize(self.div);\n  });\n};\n\n// remove the DIV from the document\nOnscreenDiv.prototype.remove = function() {\n  this.div.parentNode.removeChild(this.div);\n};\n\n// Show the div (which is otherwise display:none),\n// for tests that require it or for debugging of tests.\n// If invisibly=true, make the div 0-height to obscure\n// the contents.\nOnscreenDiv.prototype.show = function(invisibly) {\n  this.div.style.display = \"block\";\n  if (invisibly) {\n    this.div.style.height = 0;\n    this.div.style.overflow = 'hidden';\n  }\n};\n","// A WrappedFrag provides utility methods pertaining to a given\n// DocumentFragment that are helpful in tests.  For example,\n// WrappedFrag(frag).html() constructs a sort of cross-browser\n// innerHTML for the fragment.\n\n// Constructor, with optional 'new':\n// var f = [new] WrappedFrag([frag])\nWrappedFrag = function(frag) {\n  if (! (this instanceof WrappedFrag))\n    return new WrappedFrag(frag);\n\n  this.frag = frag;\n};\n\nWrappedFrag.prototype.rawHtml = function() {\n  return DomUtils.fragmentToHtml(this.frag);\n};\n\nWrappedFrag.prototype.html = function() {\n  return canonicalizeHtml(this.rawHtml());\n};\n\nWrappedFrag.prototype.hold = function() {\n  // increments frag's GC protection reference count\n  this.frag[\"_protect\"] = (this.frag[\"_protect\"] || 0) + 1;\n  return this;\n};\n\nWrappedFrag.prototype.release = function() {\n  var frag = this.frag;\n  // decrement frag's GC protection reference count\n  // Clean up on flush, if hits 0.  Wait to decrement\n  // so no one else cleans it up first.\n  Deps.afterFlush(function () {\n    if (! --frag[\"_protect\"]) {\n      Spark.finalize(frag);\n    }\n  });\n  return this;\n};\n\nWrappedFrag.prototype.node = function() {\n  return this.frag;\n};\n","// Cross-browser implementation of getting the computed style of an element.\ngetStyleProperty = function(n, prop) {\n  if (n.currentStyle) {\n    // camelCase it for IE\n    return n.currentStyle[prop.replace(\n      /-([a-z])/g,\n      function(x,y) { return y.toUpperCase(); })];\n  } else {\n    return window.getComputedStyle(n, null).getPropertyValue(prop);\n  }\n};\n","// ReactiveVar is like a portable Session var.  When you get it,\n// it registers a dependency, and when it's set, it invalidates\n// its dependencies.\n//\n// When set to a primitive value, invalidation\n// is only fired if the new value is !== the old one.  When set\n// to an object value, invalidation always happens.  Each behavior\n// may be desirable in different test scenarios.\n// body and keeps track of it, providing methods that query it,\n// mutate, and destroy it.\n//\n// Constructor, with optional 'new':\n// var R = [new] ReactiveVar([initialValue])\n\nReactiveVar = function(initialValue) {\n  if (! (this instanceof ReactiveVar))\n    return new ReactiveVar(initialValue);\n\n  this._value = (typeof initialValue === \"undefined\" ? null :\n                 initialValue);\n  this._deps = new Deps.Dependency;\n};\n\nReactiveVar.prototype.get = function() {\n  this._deps.depend();\n  return this._value;\n};\n\nReactiveVar.prototype.set = function(newValue) {\n  // detect equality and don't invalidate dependers\n  // when value is a primitive.\n  if ((typeof newValue !== 'object') && this._value === newValue)\n    return;\n\n  this._value = newValue;\n\n  this._deps.changed();\n};\n\nReactiveVar.prototype.numListeners = function() {\n  // accesses private field (tests want to know)\n  return _.keys(this._deps._dependentsById).length;\n};\n","// This file allows you to write tests that expect certain callbacks to be\n// called in certain orders, or optionally in groups where the order does not\n// matter.  It can be set up in either a synchronous manner, so that each\n// callback must have already occured before you call expectResult & its ilk, or\n// in an asynchronous manner, so that the logger yields and waits a reasonable\n// timeout for the callback.  Because we're using Node Fibers to yield & start\n// ourselves, the asynchronous version is only available on the server.\n\nvar Fiber = Meteor.isServer ? Npm.require('fibers') : null;\n\nvar TIMEOUT = 1000;\n\n// Run the given function, passing it a correctly-set-up callback logger as an\n// argument.  If we're meant to be running asynchronously, the function gets its\n// own Fiber.\n\nwithCallbackLogger = function (test, callbackNames, async, fun) {\n  var logger = new CallbackLogger(test, callbackNames);\n  if (async) {\n    if (!Fiber)\n      throw new Error(\"Fiber is not available\");\n    logger.fiber = Fiber(_.bind(fun, null, logger));\n    logger.fiber.run();\n  } else {\n    fun(logger);\n  }\n};\n\nvar CallbackLogger = function (test, callbackNames) {\n  var self = this;\n  self._log = [];\n  self._test = test;\n  self._yielded = false;\n  _.each(callbackNames, function (callbackName) {\n    self[callbackName] = function () {\n      var args = _.toArray(arguments);\n      self._log.push({callback: callbackName, args: args});\n      if (self.fiber) {\n        setTimeout(function () {\n          if (self._yielded)\n            self.fiber.run(callbackName);\n        }, 0);\n      }\n    };\n  });\n};\n\nCallbackLogger.prototype._yield = function (arg) {\n  var self = this;\n  self._yielded = true;\n  var y = Fiber.yield(arg);\n  self._yielded = false;\n  return y;\n};\n\nCallbackLogger.prototype.expectResult = function (callbackName, args) {\n  var self = this;\n  self._waitForLengthOrTimeout(1);\n  if (_.isEmpty(self._log)) {\n    self._test.fail([\"Expected callback \" + callbackName + \" got none\"]);\n    return;\n  }\n  var result = self._log.shift();\n  self._test.equal(result.callback, callbackName);\n  self._test.equal(result.args, args);\n};\n\nCallbackLogger.prototype.expectResultOnly = function (callbackName, args) {\n  var self = this;\n  self.expectResult(callbackName, args);\n  self._expectNoResultImpl();\n}\n\nCallbackLogger.prototype._waitForLengthOrTimeout = function (len) {\n  var self = this;\n  if (self.fiber) {\n    var timeLeft = TIMEOUT;\n    var startTime = new Date();\n    var handle = setTimeout(function () {\n      self.fiber.run(handle);\n    }, TIMEOUT);\n    while (self._log.length < len) {\n      if (self._yield() === handle) {\n        break;\n      }\n    }\n    clearTimeout(handle);\n  }\n};\n\nCallbackLogger.prototype.expectResultUnordered = function (list) {\n  var self = this;\n\n  self._waitForLengthOrTimeout(list.length);\n\n  list = _.clone(list); // shallow copy.\n  var i = list.length;\n  while (i > 0) {\n    var found = false;\n    var dequeued = self._log.shift();\n    for (var j = 0; j < list.length; j++) {\n      if (_.isEqual(list[j], dequeued)) {\n        list.splice(j, 1);\n        found = true;\n        break;\n      }\n    }\n    if (!found)\n      self._test.fail([\"Found unexpected result: \" + JSON.stringify(dequeued)]);\n    i--;\n  }\n};\n\nCallbackLogger.prototype._expectNoResultImpl = function () {\n  var self = this;\n  self._test.length(self._log, 0);\n};\n\nCallbackLogger.prototype.expectNoResult = function () {\n  var self = this;\n  if (self.fiber) {\n    var handle = setTimeout(function () {\n      self.fiber.run(handle);\n    }, TIMEOUT);\n    var foo = self._yield();\n    while (_.isEmpty(self._log) && foo !== handle) {\n      foo = self._yield();\n    }\n    clearTimeout(handle);\n  }\n  self._expectNoResultImpl();\n};\n"]}