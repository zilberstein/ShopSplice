{"version":3,"file":"/packages/mongo-livedata:tests.js","sources":["mongo-livedata/mongo_livedata_tests.js","mongo-livedata/allow_tests.js","mongo-livedata/collection_tests.js","mongo-livedata/observe_changes_tests.js","mongo-livedata/oplog_tests.js","mongo-livedata/doc_fetcher_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,sE;AACA,2D;;AAEA,oB;AACA,sB;AACA,kB;AACA,wD;AACA,0B;AACA,qC;AACA,8C;AACA,4C;AACA,U;;AAEA,6C;AACA,8D;AACA,O;AACA,mD;AACA,yB;AACA,+C;AACA,wB;AACA,S;AACA,K;AACA,K;AACA,C;;AAEA,+B;AACA,wB;AACA,Q;AACA,U;AACA,0C;AACA,qD;AACA,uB;AACA,G;AACA,E;;AAEA,2B;;AAEA,8B;AACA,iB;AACA,E;;AAEA,iE;AACA,gB;AACA,2B;AACA,6B;AACA,G;AACA,oD;AACA,+B;AACA,E;;AAEA,wE;AACA,oD;AACA,uB;AACA,iB;AACA,G;;AAEA,kB;AACA,iB;AACA,oC;AACA,6D;AACA,iD;AACA,mD;AACA,mD;AACA,8B;AACA,4B;AACA,Y;AACA,6C;AACA,sE;AACA,M;AACA,U;AACA,sD;AACA,G;AACA,E;;AAEA,qD;AACA,yB;;AAEA,8E;AACA,gF;AACA,wE;AACA,wD;AACA,E;AACA,+E;AACA,uD;AACA,6D;AACA,kB;AACA,wE;;AAEA,e;AACA,Y;AACA,8B;AACA,iC;AACA,yC;AACA,wE;AACA,Q;AACA,4B;AACA,gB;AACA,8D;AACA,Q;AACA,6B;AACA,c;AACA,8D;AACA,O;AACA,M;AACA,G;;AAEA,2E;AACA,mE;AACA,uB;;AAEA,wC;AACA,kB;AACA,oC;AACA,iC;AACA,yC;AACA,mB;AACA,kB;AACA,4C;AACA,uD;AACA,kD;AACA,uB;AACA,wC;AACA,mC;AACA,E;;AAEA,sB;AACA,a;AACA,4D;AACA,uB;AACA,8B;AACA,mG;AACA,0D;AACA,I;AACA,oB;AACA,C;;AAEA,+B;AACA,6D;;AAEA,yC;AACA,2C;AACA,kB;AACA,qB;AACA,mB;AACA,4D;AACA,E;AACA,yB;AACA,4C;AACA,6C;AACA,+D;AACA,0D;AACA,yE;AACA,kG;AACA,0C;AACA,gE;AACA,uC;AACA,G;AACA,kF;;;AAGA,sB;AACA,qD;;AAEA,sD;;AAEA,8E;AACA,2B;AACA,4C;;AAEA,yC;AACA,kC;AACA,M;;AAEA,0D;AACA,+C;AACA,oB;;AAEA,wC;AACA,8B;AACA,uC;AACA,gB;AACA,iC;AACA,S;AACA,Q;;AAEA,4B;AACA,iC;AACA,mB;AACA,W;;AAEA,kC;AACA,O;;AAEA,4B;AACA,kC;;AAEA,yD;AACA,gC;AACA,iB;AACA,O;AACA,O;AACA,G;AACA,G;;;AAGA,2F;AACA,yB;AACA,kB;AACA,wB;AACA,+E;AACA,+E;AACA,U;AACA,qF;AACA,wF;AACA,G;;AAEA,e;AACA,0D;AACA,mD;AACA,oE;AACA,M;AACA,sD;AACA,uE;AACA,M;AACA,mD;AACA,oE;AACA,M;AACA,yC;AACA,iD;AACA,K;AACA,K;;AAEA,qC;AACA,0B;AACA,U;AACA,Y;AACA,4C;AACA,uD;AACA,yB;AACA,K;;AAEA,kB;AACA,a;AACA,e;AACA,I;;AAEA,8C;AACA,qC;AACA,4B;;AAEA,8C;AACA,I;;AAEA,+C;AACA,6C;AACA,kD;;AAEA,4C;AACA,2C;AACA,iD;AACA,sC;AACA,8C;AACA,K;;AAEA,4C;AACA,4C;AACA,iD;AACA,iD;AACA,uC;AACA,K;;AAEA,oE;AACA,oE;AACA,sE;AACA,sE;;;AAGA,iD;AACA,gB;AACA,gB;AACA,mB;AACA,yC;AACA,2B;AACA,gC;AACA,kC;AACA,gB;AACA,0B;AACA,yE;AACA,4E;AACA,8E;AACA,8E;AACA,+E;AACA,0E;AACA,4B;AACA,K;AACA,mB;AACA,mD;AACA,gC;AACA,c;AACA,wB;;AAEA,e;AACA,Y;AACA,gD;AACA,4E;AACA,2C;AACA,2B;AACA,gC;AACA,kC;AACA,qB;AACA,uB;;AAEA,0E;AACA,qB;;AAEA,iC;AACA,8E;AACA,yB;AACA,K;;AAEA,iD;AACA,uE;AACA,yB;AACA,4E;AACA,uB;AACA,K;;AAEA,2D;AACA,yE;AACA,kE;AACA,4E;AACA,wB;AACA,K;;AAEA,wC;AACA,sD;AACA,yB;AACA,iD;AACA,K;;AAEA,uC;AACA,4B;AACA,iD;AACA,K;;AAEA,iC;AACA,wC;AACA,yB;AACA,iD;AACA,K;;AAEA,a;AACA,e;AACA,G;;AAEA,6F;;AAEA,wB;AACA,W;AACA,wB;AACA,8E;AACA,U;AACA,qF;AACA,G;;AAEA,+D;AACA,kB;AACA,mB;AACA,yD;;AAEA,0D;AACA,2C;AACA,qB;AACA,4C;AACA,M;AACA,sD;AACA,wB;AACA,8C;AACA,mC;AACA,M;AACA,mD;AACA,sB;AACA,2C;AACA,kC;AACA,yC;AACA,M;AACA,yC;AACA,wB;AACA,0C;AACA,iC;AACA,K;AACA,K;;AAEA,8E;AACA,4E;AACA,a;AACA,wB;AACA,8C;AACA,oC;AACA,oD;AACA,G;;AAEA,e;;AAEA,mE;AACA,+D;AACA,sD;AACA,qE;AACA,4B;AACA,0B;AACA,+C;AACA,I;;AAEA,oC;AACA,0B;AACA,U;AACA,Y;AACA,4C;AACA,uD;AACA,yB;AACA,K;AACA,I;;AAEA,4B;AACA,6C;AACA,iB;AACA,mB;AACA,a;AACA,K;;AAEA,yC;;AAEA,+B;AACA,0B;AACA,6C;;AAEA,sC;AACA,oC;AACA,6C;AACA,wE;AACA,wB;AACA,wC;AACA,sD;AACA,gB;AACA,+B;AACA,wC;AACA,0B;AACA,6B;AACA,0C;AACA,iC;AACA,uB;AACA,uD;AACA,4C;AACA,c;AACA,mD;AACA,mC;AACA,0D;AACA,+B;AACA,gC;AACA,8B;AACA,gB;AACA,qD;AACA,mC;AACA,gC;AACA,S;AACA,O;AACA,0B;AACA,4C;;AAEA,O;;AAEA,qE;AACA,iB;AACA,+C;AACA,gC;;AAEA,gE;AACA,6C;AACA,0C;AACA,qD;AACA,O;;AAEA,yB;AACA,I;;AAEA,W;;AAEA,G;;AAEA,+F;AACA,yB;AACA,W;AACA,wB;AACA,8E;AACA,U;AACA,qF;AACA,G;;AAEA,oB;AACA,8C;AACA,2B;AACA,+E;AACA,6E;AACA,mB;AACA,kB;AACA,K;AACA,K;AACA,0C;AACA,4B;AACA,wC;AACA,O;AACA,K;AACA,gB;AACA,2C;AACA,2B;;AAEA,e;AACA,G;;AAEA,4G;AACA,wB;AACA,W;AACA,wB;AACA,8E;AACA,U;AACA,iF;AACA,G;;AAEA,kB;;AAEA,oC;AACA,2B;AACA,oC;AACA,M;AACA,gC;AACA,6B;AACA,oB;AACA,K;AACA,K;;AAEA,yB;;AAEA,kE;AACA,Y;AACA,0B;AACA,mC;AACA,K;AACA,yB;AACA,6C;;AAEA,6E;AACA,0B;AACA,yB;AACA,0C;AACA,K;AACA,yB;AACA,wC;;AAEA,0E;AACA,iB;AACA,yB;AACA,0C;AACA,K;AACA,yB;;AAEA,qC;AACA,iC;AACA,sD;;AAEA,e;AACA,G;;AAEA,oD;AACA,sB;AACA,+G;AACA,2B;AACA,kF;;AAEA,+B;AACA,wC;AACA,gC;AACA,8B;AACA,iC;AACA,kC;AACA,W;AACA,O;AACA,O;AACA,iC;AACA,oE;AACA,4B;AACA,6B;AACA,O;AACA,gC;;AAEA,kB;;AAEA,iB;AACA,K;;AAEA,mG;AACA,2B;AACA,4E;;AAEA,uC;AACA,sB;AACA,uB;AACA,oC;AACA,6C;AACA,S;AACA,Q;AACA,qB;AACA,0C;AACA,wC;AACA,U;AACA,O;AACA,2D;AACA,8C;AACA,M;;AAEA,wC;AACA,wC;AACA,wB;AACA,mB;AACA,8B;AACA,mD;;AAEA,+D;AACA,e;AACA,4B;AACA,8C;AACA,O;AACA,oB;AACA,8B;AACA,mD;;AAEA,gC;AACA,wB;AACA,oB;AACA,8B;AACA,uD;AACA,uD;AACA,0D;AACA,yB;AACA,qC;AACA,8B;;AAEA,wE;AACA,oD;AACA,oC;AACA,+D;;AAEA,kC;AACA,4B;AACA,4C;AACA,O;AACA,8B;AACA,8B;AACA,qD;AACA,qD;;AAEA,qD;AACA,qB;AACA,8B;AACA,8B;;AAEA,0D;AACA,4B;AACA,4C;AACA,O;AACA,8B;AACA,8B;AACA,qD;;AAEA,4E;AACA,kB;AACA,mE;AACA,qB;AACA,8B;AACA,8B;AACA,yE;AACA,+B;AACA,6C;;AAEA,kD;AACA,wB;AACA,oB;AACA,8B;AACA,uD;AACA,uD;AACA,0D;AACA,gC;AACA,8B;AACA,8B;AACA,+C;AACA,+D;;AAEA,6E;AACA,4B;;AAEA,qB;AACA,qB;;AAEA,iB;AACA,K;;AAEA,+G;AACA,6E;AACA,+E;AACA,4B;AACA,4C;AACA,6B;AACA,c;AACA,6C;AACA,4B;AACA,uB;AACA,mB;AACA,O;AACA,Q;AACA,K;;AAEA,+G;AACA,0D;AACA,4B;AACA,4C;AACA,6B;AACA,c;AACA,8B;AACA,sE;AACA,4B;AACA,4B;AACA,uB;AACA,mB;AACA,O;AACA,Q;AACA,K;;AAEA,+G;AACA,0D;AACA,4B;AACA,4C;AACA,6B;AACA,c;AACA,8B;AACA,4C;AACA,4B;AACA,qC;AACA,uB;AACA,mB;AACA,O;AACA,Q;AACA,K;AACA,C;;;AAGA,qE;AACA,2B;AACA,qC;AACA,0B;AACA,8D;AACA,8C;AACA,K;;AAEA,wE;AACA,c;;AAEA,+C;AACA,wB;AACA,sB;AACA,iB;AACA,+B;AACA,oC;AACA,Q;AACA,G;AACA,G;;AAEA,0E;AACA,2B;AACA,qC;AACA,0B;AACA,iF;AACA,8C;AACA,K;;AAEA,wE;AACA,c;AACA,yE;AACA,wB;AACA,sB;AACA,iB;AACA,+B;AACA,oC;AACA,uD;AACA,Q;AACA,G;AACA,G;;AAEA,uF;AACA,2B;AACA,oB;AACA,kC;AACA,6D;AACA,iB;AACA,M;AACA,oC;AACA,6B;AACA,iC;AACA,yB;AACA,8B;AACA,M;AACA,qC;AACA,0B;AACA,iF;AACA,8C;AACA,K;;AAEA,yE;AACA,Y;AACA,2C;AACA,oC;AACA,O;AACA,+C;AACA,oC;AACA,iB;AACA,O;AACA,8E;AACA,wB;AACA,sB;AACA,oC;AACA,4B;AACA,yB;AACA,6B;AACA,S;AACA,oC;AACA,kD;AACA,oD;AACA,8E;AACA,wC;AACA,yE;AACA,sB;AACA,2B;AACA,Q;AACA,I;AACA,2B;AACA,oB;AACA,8E;AACA,wB;AACA,sB;AACA,oB;AACA,Q;AACA,8E;AACA,wB;AACA,sB;AACA,oB;AACA,Q;AACA,I;AACA,2B;AACA,oB;AACA,8E;AACA,6D;AACA,mC;AACA,+D;AACA,kB;AACA,0B;AACA,G;AACA,G;;AAEA,+E;AACA,2B;AACA,8D;AACA,qC;AACA,8D;AACA,gE;AACA,gE;AACA,gE;AACA,gE;AACA,gE;AACA,4D;AACA,qC;AACA,0B;AACA,iF;AACA,8C;AACA,K;;AAEA,wE;AACA,c;AACA,qD;AACA,wB;AACA,sB;AACA,iB;AACA,+B;AACA,oC;AACA,kC;AACA,4C;AACA,gC;AACA,Q;AACA,G;AACA,G;;AAEA,iF;AACA,2B;AACA,qC;AACA,0B;AACA,iF;AACA,8C;AACA,K;;AAEA,wE;AACA,c;AACA,6E;AACA,sD;AACA,0C;AACA,mD;AACA,wB;AACA,sB;AACA,iB;AACA,+B;AACA,oC;AACA,kC;AACA,0B;AACA,qD;AACA,Q;AACA,G;AACA,G;;AAEA,sB;AACA,2G;AACA,2B;AACA,uF;;AAEA,gC;AACA,gC;AACA,0E;AACA,kB;AACA,wF;AACA,wB;AACA,4B;AACA,mB;AACA,O;AACA,K;;AAEA,2G;AACA,2B;AACA,uF;;AAEA,gC;AACA,gC;AACA,mC;AACA,gC;AACA,gC;AACA,4C;AACA,wB;AACA,4B;AACA,mB;AACA,O;AACA,K;;;AAGA,4G;AACA,2B;AACA,iG;;AAEA,gB;AACA,yC;AACA,wC;AACA,O;;AAEA,8C;AACA,8C;;AAEA,mB;AACA,2B;AACA,0C;AACA,oD;AACA,4E;AACA,0E;AACA,4E;AACA,4C;AACA,8D;AACA,S;AACA,S;AACA,iC;AACA,M;;AAEA,uB;AACA,8B;AACA,+C;AACA,8B;AACA,+C;AACA,iD;;AAEA,gD;AACA,iB;AACA,oB;AACA,M;;AAEA,6E;AACA,qE;AACA,yC;AACA,uC;AACA,O;AACA,e;AACA,Y;AACA,yD;;AAEA,yE;AACA,e;AACA,yC;AACA,uD;AACA,O;AACA,e;AACA,Y;AACA,yD;;AAEA,4E;AACA,yC;AACA,qE;AACA,O;AACA,e;AACA,Y;AACA,wE;AACA,oB;;AAEA,oD;AACA,iB;AACA,K;;AAEA,wF;AACA,2B;AACA,sG;;AAEA,iC;AACA,Y;AACA,S;AACA,oD;AACA,iB;AACA,c;AACA,K;AACA,qB;AACA,uE;;AAEA,S;AACA,mC;AACA,iB;AACA,c;AACA,K;AACA,qB;AACA,wD;AACA,wE;AACA,K;;AAEA,wB;;AAEA,8E;AACA,oB;AACA,uE;AACA,8C;AACA,0D;AACA,gN;AACA,+B;AACA,wC;AACA,+E;AACA,qD;AACA,wE;AACA,sB;AACA,0E;AACA,yC;AACA,4C;AACA,2C;AACA,8C;AACA,yD;AACA,iB;AACA,U;AACA,gC;AACA,kC;;AAEA,0E;AACA,8C;AACA,sB;AACA,0C;AACA,oG;;AAEA,0E;AACA,8C;AACA,sB;AACA,2C;AACA,oG;;AAEA,wB;;AAEA,oE;;AAEA,kD;AACA,kD;AACA,oE;AACA,8C;AACA,sB;AACA,0C;AACA,iG;;AAEA,oE;AACA,8C;AACA,sB;AACA,2C;AACA,iG;;AAEA,wB;;AAEA,sC;;AAEA,iF;AACA,8C;AACA,sB;AACA,0C;AACA,yC;AACA,oG;;AAEA,iC;AACA,8C;AACA,sE;AACA,W;;;AAGA,iF;AACA,8C;AACA,sB;AACA,2C;AACA,mF;AACA,0F;;AAEA,2D;AACA,kG;AACA,sG;;AAEA,iC;AACA,uD;AACA,6C;AACA,oE;AACA,4C;AACA,8C;AACA,sB;AACA,2C;AACA,0G;AACA,8G;;AAEA,iC;AACA,uD;AACA,6C;AACA,oE;AACA,4C;AACA,8C;AACA,sB;AACA,0C;AACA,wC;AACA,0D;AACA,sE;AACA,sE;AACA,sE;;AAEA,mC;AACA,8D;AACA,6C;AACA,oD;AACA,8C;AACA,sB;AACA,kD;AACA,0D;AACA,sE;AACA,sE;AACA,oE;AACA,wD;AACA,2C;AACA,2C;;AAEA,wC;;AAEA,8C;AACA,wE;AACA,+D;AACA,+C;AACA,sB;AACA,4C;AACA,qC;AACA,sF;AACA,sE;AACA,sE;AACA,wB;;AAEA,8B;AACA,0B;AACA,W;AACA,4B;AACA,wC;AACA,Y;AACA,8B;AACA,U;AACA,+C;AACA,sB;AACA,2C;AACA,4C;AACA,qC;AACA,8D;AACA,oE;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,oE;AACA,8D;AACA,oC;AACA,kC;AACA,e;AACA,yC;AACA,yD;AACA,iB;AACA,E;;AAEA,+E;AACA,qE;AACA,wE;AACA,6E;AACA,iD;AACA,yE;AACA,+E;AACA,gD;AACA,oI;AACA,iB;AACA,+B;AACA,yD;AACA,6C;AACA,+C;AACA,sD;AACA,yB;AACA,+E;AACA,oE;AACA,4C;AACA,gB;AACA,gD;AACA,8B;AACA,mC;AACA,uD;AACA,kC;AACA,oC;AACA,S;;AAEA,oB;AACA,4C;AACA,2B;AACA,gD;AACA,4B;AACA,4C;AACA,kD;AACA,W;AACA,2F;AACA,qE;AACA,U;;AAEA,4B;AACA,+E;;AAEA,4B;AACA,4C;AACA,2B;AACA,gD;AACA,0B;AACA,6C;AACA,wG;AACA,oC;AACA,mE;;AAEA,sE;;AAEA,gD;AACA,gD;AACA,2E;AACA,U;;AAEA,oB;AACA,4C;AACA,2B;AACA,gD;AACA,4B;AACA,4C;AACA,+C;AACA,W;AACA,wF;;AAEA,+D;AACA,U;;AAEA,6C;AACA,gD;AACA,0B;AACA,6C;AACA,qG;;AAEA,iC;;AAEA,wC;AACA,2E;AACA,U;;AAEA,oB;AACA,4C;AACA,2B;AACA,gD;AACA,4B;AACA,4C;AACA,oD;AACA,W;AACA,2C;AACA,yF;;AAEA,yD;AACA,2C;AACA,6E;AACA,iD;AACA,oC;AACA,uF;AACA,6D;AACA,iC;AACA,+E;AACA,e;AACA,kB;AACA,4E;AACA,2E;AACA,gE;AACA,gF;AACA,0E;AACA,6E;AACA,W;AACA,U;;AAEA,oB;AACA,4C;AACA,2B;AACA,gD;AACA,0B;AACA,6C;AACA,yF;;AAEA,4D;AACA,uF;AACA,yF;;AAEA,oC;AACA,kF;AACA,gF;AACA,iD;AACA,iC;AACA,wD;AACA,uC;AACA,U;;AAEA,oB;AACA,4C;AACA,2B;AACA,gD;AACA,0B;AACA,6C;AACA,uF;AACA,iG;;AAEA,mC;AACA,gD;AACA,iC;AACA,wD;AACA,uC;;AAEA,U;;AAEA,oB;AACA,4C;AACA,2B;;AAEA,gD;AACA,4B;AACA,4C;AACA,mD;AACA,W;AACA,0C;AACA,+D;AACA,iD;AACA,yD;AACA,wE;AACA,uB;AACA,U;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,sB;AACA,oI;AACA,a;AACA,2B;AACA,qD;AACA,yE;AACA,8D;AACA,sC;;AAEA,gC;AACA,gC;AACA,+F;AACA,wB;AACA,4B;AACA,kF;AACA,0B;AACA,8B;AACA,kF;AACA,4B;AACA,gC;AACA,8D;AACA,kC;AACA,gE;AACA,oC;AACA,2B;AACA,e;AACA,a;AACA,W;AACA,S;AACA,O;AACA,K;AACA,C;;AAEA,+E;AACA,2C;AACA,sB;AACA,8C;AACA,6I;AACA,6B;AACA,+G;AACA,iB;AACA,iE;AACA,gE;AACA,oE;AACA,Q;AACA,wB;AACA,+F;AACA,0B;AACA,qB;AACA,S;AACA,O;AACA,K;AACA,C;;AAEA,uE;AACA,8C;AACA,+J;AACA,6B;AACA,sC;AACA,oB;AACA,wE;AACA,yF;;AAEA,c;AACA,kE;AACA,wC;AACA,sB;AACA,0C;AACA,0D;AACA,2C;;AAEA,kE;AACA,wC;AACA,sB;AACA,qC;AACA,0D;AACA,2C;;AAEA,kE;AACA,wC;AACA,sB;AACA,0C;AACA,0D;AACA,yC;AACA,2C;;AAEA,sB;;AAEA,2D;AACA,wC;AACA,gC;AACA,wB;AACA,0B;AACA,6D;AACA,qB;AACA,oC;AACA,c;AACA,kC;AACA,O;AACA,0D;AACA,0C;;AAEA,wC;AACA,wE;AACA,wC;AACA,sB;AACA,2C;AACA,0D;AACA,wC;AACA,4C;;AAEA,8B;AACA,2D;AACA,wC;AACA,mC;AACA,0D;AACA,wC;AACA,4C;;AAEA,uE;AACA,wE;AACA,wC;AACA,mC;AACA,0D;AACA,wC;AACA,4C;;AAEA,O;AACA,K;AACA,G;;AAEA,wC;;AAEA,mE;AACA,+D;AACA,oD;AACA,yE;AACA,oD;AACA,6D;AACA,oC;AACA,uE;AACA,oC;AACA,uD;AACA,2B;;AAEA,a;AACA,uC;AACA,e;AACA,kB;AACA,kB;AACA,iB;AACA,2B;AACA,Q;AACA,M;AACA,a;AACA,0B;AACA,0B;AACA,e;AACA,yB;AACA,M;AACA,I;;AAEA,a;AACA,uC;AACA,e;AACA,kB;AACA,qB;AACA,oB;AACA,+B;AACA,+F;AACA,sG;AACA,sG;AACA,W;AACA,kB;AACA,oB;AACA,qB;AACA,+B;AACA,uD;AACA,4C;AACA,U;AACA,Q;AACA,M;AACA,a;AACA,gB;AACA,2C;AACA,4B;AACA,2C;AACA,+C;AACA,0C;AACA,yC;AACA,S;AACA,gB;AACA,4B;AACA,2C;AACA,2C;AACA,yC;AACA,Q;AACA,M;AACA,I;;AAEA,6C;AACA,qD;AACA,yB;AACA,G;;AAEA,kD;AACA,2B;AACA,qC;AACA,0B;AACA,8D;AACA,8C;AACA,K;AACA,qD;AACA,uB;AACA,+B;AACA,kC;AACA,O;AACA,qD;AACA,uE;AACA,4B;AACA,+B;AACA,iC;AACA,8B;AACA,0D;AACA,Q;AACA,G;AACA,G;;AAEA,qD;AACA,2B;AACA,oB;AACA,sC;AACA,0B;AACA,mE;AACA,mD;AACA,K;AACA,2D;AACA,S;AACA,4C;AACA,wD;AACA,iB;AACA,W;AACA,K;AACA,4E;AACA,gC;AACA,Q;AACA,I;AACA,2B;AACA,oB;AACA,wC;AACA,kD;AACA,I;AACA,2B;AACA,oB;AACA,0B;AACA,wD;AACA,qD;AACA,K;AACA,G;AACA,G;;;AAGA,sB;;AAEA,+E;AACA,6B;AACA,sB;AACA,wC;AACA,4B;AACA,2E;AACA,e;AACA,2C;AACA,2C;AACA,0C;AACA,S;AACA,6B;AACA,6B;AACA,6B;AACA,2C;AACA,8B;AACA,S;;AAEA,oD;AACA,qC;AACA,4C;AACA,gB;AACA,M;;AAEA,6B;AACA,sB;AACA,yC;AACA,0E;AACA,+B;AACA,W;AACA,yC;AACA,4B;AACA,W;AACA,sC;AACA,uB;AACA,sB;AACA,W;AACA,O;AACA,M;;AAEA,6B;AACA,sB;AACA,uB;AACA,iD;AACA,uC;AACA,qC;AACA,O;AACA,M;;AAEA,6B;AACA,sB;AACA,sB;AACA,e;AACA,oC;AACA,oD;AACA,qC;AACA,mC;AACA,K;AACA,K;;AAEA,kE;AACA,6B;AACA,sB;AACA,4B;AACA,0E;AACA,uB;;AAEA,2C;AACA,6B;AACA,S;;AAEA,oD;AACA,qC;AACA,4C;AACA,gB;AACA,M;;AAEA,6B;AACA,sB;AACA,yC;AACA,iF;AACA,+B;AACA,W;AACA,yC;AACA,4B;AACA,W;AACA,sC;AACA,uB;AACA,sB;AACA,W;AACA,O;AACA,M;;AAEA,6B;AACA,sB;AACA,uB;AACA,qD;AACA,wC;AACA,iD;AACA,oC;AACA,iD;AACA,W;AACA,W;AACA,qC;AACA,qC;AACA,uC;AACA,0C;AACA,kB;AACA,O;AACA,M;;AAEA,6B;AACA,sB;AACA,uB;AACA,iC;AACA,mC;AACA,mC;AACA,mC;AACA,kC;AACA,W;AACA,O;AACA,kC;AACA,K;AACA,K;AACA,C;;AAEA,gH;AACA,0B;AACA,2B;AACA,2C;AACA,2B;AACA,kE;AACA,wC;AACA,2C;AACA,2C;AACA,iB;AACA,K;AACA,G;;AAEA,sH;AACA,0B;AACA,iE;AACA,2B;AACA,oD;AACA,0B;AACA,2C;AACA,iB;AACA,K;AACA,G;;AAEA,uH;AACA,0B;AACA,iE;AACA,2B;AACA,gC;AACA,4C;AACA,e;AACA,G;;AAEA,8E;AACA,2B;AACA,oB;AACA,qC;AACA,0B;AACA,8D;AACA,8C;AACA,K;;AAEA,4D;;AAEA,qC;AACA,wE;AACA,0B;AACA,iC;AACA,Y;AACA,I;AACA,2B;AACA,oB;AACA,qC;AACA,c;AACA,mB;AACA,iC;AACA,oB;AACA,yC;AACA,4B;AACA,qB;AACA,6C;AACA,0E;AACA,Y;AACA,G;AACA,G;;AAEA,sB;AACA,8F;AACA,wD;;AAEA,mC;AACA,qB;AACA,e;AACA,mB;AACA,iC;AACA,oB;AACA,a;;AAEA,qD;AACA,uC;AACA,6B;AACA,4C;;AAEA,sE;AACA,+B;AACA,sB;AACA,e;AACA,mB;AACA,iC;AACA,oB;AACA,a;;AAEA,sC;AACA,wB;AACA,8B;AACA,iD;AACA,K;AACA,C;;AAEA,iC;AACA,2F;AACA,6B;AACA,6C;AACA,0E;AACA,4C;AACA,mD;AACA,iD;AACA,4D;AACA,4B;AACA,G;AACA,oE;AACA,iD;AACA,kD;AACA,8D;AACA,6B;AACA,G;;AAEA,qG;AACA,iD;AACA,6C;;AAEA,uD;AACA,qB;;AAEA,+E;AACA,uE;AACA,kE;AACA,sB;AACA,gF;AACA,qC;;AAEA,kB;AACA,yE;AACA,kC;AACA,yC;AACA,M;AACA,oC;AACA,2C;AACA,M;AACA,4B;AACA,mC;AACA,K;AACA,K;AACA,yC;AACA,yB;AACA,2D;;AAEA,6E;AACA,gF;AACA,+E;AACA,oE;AACA,0B;AACA,qD;AACA,K;AACA,yB;AACA,6D;;AAEA,gB;AACA,G;;AAEA,uF;AACA,gD;AACA,6C;;AAEA,oD;AACA,qB;;AAEA,+E;AACA,uE;AACA,kE;AACA,sB;AACA,gF;AACA,qC;;AAEA,yD;AACA,iB;AACA,M;;AAEA,yB;AACA,6C;AACA,kC;AACA,4C;AACA,K;AACA,K;AACA,2D;AACA,gC;AACA,yE;AACA,uB;;AAEA,6B;AACA,0C;AACA,2B;AACA,6C;AACA,K;AACA,K;AACA,oC;AACA,iE;AACA,2B;AACA,G;;;AAGA,6F;AACA,gD;AACA,6C;;AAEA,6C;AACA,uC;AACA,6C;AACA,U;;AAEA,kB;AACA,qD;AACA,kC;AACA,yC;AACA,M;AACA,4B;AACA,+B;AACA,M;AACA,4B;AACA,mC;AACA,K;AACA,K;AACA,yB;AACA,0B;AACA,uD;AACA,oB;AACA,0B;AACA,oB;AACA,G;AACA,kE;AACA,kE;;AAEA,2E;AACA,8E;AACA,gF;AACA,qC;;AAEA,iD;AACA,0B;AACA,2B;AACA,K;;AAEA,yB;AACA,0B;AACA,uD;AACA,oB;AACA,0B;AACA,oB;AACA,G;AACA,kD;AACA,kD;;AAEA,2B;AACA,a;AACA,0B;AACA,2C;AACA,K;;AAEA,yB;AACA,kE;;AAEA,gB;AACA,G;;AAEA,4C;AACA,2E;AACA,gD;AACA,qB;AACA,qB;AACA,E;AACA,oC;AACA,sB;AACA,wD;AACA,I;AACA,4B;AACA,0C;AACA,gD;AACA,iD;AACA,I;AACA,yB;AACA,4B;AACA,I;AACA,4B;AACA,kD;AACA,G;AACA,G;;AAEA,iD;AACA,kD;AACA,G;;AAEA,yD;AACA,2B;AACA,oB;AACA,+C;AACA,0B;AACA,8D;AACA,8C;AACA,K;;AAEA,4D;AACA,yB;AACA,gD;;AAEA,qC;AACA,oC;AACA,6C;AACA,kC;AACA,0B;AACA,iC;AACA,U;AACA,I;AACA,2B;AACA,oB;AACA,sB;AACA,2D;AACA,oC;AACA,6C;AACA,Q;AACA,sC;AACA,6C;AACA,Q;AACA,8B;AACA,qC;AACA,O;AACA,O;AACA,iC;AACA,oC;AACA,6B;AACA,8C;AACA,yD;;AAEA,+C;AACA,6E;AACA,c;AACA,4B;AACA,6B;AACA,gE;AACA,+B;AACA,4B;AACA,Y;AACA,O;AACA,I;AACA,2B;AACA,oB;AACA,iC;AACA,oC;AACA,uE;;AAEA,0E;AACA,gD;AACA,4B;AACA,6B;AACA,+D;AACA,6B;AACA,0B;AACA,U;AACA,O;AACA,I;AACA,2B;AACA,oB;AACA,iC;AACA,oC;AACA,uE;;AAEA,yC;AACA,sD;AACA,iD;AACA,4B;AACA,6B;AACA,0D;AACA,6B;AACA,0B;AACA,U;AACA,O;AACA,I;AACA,2B;AACA,oB;AACA,iC;AACA,oC;AACA,iE;;AAEA,uB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtnEA,sB;AACA,iD;;AAEA,4B;;AAEA,6E;AACA,8E;AACA,8E;AACA,gF;AACA,6E;AACA,uB;AACA,+D;AACA,yB;AACA,gC;AACA,qB;AACA,oC;;AAEA,0E;AACA,wE;AACA,gE;AACA,iD;;AAEA,qB;AACA,8C;AACA,gD;AACA,qC;AACA,8D;AACA,gC;AACA,c;AACA,2C;AACA,wE;AACA,gD;AACA,sC;AACA,oE;AACA,+B;AACA,wC;AACA,mB;AACA,wD;AACA,gC;AACA,U;AACA,0B;AACA,O;;AAEA,sC;AACA,wB;AACA,M;;AAEA,8C;AACA,gD;AACA,qC;AACA,gD;AACA,oD;AACA,0E;AACA,qC;AACA,6D;AACA,gE;AACA,+D;AACA,iE;AACA,oE;AACA,sE;AACA,mE;AACA,qE;AACA,kE;AACA,oE;AACA,4D;AACA,8D;AACA,+D;AACA,iE;AACA,6D;AACA,8C;AACA,qB;AACA,S;;AAEA,0B;AACA,+C;AACA,wC;AACA,mC;AACA,U;AACA,wC;AACA,mC;AACA,U;AACA,wC;AACA,mC;AACA,S;AACA,S;AACA,+C;AACA,4E;AACA,mB;AACA,wB;AACA,wC;AACA,qC;AACA,S;AACA,S;;AAEA,0E;AACA,qB;AACA,uC;AACA,+B;AACA,U;AACA,uC;AACA,+B;AACA,U;AACA,wC;AACA,+B;AACA,S;AACA,U;AACA,uC;AACA,gC;AACA,U;AACA,yD;AACA,wD;AACA,U;AACA,uC;AACA,gC;AACA,S;AACA,S;;AAEA,uE;AACA,qB;AACA,uC;AACA,gC;AACA,U;AACA,wC;AACA,gC;AACA,S;AACA,U;AACA,uC;AACA,iC;AACA,U;AACA,yD;AACA,wD;AACA,S;AACA,S;;AAEA,c;AACA,0C;AACA,4C;AACA,gD;AACA,gC;AACA,yC;AACA,kC;AACA,W;AACA,wC;AACA,gC;AACA,W;AACA,S;;AAEA,sE;AACA,a;AACA,qD;AACA,6B;AACA,S;AACA,mD;AACA,6B;AACA,S;;AAEA,mE;AACA,qD;AACA,8C;AACA,4C;AACA,uC;AACA,oE;AACA,iC;AACA,kE;AACA,U;AACA,uC;AACA,oE;AACA,iC;AACA,kE;AACA,U;AACA,yB;AACA,S;AACA,8C;AACA,yB;AACA,S;AACA,6C;AACA,yB;AACA,S;;AAEA,mE;AACA,wC;AACA,iD;AACA,4C;AACA,uC;AACA,oE;AACA,iC;AACA,kE;AACA,U;AACA,uC;AACA,oE;AACA,iC;AACA,kE;AACA,U;AACA,yB;AACA,S;AACA,iD;AACA,2C;AACA,S;AACA,K;;AAEA,mB;AACA,K;AACA,C;;AAEA,sB;AACA,uD;AACA,+E;AACA,6C;;AAEA,4B;AACA,kF;AACA,6E;AACA,0D;AACA,wD;;AAEA,wE;AACA,2B;AACA,sD;AACA,iD;AACA,6C;AACA,sE;;AAEA,wD;AACA,8D;AACA,Q;AACA,oD;AACA,wB;AACA,M;;AAEA,kC;AACA,qE;;AAEA,qC;AACA,0E;;AAEA,0E;AACA,qC;AACA,6D;AACA,4C;AACA,+D;AACA,8C;AACA,oE;AACA,mD;AACA,mE;AACA,kD;AACA,kE;AACA,iD;AACA,4D;AACA,2C;AACA,+D;AACA,8C;AACA,6D;AACA,uC;AACA,qB;AACA,S;;;AAGA,+D;AACA,0D;AACA,mE;AACA,+B;AACA,uD;AACA,sE;AACA,uC;AACA,c;AACA,O;AACA,O;;AAEA,8D;AACA,0D;AACA,kE;AACA,+B;AACA,sD;AACA,sE;AACA,uC;AACA,c;AACA,O;AACA,O;;;AAGA,mD;AACA,2D;AACA,+B;AACA,8D;AACA,wD;AACA,oE;AACA,wD;AACA,gD;AACA,wE;AACA,kC;AACA,wE;AACA,c;AACA,gD;AACA,+C;AACA,kC;AACA,wE;AACA,c;;AAEA,mD;AACA,2E;AACA,kC;AACA,+E;AACA,c;AACA,mD;AACA,kD;AACA,kC;AACA,+E;AACA,c;AACA,O;AACA,O;;AAEA,gB;AACA,gB;AACA,gB;AACA,2E;AACA,iC;AACA,gF;AACA,4E;AACA,c;AACA,U;AACA,iC;AACA,oD;AACA,mD;AACA,uC;AACA,4B;AACA,6B;AACA,wB;AACA,c;AACA,oD;AACA,sD;AACA,uB;AACA,uC;AACA,4B;AACA,6B;AACA,wB;AACA,c;AACA,oD;AACA,0D;AACA,uB;AACA,uC;AACA,2B;AACA,c;AACA,oD;AACA,4B;AACA,+B;AACA,uC;AACA,4B;AACA,6B;AACA,c;AACA,U;AACA,iC;AACA,qB;AACA,wE;AACA,kD;AACA,oF;AACA,4B;AACA,c;AACA,oF;AACA,2B;AACA,c;AACA,S;AACA,S;AACA,S;;AAEA,8D;AACA,+B;AACA,+D;AACA,2D;AACA,Y;AACA,Q;AACA,+B;AACA,oF;AACA,8B;AACA,6D;AACA,gE;AACA,Y;AACA,2D;AACA,8D;AACA,O;AACA,O;;AAEA,iE;AACA,+B;AACA,gE;AACA,6D;AACA,Y;AACA,Q;AACA,+B;AACA,8E;AACA,qC;AACA,6D;AACA,Y;AACA,O;AACA,O;;AAEA,kB;AACA,gE;AACA,mB;AACA,sE;AACA,e;AACA,iC;AACA,yD;AACA,qD;AACA,c;AACA,U;AACA,4B;AACA,iC;AACA,uD;AACA,uC;AACA,uC;AACA,iC;AACA,6D;AACA,8B;AACA,qD;AACA,c;AACA,U;AACA,uB;AACA,iC;AACA,4B;AACA,gB;AACA,oC;AACA,wC;AACA,gC;AACA,sE;AACA,gB;AACA,U;AACA,oC;AACA,iC;AACA,4B;AACA,uB;AACA,oC;AACA,wC;AACA,gC;AACA,sE;AACA,gB;AACA,U;AACA,4E;AACA,iC;AACA,4B;AACA,uB;AACA,sC;AACA,wC;AACA,yC;AACA,0D;AACA,0B;AACA,sE;AACA,gB;AACA,U;AACA,kD;AACA,iC;AACA,4B;AACA,uB;AACA,uC;AACA,6B;AACA,wC;AACA,yC;AACA,0D;AACA,yE;AACA,gB;AACA,U;AACA,uE;AACA,iC;AACA,4B;AACA,uB;AACA,yC;AACA,wC;AACA,yC;AACA,sD;AACA,0B;AACA,sE;AACA,gB;AACA,U;AACA,8D;AACA,iC;AACA,iD;AACA,mC;AACA,8B;AACA,0C;AACA,uC;AACA,a;AACA,+D;AACA,sB;AACA,+C;AACA,wC;AACA,oC;AACA,wC;AACA,yC;AACA,0B;AACA,sE;AACA,gB;AACA,U;AACA,+E;AACA,iC;AACA,mC;AACA,8B;AACA,oD;AACA,uC;AACA,a;AACA,U;AACA,8D;AACA,iC;AACA,iD;AACA,mC;AACA,+C;AACA,a;AACA,+D;AACA,sB;AACA,+C;AACA,4B;AACA,wC;AACA,yC;AACA,0B;AACA,sE;AACA,gB;AACA,S;AACA,S;AACA,U;;AAEA,W;AACA,+E;AACA,4B;AACA,qC;;AAEA,mE;AACA,iB;AACA,mC;AACA,2D;AACA,uD;AACA,gB;AACA,Y;;AAEA,8D;AACA,mC;AACA,8B;AACA,iB;AACA,0C;AACA,2C;AACA,yD;AACA,kB;AACA,Y;AACA,wD;AACA,mC;AACA,8B;AACA,kD;AACA,0C;AACA,2C;AACA,yD;AACA,kB;AACA,Y;AACA,0D;AACA,mC;AACA,8B;AACA,mD;AACA,0C;AACA,2C;AACA,yD;AACA,kB;AACA,Y;AACA,8C;AACA,mC;AACA,8B;AACA,gC;AACA,0C;AACA,kC;AACA,yD;AACA,kB;AACA,Y;AACA,gD;AACA,0C;AACA,mC;AACA,4C;AACA,kD;AACA,0C;AACA,kC;AACA,yD;AACA,kB;AACA,Y;AACA,oE;AACA,sC;AACA,mC;AACA,4C;AACA,mE;AACA,0C;AACA,kC;AACA,yD;AACA,kB;AACA,Y;;AAEA,sD;AACA,mC;AACA,8B;AACA,0C;AACA,0C;AACA,2C;AACA,yD;AACA,kB;AACA,Y;;AAEA,qE;AACA,qB;AACA,mC;AACA,8B;AACA,uD;AACA,0C;AACA,kC;AACA,4E;AACA,kB;AACA,Y;AACA,mC;AACA,8B;AACA,2D;AACA,0C;AACA,2C;AACA,sF;AACA,kB;AACA,Y;;AAEA,wD;AACA,mC;AACA,8B;AACA,8B;AACA,sC;AACA,0C;AACA,kC;AACA,sC;AACA,yD;AACA,wE;AACA,kB;AACA,Y;AACA,0E;AACA,mC;AACA,8B;AACA,sD;AACA,0C;AACA,2C;AACA,sC;AACA,yD;AACA,wE;AACA,kB;AACA,Y;AACA,wE;AACA,yB;AACA,mC;AACA,8B;AACA,qE;AACA,0C;AACA,2C;AACA,sC;AACA,yD;AACA,wE;AACA,kB;AACA,Y;AACA,+D;AACA,iC;AACA,mC;AACA,8B;AACA,0B;AACA,sC;AACA,0C;AACA,2C;AACA,sC;AACA,yD;AACA,wE;AACA,kB;AACA,Y;AACA,2C;AACA,mC;AACA,8B;AACA,0B;AACA,sC;AACA,0C;AACA,kC;AACA,wE;AACA,kB;AACA,Y;;AAEA,6E;AACA,mC;AACA,0C;AACA,0D;AACA,yC;AACA,oC;AACA,uD;AACA,gB;AACA,Y;AACA,wE;AACA,gB;AACA,mC;AACA,0C;AACA,0D;AACA,yC;AACA,oC;AACA,uD;AACA,gB;AACA,Y;;AAEA,iD;AACA,mC;AACA,8B;AACA,0B;AACA,4D;AACA,0C;AACA,kC;AACA,2E;AACA,kB;AACA,Y;;AAEA,sC;AACA,mC;AACA,0C;AACA,0D;AACA,gC;AACA,qC;AACA,uD;AACA,gB;AACA,Y;;AAEA,kD;AACA,mC;AACA,uC;AACA,0C;AACA,kC;AACA,uC;AACA,yD;AACA,gB;AACA,W;AACA,W;AACA,S;AACA,+B;AACA,qB;;;;AAIA,4E;AACA,oB;AACA,sB;AACA,gF;AACA,iD;;AAEA,6B;AACA,8C;AACA,O;AACA,6B;AACA,6C;AACA,O;;AAEA,oE;AACA,uB;AACA,0B;AACA,+B;AACA,kC;AACA,S;AACA,+B;AACA,iC;AACA,S;AACA,O;;AAEA,2D;AACA,uB;AACA,6E;AACA,+B;AACA,kC;AACA,S;AACA,+B;AACA,iC;AACA,S;AACA,O;;AAEA,6B;AACA,2E;AACA,O;AACA,K;;AAEA,wE;AACA,iD;AACA,8C;AACA,sB;AACA,2B;AACA,O;AACA,6C;AACA,K;;AAEA,gE;AACA,6E;AACA,8E;AACA,yE;AACA,2C;;AAEA,0B;AACA,iD;AACA,+C;;AAEA,iC;AACA,gD;;AAEA,4B;AACA,gD;;AAEA,gC;AACA,+C;;AAEA,wB;AACA,yC;AACA,Q;AACA,8B;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACtyBA,a;AACA,oD;AACA,mB;AACA,gB;AACA,mB;AACA,gC;AACA,Q;AACA,mD;AACA,M;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACVA,kC;AACA,sB;AACA,8C;AACA,M;AACA,uC;AACA,E;;AAEA,6C;AACA,8C;AACA,2E;AACA,qC;AACA,mD;AACA,0D;AACA,2B;AACA,6D;AACA,iD;AACA,6B;AACA,oB;AACA,kD;AACA,qB;AACA,oC;AACA,4B;AACA,iC;AACA,uC;AACA,0C;AACA,2C;AACA,wE;AACA,sD;AACA,0B;AACA,wF;AACA,Q;AACA,gC;AACA,wF;AACA,2E;AACA,kC;AACA,4F;;AAEA,oB;AACA,4C;;AAEA,oB;;AAEA,4D;AACA,4B;AACA,kB;AACA,iB;AACA,O;AACA,K;AACA,G;;AAEA,sF;AACA,2B;AACA,gG;AACA,qB;AACA,0B;AACA,gD;AACA,gC;AACA,wC;AACA,mC;AACA,gC;AACA,Q;AACA,qC;AACA,gC;AACA,Q;AACA,Q;;AAEA,yC;AACA,0D;;AAEA,uC;AACA,gE;;AAEA,kD;;AAEA,yD;AACA,iB;AACA,K;;AAEA,G;;AAEA,4F;AACA,2B;AACA,gG;AACA,sE;AACA,oD;AACA,uF;AACA,0B;AACA,gB;AACA,e;AACA,K;AACA,G;;;;AAIA,4F;AACA,2B;AACA,gG;AACA,sE;AACA,wE;AACA,+C;AACA,gC;AACA,uB;AACA,mE;AACA,uB;AACA,oE;AACA,K;AACA,0B;AACA,gB;AACA,e;AACA,K;AACA,G;;AAEA,sF;AACA,2B;AACA,gG;AACA,+C;AACA,yC;AACA,8D;;AAEA,sE;;AAEA,2F;;AAEA,yE;AACA,yE;AACA,oC;AACA,0F;AACA,kB;AACA,8C;AACA,kB;AACA,8C;;AAEA,kE;;AAEA,uF;AACA,0B;AACA,gB;AACA,e;AACA,K;AACA,G;;AAEA,sB;AACA,iG;AACA,6B;AACA,kG;AACA,sF;AACA,6C;AACA,oD;;AAEA,0E;;AAEA,iF;;AAEA,6E;AACA,wC;AACA,+E;AACA,2E;AACA,sB;AACA,kD;AACA,sB;AACA,kD;;AAEA,wD;;AAEA,6E;AACA,8B;AACA,oB;AACA,mB;AACA,O;AACA,K;;AAEA,+H;AACA,6B;AACA,kG;AACA,gD;AACA,2F;AACA,gE;AACA,oD;;AAEA,6F;;AAEA,iF;;AAEA,gG;AACA,wC;AACA,+E;;AAEA,oE;AACA,8F;AACA,8B;;AAEA,sB;AACA,kD;AACA,sB;AACA,kD;;AAEA,2E;;AAEA,6E;AACA,8B;AACA,oB;AACA,mB;AACA,O;AACA,K;;AAEA,6H;AACA,6B;AACA,kG;AACA,gD;AACA,2F;AACA,6F;;AAEA,iF;;;AAGA,oD;AACA,wE;AACA,wC;AACA,wE;;AAEA,sB;AACA,kD;AACA,8B;AACA,oB;AACA,mB;AACA,O;AACA,K;AACA,C;;;AAGA,0H;AACA,2B;AACA,gG;AACA,gE;AACA,yC;;AAEA,sE;AACA,2F;;AAEA,yE;AACA,oC;AACA,+B;AACA,kB;AACA,kB;;AAEA,gE;AACA,sE;AACA,4F;AACA,0B;AACA,gB;AACA,e;AACA,K;AACA,G;;;AAGA,sB;AACA,+C;AACA,6B;AACA,sB;AACA,0C;AACA,iD;AACA,4C;AACA,mB;AACA,wB;AACA,uC;AACA,2E;AACA,sC;AACA,Q;;AAEA,uE;AACA,kB;AACA,0B;AACA,wE;AACA,kC;;AAEA,8D;AACA,2C;AACA,sC;AACA,iC;AACA,gD;AACA,+B;AACA,U;AACA,8B;AACA,6C;AACA,U;AACA,8B;AACA,6C;AACA,S;AACA,S;;AAEA,uC;AACA,8B;AACA,M;AACA,6B;AACA,sB;AACA,4C;AACA,+B;AACA,mB;;AAEA,gC;AACA,8D;AACA,0B;AACA,0C;AACA,0C;AACA,M;AACA,6B;AACA,sB;AACA,kC;AACA,mB;AACA,yB;;AAEA,0B;AACA,6E;AACA,iE;AACA,wC;AACA,M;AACA,6B;AACA,sB;AACA,8B;AACA,K;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACjUA,oE;;AAEA,0E;AACA,iD;AACA,gD;AACA,e;AACA,8E;AACA,gB;AACA,I;;AAEA,0B;AACA,wB;AACA,oD;;AAEA,iC;AACA,+B;AACA,2D;;AAEA,+B;AACA,6B;AACA,yD;AACA,+B;AACA,gC;AACA,+B;;AAEA,sB;;AAEA,0D;AACA,kC;AACA,oC;AACA,qC;AACA,G;;;;;;;;;;;;;;;;;;;AC/BA,kC;AACA,0C;;AAEA,gD;AACA,2B;AACA,oB;AACA,+C;AACA,qD;AACA,wC;AACA,wC;;AAEA,2C;AACA,4D;;AAEA,4B;AACA,8E;AACA,6E;;AAEA,wB;AACA,+B;AACA,oC;AACA,mE;AACA,qB;AACA,sB;AACA,8B;AACA,Q;AACA,0B;AACA,0B;;AAEA,gF;AACA,+E;AACA,4B;AACA,2E;AACA,sB;AACA,8B;AACA,Q;AACA,G;AACA,G","sourcesContent":["// This is a magic collection that fails its writes on the server when\n// the selector (or inserted document) contains fail: true.\n\nvar TRANSFORMS = {};\nif (Meteor.isServer) {\n  Meteor.methods({\n    createInsecureCollection: function (name, options) {\n      check(name, String);\n      check(options, Match.Optional({\n        transformName: Match.Optional(String),\n        idGeneration: Match.Optional(String)\n      }));\n\n      if (options && options.transformName) {\n        options.transform = TRANSFORMS[options.transformName];\n      }\n      var c = new Meteor.Collection(name, options);\n      c._insecure = true;\n      Meteor.publish('c-' + name, function () {\n        return c.find();\n      });\n    }\n  });\n}\n\nvar runInFence = function (f) {\n  if (Meteor.isClient) {\n    f();\n  } else {\n    var fence = new DDPServer._WriteFence;\n    DDPServer._CurrentWriteFence.withValue(fence, f);\n    fence.armAndWait();\n  }\n};\n\n// Helpers for upsert tests\n\nvar stripId = function (obj) {\n  delete obj._id;\n};\n\nvar compareResults = function (test, skipIds, actual, expected) {\n  if (skipIds) {\n    _.map(actual, stripId);\n    _.map(expected, stripId);\n  }\n  // (technically should ignore order in comparison)\n  test.equal(actual, expected);\n};\n\nvar upsert = function (coll, useUpdate, query, mod, options, callback) {\n  if (! callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  if (useUpdate) {\n    if (callback)\n      return coll.update(query, mod,\n                         _.extend({ upsert: true }, options),\n                         function (err, result) {\n                           callback(err, ! err && {\n                             numberAffected: result\n                           });\n                         });\n    return {\n      numberAffected: coll.update(query, mod,\n                                  _.extend({ upsert: true }, options))\n    };\n  } else {\n    return coll.upsert(query, mod, options, callback);\n  }\n};\n\nvar upsertTestMethod = \"livedata_upsert_test_method\";\nvar upsertTestMethodColl;\n\n// This is the implementation of the upsert test method on both the client and\n// the server. On the client, we get a test object. On the server, we just throw\n// errors if something doesn't go according to plan, and when the client\n// receives those errors it will cause the test to fail.\n//\n// Client-side exceptions in here will NOT cause the test to fail! Because it's\n// a stub, those exceptions will get caught and logged.\nvar upsertTestMethodImpl = function (coll, useUpdate, test) {\n  coll.remove({});\n  var result1 = upsert(coll, useUpdate, { foo: \"bar\" }, { foo: \"bar\" });\n\n  if (! test) {\n    test = {\n      equal: function (a, b) {\n        if (! EJSON.equals(a, b))\n          throw new Error(\"Not equal: \" +\n                          JSON.stringify(a) + \", \" + JSON.stringify(b));\n      },\n      isTrue: function (a) {\n        if (! a)\n          throw new Error(\"Not truthy: \" + JSON.stringify(a));\n      },\n      isFalse: function (a) {\n        if (a)\n          throw new Error(\"Not falsey: \" + JSON.stringify(a));\n      }\n    };\n  }\n\n  // if we don't test this, then testing result1.numberAffected will throw,\n  // which will get caught and logged and the whole test will pass!\n  test.isTrue(result1);\n\n  test.equal(result1.numberAffected, 1);\n  if (! useUpdate)\n    test.isTrue(result1.insertedId);\n  var fooId = result1.insertedId;\n  var obj = coll.findOne({ foo: \"bar\" });\n  test.isTrue(obj);\n  if (! useUpdate)\n    test.equal(obj._id, result1.insertedId);\n  var result2 = upsert(coll, useUpdate, { _id: fooId },\n                       { $set: { foo: \"baz \" } });\n  test.isTrue(result2);\n  test.equal(result2.numberAffected, 1);\n  test.isFalse(result2.insertedId);\n};\n\nif (Meteor.isServer) {\n  var m = {};\n  m[upsertTestMethod] = function (run, useUpdate, options) {\n    check(run, String);\n    check(useUpdate, Boolean);\n    upsertTestMethodColl = new Meteor.Collection(upsertTestMethod + \"_collection_\" + run, options);\n    upsertTestMethodImpl(upsertTestMethodColl, useUpdate);\n  };\n  Meteor.methods(m);\n}\n\nMeteor._FailureTestCollection =\n  new Meteor.Collection(\"___meteor_failure_test_collection\");\n\n// For test \"document with a custom type\"\nvar Dog = function (name, color, actions) {\n  var self = this;\n  self.color = color;\n  self.name = name;\n  self.actions = actions || [{name: \"wag\"}, {name: \"swim\"}];\n};\n_.extend(Dog.prototype, {\n  getName: function () { return this.name;},\n  getColor: function () { return this.name;},\n  equals: function (other) { return other.name === this.name &&\n                             other.color === this.color &&\n                             EJSON.equals(other.actions, this.actions);},\n  toJSONValue: function () { return {color: this.color, name: this.name, actions: this.actions};},\n  typeName: function () { return \"dog\"; },\n  clone: function () { return new Dog(this.name, this.color); },\n  speak: function () { return \"woof\"; }\n});\nEJSON.addType(\"dog\", function (o) { return new Dog(o.name, o.color, o.actions);});\n\n\n// Parameterize tests.\n_.each( ['STRING', 'MONGO'], function(idGeneration) {\n\nvar collectionOptions = { idGeneration: idGeneration};\n\ntestAsyncMulti(\"mongo-livedata - database error reporting. \" + idGeneration, [\n  function (test, expect) {\n    var ftc = Meteor._FailureTestCollection;\n\n    var exception = function (err, res) {\n      test.instanceOf(err, Error);\n    };\n\n    _.each([\"insert\", \"remove\", \"update\"], function (op) {\n      var arg = (op === \"insert\" ? {} : 'bla');\n      var arg2 = {};\n\n      var callOp = function (callback) {\n        if (op === \"update\") {\n          ftc[op](arg, arg2, callback);\n        } else {\n          ftc[op](arg, callback);\n        }\n      };\n\n      if (Meteor.isServer) {\n        test.throws(function () {\n          callOp();\n        });\n\n        callOp(expect(exception));\n      }\n\n      if (Meteor.isClient) {\n        callOp(expect(exception));\n\n        // This would log to console in normal operation.\n        Meteor._suppress_log(1);\n        callOp();\n      }\n    });\n  }\n]);\n\n\nTinytest.addAsync(\"mongo-livedata - basics, \" + idGeneration, function (test, onComplete) {\n  var run = test.runId();\n  var coll, coll2;\n  if (Meteor.isClient) {\n    coll = new Meteor.Collection(null, collectionOptions) ; // local, unmanaged\n    coll2 = new Meteor.Collection(null, collectionOptions); // local, unmanaged\n  } else {\n    coll = new Meteor.Collection(\"livedata_test_collection_\"+run, collectionOptions);\n    coll2 = new Meteor.Collection(\"livedata_test_collection_2_\"+run, collectionOptions);\n  }\n\n  var log = '';\n  var obs = coll.find({run: run}, {sort: [\"x\"]}).observe({\n    addedAt: function (doc, before_index, before) {\n      log += 'a(' + doc.x + ',' + before_index + ',' + before + ')';\n    },\n    changedAt: function (new_doc, old_doc, at_index) {\n      log += 'c(' + new_doc.x + ',' + at_index + ',' + old_doc.x + ')';\n    },\n    movedTo: function (doc, old_index, new_index) {\n      log += 'm(' + doc.x + ',' + old_index + ',' + new_index + ')';\n    },\n    removedAt: function (doc, at_index) {\n      log += 'r(' + doc.x + ',' + at_index + ')';\n    }\n  });\n\n  var captureObserve = function (f) {\n    if (Meteor.isClient) {\n      f();\n    } else {\n      var fence = new DDPServer._WriteFence;\n      DDPServer._CurrentWriteFence.withValue(fence, f);\n      fence.armAndWait();\n    }\n\n    var ret = log;\n    log = '';\n    return ret;\n  };\n\n  var expectObserve = function (expected, f) {\n    if (!(expected instanceof Array))\n      expected = [expected];\n\n    test.include(expected, captureObserve(f));\n  };\n\n  test.equal(coll.find({run: run}).count(), 0);\n  test.equal(coll.findOne(\"abc\"), undefined);\n  test.equal(coll.findOne({run: run}), undefined);\n\n  expectObserve('a(1,0,null)', function () {\n    var id = coll.insert({run: run, x: 1});\n    test.equal(coll.find({run: run}).count(), 1);\n    test.equal(coll.findOne(id).x, 1);\n    test.equal(coll.findOne({run: run}).x, 1);\n  });\n\n  expectObserve('a(4,1,null)', function () {\n    var id2 = coll.insert({run: run, x: 4});\n    test.equal(coll.find({run: run}).count(), 2);\n    test.equal(coll.find({_id: id2}).count(), 1);\n    test.equal(coll.findOne(id2).x, 4);\n  });\n\n  test.equal(coll.findOne({run: run}, {sort: [\"x\"], skip: 0}).x, 1);\n  test.equal(coll.findOne({run: run}, {sort: [\"x\"], skip: 1}).x, 4);\n  test.equal(coll.findOne({run: run}, {sort: {x: -1}, skip: 0}).x, 4);\n  test.equal(coll.findOne({run: run}, {sort: {x: -1}, skip: 1}).x, 1);\n\n\n  var cur = coll.find({run: run}, {sort: [\"x\"]});\n  var total = 0;\n  var index = 0;\n  var context = {};\n  cur.forEach(function (doc, i, cursor) {\n    test.equal(i, index++);\n    test.isTrue(cursor === cur);\n    test.isTrue(context === this);\n    total *= 10;\n    if (Meteor.isServer) {\n      // Verify that the callbacks from forEach run sequentially and that\n      // forEach waits for them to complete (issue# 321). If they do not run\n      // sequentially, then the second callback could execute during the first\n      // callback's sleep sleep and the *= 10 will occur before the += 1, then\n      // total (at test.equal time) will be 5. If forEach does not wait for the\n      // callbacks to complete, then total (at test.equal time) will be 0.\n      Meteor._sleepForMs(5);\n    }\n    total += doc.x;\n    // verify the meteor environment is set up here\n    coll2.insert({total:total});\n  }, context);\n  test.equal(total, 14);\n\n  cur.rewind();\n  index = 0;\n  test.equal(cur.map(function (doc, i, cursor) {\n    // XXX we could theoretically make map run its iterations in parallel or\n    // something which would make this fail\n    test.equal(i, index++);\n    test.isTrue(cursor === cur);\n    test.isTrue(context === this);\n    return doc.x * 2;\n  }, context), [2, 8]);\n\n  test.equal(_.pluck(coll.find({run: run}, {sort: {x: -1}}).fetch(), \"x\"),\n             [4, 1]);\n\n  expectObserve('', function () {\n    var count = coll.update({run: run, x: -1}, {$inc: {x: 2}}, {multi: true});\n    test.equal(count, 0);\n  });\n\n  expectObserve('c(3,0,1)c(6,1,4)', function () {\n    var count = coll.update({run: run}, {$inc: {x: 2}}, {multi: true});\n    test.equal(count, 2);\n    test.equal(_.pluck(coll.find({run: run}, {sort: {x: -1}}).fetch(), \"x\"),\n               [6, 3]);\n  });\n\n  expectObserve(['c(13,0,3)m(13,0,1)', 'm(6,1,0)c(13,1,3)',\n                 'c(13,0,3)m(6,1,0)', 'm(3,0,1)c(13,1,3)'], function () {\n    coll.update({run: run, x: 3}, {$inc: {x: 10}}, {multi: true});\n    test.equal(_.pluck(coll.find({run: run}, {sort: {x: -1}}).fetch(), \"x\"),\n               [13, 6]);\n  });\n\n  expectObserve('r(13,1)', function () {\n    var count = coll.remove({run: run, x: {$gt: 10}});\n    test.equal(count, 1);\n    test.equal(coll.find({run: run}).count(), 1);\n  });\n\n  expectObserve('r(6,0)', function () {\n    coll.remove({run: run});\n    test.equal(coll.find({run: run}).count(), 0);\n  });\n\n  expectObserve('', function () {\n    var count = coll.remove({run: run});\n    test.equal(count, 0);\n    test.equal(coll.find({run: run}).count(), 0);\n  });\n\n  obs.stop();\n  onComplete();\n});\n\nTinytest.addAsync(\"mongo-livedata - fuzz test, \" + idGeneration, function(test, onComplete) {\n\n  var run = Random.id();\n  var coll;\n  if (Meteor.isClient) {\n    coll = new Meteor.Collection(null, collectionOptions); // local, unmanaged\n  } else {\n    coll = new Meteor.Collection(\"livedata_test_collection_\"+run, collectionOptions);\n  }\n\n  // fuzz test of observe(), especially the server-side diffing\n  var actual = [];\n  var correct = [];\n  var counters = {add: 0, change: 0, move: 0, remove: 0};\n\n  var obs = coll.find({run: run}, {sort: [\"x\"]}).observe({\n    addedAt: function (doc, before_index) {\n      counters.add++;\n      actual.splice(before_index, 0, doc.x);\n    },\n    changedAt: function (new_doc, old_doc, at_index) {\n      counters.change++;\n      test.equal(actual[at_index], old_doc.x);\n      actual[at_index] = new_doc.x;\n    },\n    movedTo: function (doc, old_index, new_index) {\n      counters.move++;\n      test.equal(actual[old_index], doc.x);\n      actual.splice(old_index, 1);\n      actual.splice(new_index, 0, doc.x);\n    },\n    removedAt: function (doc, at_index) {\n      counters.remove++;\n      test.equal(actual[at_index], doc.x);\n      actual.splice(at_index, 1);\n    }\n  });\n\n  // XXX What if there are multiple observe handles on the ObserveMultiplexer?\n  //     There shouldn't be because the collection has a name unique to this\n  //     run.\n  if (Meteor.isServer) {\n    // For now, has to be polling (not oplog).\n    test.isTrue(obs._observeDriver);\n    test.isTrue(obs._observeDriver._suspendPolling);\n  }\n\n  var step = 0;\n\n  // Use non-deterministic randomness so we can have a shorter fuzz\n  // test (fewer iterations).  For deterministic (fully seeded)\n  // randomness, remove the call to Random.fraction().\n  var seededRandom = new SeededRandom(\"foobard\" + Random.fraction());\n  // Random integer in [0,n)\n  var rnd = function (n) {\n    return seededRandom.nextIntBetween(0, n-1);\n  };\n\n  var finishObserve = function (f) {\n    if (Meteor.isClient) {\n      f();\n    } else {\n      var fence = new DDPServer._WriteFence;\n      DDPServer._CurrentWriteFence.withValue(fence, f);\n      fence.armAndWait();\n    }\n  };\n\n  var doStep = function () {\n    if (step++ === 5) { // run N random tests\n      obs.stop();\n      onComplete();\n      return;\n    }\n\n    var max_counters = _.clone(counters);\n\n    finishObserve(function () {\n      if (Meteor.isServer)\n        obs._observeDriver._suspendPolling();\n\n      // Do a batch of 1-10 operations\n      var batch_count = rnd(10) + 1;\n      for (var i = 0; i < batch_count; i++) {\n        // 25% add, 25% remove, 25% change in place, 25% change and move\n        var op = rnd(4);\n        var which = rnd(correct.length);\n        if (op === 0 || step < 2 || !correct.length) {\n          // Add\n          var x = rnd(1000000);\n          coll.insert({run: run, x: x});\n          correct.push(x);\n          max_counters.add++;\n        } else if (op === 1 || op === 2) {\n          var x = correct[which];\n          if (op === 1)\n            // Small change, not likely to cause a move\n            var val = x + (rnd(2) ? -1 : 1);\n          else\n            // Large change, likely to cause a move\n            var val = rnd(1000000);\n          coll.update({run: run, x: x}, {$set: {x: val}});\n          correct[which] = val;\n          max_counters.change++;\n          max_counters.move++;\n        } else {\n          coll.remove({run: run, x: correct[which]});\n          correct.splice(which, 1);\n          max_counters.remove++;\n        }\n      }\n      if (Meteor.isServer)\n        obs._observeDriver._resumePolling();\n\n    });\n\n    // Did we actually deliver messages that mutated the array in the\n    // right way?\n    correct.sort(function (a,b) {return a-b;});\n    test.equal(actual, correct);\n\n    // Did we limit ourselves to one 'moved' message per change,\n    // rather than O(results) moved messages?\n    _.each(max_counters, function (v, k) {\n      test.isTrue(max_counters[k] >= counters[k], k);\n    });\n\n    Meteor.defer(doStep);\n  };\n\n  doStep();\n\n});\n\nTinytest.addAsync(\"mongo-livedata - scribbling, \" + idGeneration, function (test, onComplete) {\n  var run = test.runId();\n  var coll;\n  if (Meteor.isClient) {\n    coll = new Meteor.Collection(null, collectionOptions); // local, unmanaged\n  } else {\n    coll = new Meteor.Collection(\"livedata_test_collection_\"+run, collectionOptions);\n  }\n\n  var numAddeds = 0;\n  var handle = coll.find({run: run}).observe({\n    addedAt: function (o) {\n      // test that we can scribble on the object we get back from Mongo without\n      // breaking anything.  The worst possible scribble is messing with _id.\n      delete o._id;\n      numAddeds++;\n    }\n  });\n  _.each([123, 456, 789], function (abc) {\n    runInFence(function () {\n      coll.insert({run: run, abc: abc});\n    });\n  });\n  handle.stop();\n  // will be 6 (1+2+3) if we broke diffing!\n  test.equal(numAddeds, 3);\n\n  onComplete();\n});\n\nTinytest.addAsync(\"mongo-livedata - stop handle in callback, \" + idGeneration, function (test, onComplete) {\n  var run = Random.id();\n  var coll;\n  if (Meteor.isClient) {\n    coll = new Meteor.Collection(null, collectionOptions); // local, unmanaged\n  } else {\n    coll = new Meteor.Collection(\"stopHandleInCallback-\"+run, collectionOptions);\n  }\n\n  var output = [];\n\n  var handle = coll.find().observe({\n    added: function (doc) {\n      output.push({added: doc._id});\n    },\n    changed: function (newDoc) {\n      output.push('changed');\n      handle.stop();\n    }\n  });\n\n  test.equal(output, []);\n\n  // Insert a document. Observe that the added callback is called.\n  var docId;\n  runInFence(function () {\n    docId = coll.insert({foo: 42});\n  });\n  test.length(output, 1);\n  test.equal(output.shift(), {added: docId});\n\n  // Update it. Observe that the changed callback is called. This should also\n  // stop the observation.\n  runInFence(function() {\n    coll.update(docId, {$set: {bar: 10}});\n  });\n  test.length(output, 1);\n  test.equal(output.shift(), 'changed');\n\n  // Update again. This shouldn't call the callback because we stopped the\n  // observation.\n  runInFence(function() {\n    coll.update(docId, {$set: {baz: 40}});\n  });\n  test.length(output, 0);\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne(docId),\n             {_id: docId, foo: 42, bar: 10, baz: 40});\n\n  onComplete();\n});\n\n// This behavior isn't great, but it beats deadlock.\nif (Meteor.isServer) {\n  Tinytest.addAsync(\"mongo-livedata - recursive observe throws, \" + idGeneration, function (test, onComplete) {\n    var run = test.runId();\n    var coll = new Meteor.Collection(\"observeInCallback-\"+run, collectionOptions);\n\n    var callbackCalled = false;\n    var handle = coll.find({}).observe({\n      added: function (newDoc) {\n        callbackCalled = true;\n        test.throws(function () {\n          coll.find({}).observe();\n        });\n      }\n    });\n    test.isFalse(callbackCalled);\n    // Insert a document. Observe that the added callback is called.\n    runInFence(function () {\n      coll.insert({foo: 42});\n    });\n    test.isTrue(callbackCalled);\n\n    handle.stop();\n\n    onComplete();\n  });\n\n  Tinytest.addAsync(\"mongo-livedata - cursor dedup, \" + idGeneration, function (test, onComplete) {\n    var run = test.runId();\n    var coll = new Meteor.Collection(\"cursorDedup-\"+run, collectionOptions);\n\n    var observer = function (noAdded) {\n      var output = [];\n      var callbacks = {\n        changed: function (newDoc) {\n          output.push({changed: newDoc._id});\n        }\n      };\n      if (!noAdded) {\n        callbacks.added = function (doc) {\n          output.push({added: doc._id});\n        };\n      }\n      var handle = coll.find({foo: 22}).observe(callbacks);\n      return {output: output, handle: handle};\n    };\n\n    // Insert a doc and start observing.\n    var docId1 = coll.insert({foo: 22});\n    var o1 = observer();\n    // Initial add.\n    test.length(o1.output, 1);\n    test.equal(o1.output.shift(), {added: docId1});\n\n    // Insert another doc (blocking until observes have fired).\n    var docId2;\n    runInFence(function () {\n      docId2 = coll.insert({foo: 22, bar: 5});\n    });\n    // Observed add.\n    test.length(o1.output, 1);\n    test.equal(o1.output.shift(), {added: docId2});\n\n    // Second identical observe.\n    var o2 = observer();\n    // Initial adds.\n    test.length(o2.output, 2);\n    test.include([docId1, docId2], o2.output[0].added);\n    test.include([docId1, docId2], o2.output[1].added);\n    test.notEqual(o2.output[0].added, o2.output[1].added);\n    o2.output.length = 0;\n    // Original observe not affected.\n    test.length(o1.output, 0);\n\n    // White-box test: both observes should share an ObserveMultiplexer.\n    var observeMultiplexer = o1.handle._multiplexer;\n    test.isTrue(observeMultiplexer);\n    test.isTrue(observeMultiplexer === o2.handle._multiplexer);\n\n    // Update. Both observes fire.\n    runInFence(function () {\n      coll.update(docId1, {$set: {x: 'y'}});\n    });\n    test.length(o1.output, 1);\n    test.length(o2.output, 1);\n    test.equal(o1.output.shift(), {changed: docId1});\n    test.equal(o2.output.shift(), {changed: docId1});\n\n    // Stop first handle. Second handle still around.\n    o1.handle.stop();\n    test.length(o1.output, 0);\n    test.length(o2.output, 0);\n\n    // Another update. Just the second handle should fire.\n    runInFence(function () {\n      coll.update(docId2, {$set: {z: 'y'}});\n    });\n    test.length(o1.output, 0);\n    test.length(o2.output, 1);\n    test.equal(o2.output.shift(), {changed: docId2});\n\n    // Stop second handle. Nothing should happen, but the multiplexer should\n    // be stopped.\n    test.isTrue(observeMultiplexer._handles);  // This will change.\n    o2.handle.stop();\n    test.length(o1.output, 0);\n    test.length(o2.output, 0);\n    // White-box: ObserveMultiplexer has nulled its _handles so you can't\n    // accidentally join to it.\n    test.isNull(observeMultiplexer._handles);\n\n    // Start yet another handle on the same query.\n    var o3 = observer();\n    // Initial adds.\n    test.length(o3.output, 2);\n    test.include([docId1, docId2], o3.output[0].added);\n    test.include([docId1, docId2], o3.output[1].added);\n    test.notEqual(o3.output[0].added, o3.output[1].added);\n    // Old observers not called.\n    test.length(o1.output, 0);\n    test.length(o2.output, 0);\n    // White-box: Different ObserveMultiplexer.\n    test.isTrue(observeMultiplexer !== o3.handle._multiplexer);\n\n    // Start another handle with no added callback. Regression test for #589.\n    var o4 = observer(true);\n\n    o3.handle.stop();\n    o4.handle.stop();\n\n    onComplete();\n  });\n\n  Tinytest.addAsync(\"mongo-livedata - async server-side insert, \" + idGeneration, function (test, onComplete) {\n    // Tests that insert returns before the callback runs. Relies on the fact\n    // that mongo does not run the callback before spinning off the event loop.\n    var cname = Random.id();\n    var coll = new Meteor.Collection(cname);\n    var doc = { foo: \"bar\" };\n    var x = 0;\n    coll.insert(doc, function (err, result) {\n      test.equal(err, null);\n      test.equal(x, 1);\n      onComplete();\n    });\n    x++;\n  });\n\n  Tinytest.addAsync(\"mongo-livedata - async server-side update, \" + idGeneration, function (test, onComplete) {\n    // Tests that update returns before the callback runs.\n    var cname = Random.id();\n    var coll = new Meteor.Collection(cname);\n    var doc = { foo: \"bar\" };\n    var x = 0;\n    var id = coll.insert(doc);\n    coll.update(id, { $set: { foo: \"baz\" } }, function (err, result) {\n      test.equal(err, null);\n      test.equal(result, 1);\n      test.equal(x, 1);\n      onComplete();\n    });\n    x++;\n  });\n\n  Tinytest.addAsync(\"mongo-livedata - async server-side remove, \" + idGeneration, function (test, onComplete) {\n    // Tests that remove returns before the callback runs.\n    var cname = Random.id();\n    var coll = new Meteor.Collection(cname);\n    var doc = { foo: \"bar\" };\n    var x = 0;\n    var id = coll.insert(doc);\n    coll.remove(id, function (err, result) {\n      test.equal(err, null);\n      test.isFalse(coll.findOne(id));\n      test.equal(x, 1);\n      onComplete();\n    });\n    x++;\n  });\n}\n\n\ntestAsyncMulti('mongo-livedata - empty documents, ' + idGeneration, [\n  function (test, expect) {\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    var coll = new Meteor.Collection(collectionName, collectionOptions);\n    var docId;\n\n    coll.insert({}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      docId = id;\n      var cursor = coll.find();\n      test.equal(cursor.count(), 1);\n    }));\n  }\n]);\n\ntestAsyncMulti('mongo-livedata - document with a date, ' + idGeneration, [\n  function (test, expect) {\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName, collectionOptions);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    var coll = new Meteor.Collection(collectionName, collectionOptions);\n    var docId;\n    coll.insert({d: new Date(1356152390004)}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      docId = id;\n      var cursor = coll.find();\n      test.equal(cursor.count(), 1);\n      test.equal(coll.findOne().d.getFullYear(), 2012);\n    }));\n  }\n]);\n\ntestAsyncMulti('mongo-livedata - document goes through a transform, ' + idGeneration, [\n  function (test, expect) {\n    var self = this;\n    var seconds = function (doc) {\n      doc.seconds = function () {return doc.d.getSeconds();};\n      return doc;\n    };\n    TRANSFORMS[\"seconds\"] = seconds;\n    var collectionOptions = {\n      idGeneration: idGeneration,\n      transform: seconds,\n      transformName: \"seconds\"\n    };\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName, collectionOptions);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    self.coll = new Meteor.Collection(collectionName, collectionOptions);\n    var obs;\n    var expectAdd = expect(function (doc) {\n      test.equal(doc.seconds(), 50);\n    });\n    var expectRemove = expect (function (doc) {\n      test.equal(doc.seconds(), 50);\n      obs.stop();\n    });\n    self.coll.insert({d: new Date(1356152390004)}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      var cursor = self.coll.find();\n      obs = cursor.observe({\n        added: expectAdd,\n        removed: expectRemove\n      });\n      test.equal(cursor.count(), 1);\n      test.equal(cursor.fetch()[0].seconds(), 50);\n      test.equal(self.coll.findOne().seconds(), 50);\n      test.equal(self.coll.findOne({}, {transform: null}).seconds, undefined);\n      test.equal(self.coll.findOne({}, {\n        transform: function (doc) {return {seconds: doc.d.getSeconds()};}\n      }).seconds, 50);\n      self.coll.remove(id);\n    }));\n  },\n  function (test, expect) {\n    var self = this;\n    self.coll.insert({d: new Date(1356152390004)}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      self.id1 = id;\n    }));\n    self.coll.insert({d: new Date(1356152391004)}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      self.id2 = id;\n    }));\n  },\n  function (test, expect) {\n    var self = this;\n    // Test that a transform that returns something other than a document with\n    // an _id (eg, a number) works. Regression test for #974.\n    test.equal(self.coll.find({}, {\n      transform: function (doc) { return doc.d.getSeconds(); },\n      sort: {d: 1}\n    }).fetch(), [50, 51]);\n  }\n]);\n\ntestAsyncMulti('mongo-livedata - document with binary data, ' + idGeneration, [\n  function (test, expect) {\n    // XXX probably shouldn't use EJSON's private test symbols\n    var bin = EJSONTest.base64Decode(\n      \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyBy\" +\n        \"ZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJv\" +\n        \"bSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhl\" +\n        \"IG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdo\" +\n        \"dCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdl\" +\n        \"bmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9y\" +\n        \"dCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\");\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName, collectionOptions);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    var coll = new Meteor.Collection(collectionName, collectionOptions);\n    var docId;\n    coll.insert({b: bin}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      docId = id;\n      var cursor = coll.find();\n      test.equal(cursor.count(), 1);\n      var inColl = coll.findOne();\n      test.isTrue(EJSON.isBinary(inColl.b));\n      test.equal(inColl.b, bin);\n    }));\n  }\n]);\n\ntestAsyncMulti('mongo-livedata - document with a custom type, ' + idGeneration, [\n  function (test, expect) {\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName, collectionOptions);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    var coll = new Meteor.Collection(collectionName, collectionOptions);\n    var docId;\n    // Dog is implemented at the top of the file, outside of the idGeneration\n    // loop (so that we only call EJSON.addType once).\n    var d = new Dog(\"reginald\", \"purple\");\n    coll.insert({d: d}, expect(function (err, id) {\n      test.isFalse(err);\n      test.isTrue(id);\n      docId = id;\n      var cursor = coll.find();\n      test.equal(cursor.count(), 1);\n      var inColl = coll.findOne();\n      test.isTrue(inColl);\n      inColl && test.equal(inColl.d.speak(), \"woof\");\n    }));\n  }\n]);\n\nif (Meteor.isServer) {\n  Tinytest.addAsync(\"mongo-livedata - update return values, \" + idGeneration, function (test, onComplete) {\n    var run = test.runId();\n    var coll = new Meteor.Collection(\"livedata_update_result_\"+run, collectionOptions);\n\n    coll.insert({ foo: \"bar\" });\n    coll.insert({ foo: \"baz\" });\n    test.equal(coll.update({}, { $set: { foo: \"qux\" } }, { multi: true }),\n               2);\n    coll.update({}, { $set: { foo: \"quux\" } }, { multi: true }, function (err, result) {\n      test.isFalse(err);\n      test.equal(result, 2);\n      onComplete();\n    });\n  });\n\n  Tinytest.addAsync(\"mongo-livedata - remove return values, \" + idGeneration, function (test, onComplete) {\n    var run = test.runId();\n    var coll = new Meteor.Collection(\"livedata_update_result_\"+run, collectionOptions);\n\n    coll.insert({ foo: \"bar\" });\n    coll.insert({ foo: \"baz\" });\n    test.equal(coll.remove({}), 2);\n    coll.insert({ foo: \"bar\" });\n    coll.insert({ foo: \"baz\" });\n    coll.remove({}, function (err, result) {\n      test.isFalse(err);\n      test.equal(result, 2);\n      onComplete();\n    });\n  });\n\n\n  Tinytest.addAsync(\"mongo-livedata - id-based invalidation, \" + idGeneration, function (test, onComplete) {\n    var run = test.runId();\n    var coll = new Meteor.Collection(\"livedata_invalidation_collection_\"+run, collectionOptions);\n\n    coll.allow({\n      update: function () {return true;},\n      remove: function () {return true;}\n    });\n\n    var id1 = coll.insert({x: 42, is1: true});\n    var id2 = coll.insert({x: 50, is2: true});\n\n    var polls = {};\n    var handlesToStop = [];\n    var observe = function (name, query) {\n      var handle = coll.find(query).observeChanges({\n        // Make sure that we only poll on invalidation, not due to time, and\n        // keep track of when we do. Note: this option disables the use of\n        // oplogs (which admittedly is somewhat irrelevant to this feature).\n        _testOnlyPollCallback: function () {\n          polls[name] = (name in polls ? polls[name] + 1 : 1);\n        }\n      });\n      handlesToStop.push(handle);\n    };\n\n    observe(\"all\", {});\n    observe(\"id1Direct\", id1);\n    observe(\"id1InQuery\", {_id: id1, z: null});\n    observe(\"id2Direct\", id2);\n    observe(\"id2InQuery\", {_id: id2, z: null});\n    observe(\"bothIds\", {_id: {$in: [id1, id2]}});\n\n    var resetPollsAndRunInFence = function (f) {\n      polls = {};\n      runInFence(f);\n    };\n\n    // Update id1 directly. This should poll all but the \"id2\" queries. \"all\"\n    // and \"bothIds\" increment by 2 because they are looking at both.\n    resetPollsAndRunInFence(function () {\n      coll.update(id1, {$inc: {x: 1}});\n    });\n    test.equal(\n      polls,\n      {all: 1, id1Direct: 1, id1InQuery: 1, bothIds: 1});\n\n    // Update id2 using a funny query. This should poll all but the \"id1\"\n    // queries.\n    resetPollsAndRunInFence(function () {\n      coll.update({_id: id2, q: null}, {$inc: {x: 1}});\n    });\n    test.equal(\n      polls,\n      {all: 1, id2Direct: 1, id2InQuery: 1, bothIds: 1});\n\n    // Update both using a $in query. Should poll each of them exactly once.\n    resetPollsAndRunInFence(function () {\n      coll.update({_id: {$in: [id1, id2]}, q: null}, {$inc: {x: 1}});\n    });\n    test.equal(\n      polls,\n      {all: 1, id1Direct: 1, id1InQuery: 1, id2Direct: 1, id2InQuery: 1,\n       bothIds: 1});\n\n    _.each(handlesToStop, function (h) {h.stop();});\n    onComplete();\n  });\n\n  Tinytest.add(\"mongo-livedata - upsert error parse, \" + idGeneration, function (test) {\n    var run = test.runId();\n    var coll = new Meteor.Collection(\"livedata_upsert_errorparse_collection_\"+run, collectionOptions);\n\n    coll.insert({_id: 'foobar'});\n    var err;\n    try {\n      coll.update({_id: 'foobar'}, {_id: 'cowbar'});\n    } catch (e) {\n      err = e;\n    }\n    test.isTrue(err);\n    test.isTrue(MongoInternals.Connection._isCannotChangeIdError(err));\n\n    try {\n      coll.insert({_id: 'foobar'});\n    } catch (e) {\n      err = e;\n    }\n    test.isTrue(err);\n    // duplicate id error is not same as change id error\n    test.isFalse(MongoInternals.Connection._isCannotChangeIdError(err));\n  });\n\n} // end Meteor.isServer\n\n// This test is duplicated below (with some changes) for async upserts that go\n// over the network.\n_.each(Meteor.isServer ? [true, false] : [true], function (minimongo) {\n  _.each([true, false], function (useUpdate) {\n    _.each([true, false], function (useDirectCollection) {\n      Tinytest.add(\"mongo-livedata - \" + (useUpdate ? \"update \" : \"\") + \"upsert\" + (minimongo ? \" minimongo\" : \"\") + (useDirectCollection ? \" direct collection \" : \"\") + \", \" + idGeneration, function (test) {\n        var run = test.runId();\n        var options = collectionOptions;\n        // We don't get ids back when we use update() to upsert, or when we are\n        // directly calling MongoConnection.upsert().\n        var skipIds = useUpdate || (! minimongo && useDirectCollection);\n        if (minimongo)\n          options = _.extend({}, collectionOptions, { connection: null });\n        var coll = new Meteor.Collection(\n          \"livedata_upsert_collection_\"+run+\n            (useUpdate ? \"_update_\" : \"\") +\n            (minimongo ? \"_minimongo_\" : \"\") +\n            (useDirectCollection ? \"_direct_\" : \"\") + \"\",\n          options\n        );\n        if (useDirectCollection)\n          coll = coll._collection;\n\n        var result1 = upsert(coll, useUpdate, {foo: 'bar'}, {foo: 'bar'});\n        test.equal(result1.numberAffected, 1);\n        if (! skipIds)\n          test.isTrue(result1.insertedId);\n        compareResults(test, skipIds, coll.find().fetch(), [{foo: 'bar', _id: result1.insertedId}]);\n\n        var result2 = upsert(coll, useUpdate, {foo: 'bar'}, {foo: 'baz'});\n        test.equal(result2.numberAffected, 1);\n        if (! skipIds)\n          test.isFalse(result2.insertedId);\n        compareResults(test, skipIds, coll.find().fetch(), [{foo: 'baz', _id: result1.insertedId}]);\n\n        coll.remove({});\n\n        // Test values that require transformation to go into Mongo:\n\n        var t1 = new Meteor.Collection.ObjectID();\n        var t2 = new Meteor.Collection.ObjectID();\n        var result3 = upsert(coll, useUpdate, {foo: t1}, {foo: t1});\n        test.equal(result3.numberAffected, 1);\n        if (! skipIds)\n          test.isTrue(result3.insertedId);\n        compareResults(test, skipIds, coll.find().fetch(), [{foo: t1, _id: result3.insertedId}]);\n\n        var result4 = upsert(coll, useUpdate, {foo: t1}, {foo: t2});\n        test.equal(result2.numberAffected, 1);\n        if (! skipIds)\n          test.isFalse(result2.insertedId);\n        compareResults(test, skipIds, coll.find().fetch(), [{foo: t2, _id: result3.insertedId}]);\n\n        coll.remove({});\n\n        // Test modification by upsert\n\n        var result5 = upsert(coll, useUpdate, {name: 'David'}, {$set: {foo: 1}});\n        test.equal(result5.numberAffected, 1);\n        if (! skipIds)\n          test.isTrue(result5.insertedId);\n        var davidId = result5.insertedId;\n        compareResults(test, skipIds, coll.find().fetch(), [{name: 'David', foo: 1, _id: davidId}]);\n\n        test.throws(function () {\n          // test that bad modifier fails fast\n          upsert(coll, useUpdate, {name: 'David'}, {$blah: {foo: 2}});\n        });\n\n\n        var result6 = upsert(coll, useUpdate, {name: 'David'}, {$set: {foo: 2}});\n        test.equal(result6.numberAffected, 1);\n        if (! skipIds)\n          test.isFalse(result6.insertedId);\n        compareResults(test, skipIds, coll.find().fetch(), [{name: 'David', foo: 2,\n                                                               _id: result5.insertedId}]);\n\n        var emilyId = coll.insert({name: 'Emily', foo: 2});\n        compareResults(test, skipIds, coll.find().fetch(), [{name: 'David', foo: 2, _id: davidId},\n                                                              {name: 'Emily', foo: 2, _id: emilyId}]);\n\n        // multi update by upsert\n        var result7 = upsert(coll, useUpdate, {foo: 2},\n                             {$set: {bar: 7},\n                              $setOnInsert: {name: 'Fred', foo: 2}},\n                             {multi: true});\n        test.equal(result7.numberAffected, 2);\n        if (! skipIds)\n          test.isFalse(result7.insertedId);\n        compareResults(test, skipIds, coll.find().fetch(), [{name: 'David', foo: 2, bar: 7, _id: davidId},\n                                                              {name: 'Emily', foo: 2, bar: 7, _id: emilyId}]);\n\n        // insert by multi upsert\n        var result8 = upsert(coll, useUpdate, {foo: 3},\n                             {$set: {bar: 7},\n                              $setOnInsert: {name: 'Fred', foo: 2}},\n                             {multi: true});\n        test.equal(result8.numberAffected, 1);\n        if (! skipIds)\n          test.isTrue(result8.insertedId);\n        var fredId = result8.insertedId;\n        compareResults(test, skipIds, coll.find().fetch(),\n                       [{name: 'David', foo: 2, bar: 7, _id: davidId},\n                        {name: 'Emily', foo: 2, bar: 7, _id: emilyId},\n                        {name: 'Fred', foo: 2, bar: 7, _id: fredId}]);\n\n        // test `insertedId` option\n        var result9 = upsert(coll, useUpdate, {name: 'Steve'},\n                             {name: 'Steve'},\n                             {insertedId: 'steve'});\n        test.equal(result9.numberAffected, 1);\n        if (! skipIds)\n          test.equal(result9.insertedId, 'steve');\n        compareResults(test, skipIds, coll.find().fetch(),\n                       [{name: 'David', foo: 2, bar: 7, _id: davidId},\n                        {name: 'Emily', foo: 2, bar: 7, _id: emilyId},\n                        {name: 'Fred', foo: 2, bar: 7, _id: fredId},\n                        {name: 'Steve', _id: 'steve'}]);\n        test.isTrue(coll.findOne('steve'));\n        test.isFalse(coll.findOne('fred'));\n\n        // Test $ operator in selectors.\n\n        var result10 = upsert(coll, useUpdate,\n                              {$or: [{name: 'David'}, {name: 'Emily'}]},\n                              {$set: {foo: 3}}, {multi: true});\n        test.equal(result10.numberAffected, 2);\n        if (! skipIds)\n          test.isFalse(result10.insertedId);\n        compareResults(test, skipIds,\n                       [coll.findOne({name: 'David'}), coll.findOne({name: 'Emily'})],\n                       [{name: 'David', foo: 3, bar: 7, _id: davidId},\n                        {name: 'Emily', foo: 3, bar: 7, _id: emilyId}]\n                      );\n\n        var result11 = upsert(\n          coll, useUpdate,\n          {\n            name: 'Charlie',\n            $or: [{ foo: 2}, { bar: 7 }]\n          },\n          { $set: { foo: 3 } }\n        );\n        test.equal(result11.numberAffected, 1);\n        if (! skipIds)\n          test.isTrue(result11.insertedId);\n        var charlieId = result11.insertedId;\n        compareResults(test, skipIds,\n                       coll.find({ name: 'Charlie' }).fetch(),\n                       [{name: 'Charlie', foo: 3, _id: charlieId}]);\n      });\n    });\n  });\n});\n\nvar asyncUpsertTestName = function (useNetwork, useDirectCollection,\n                                    useUpdate, idGeneration) {\n  return \"mongo-livedata - async \" +\n    (useUpdate ? \"update \" : \"\") +\n    \"upsert \" +\n    (useNetwork ? \"over network \" : \"\") +\n    (useDirectCollection ? \", direct collection \" : \"\") +\n    idGeneration;\n};\n\n// This is a duplicate of the test above, with some changes to make it work for\n// callback style. On the client, we test server-backed and in-memory\n// collections, and run the tests for both the Meteor.Collection and the\n// LocalCollection. On the server, we test mongo-backed collections, for both\n// the Meteor.Collection and the MongoConnection.\n_.each(Meteor.isServer ? [false] : [true, false], function (useNetwork) {\n  _.each(useNetwork ? [false] : [true, false], function (useDirectCollection) {\n    _.each([true, false], function (useUpdate) {\n      Tinytest.addAsync(asyncUpsertTestName(useNetwork, useDirectCollection, useUpdate, idGeneration), function (test, onComplete) {\n        var coll;\n        var run = test.runId();\n        var collName = \"livedata_upsert_collection_\"+run+\n              (useUpdate ? \"_update_\" : \"\") +\n              (useNetwork ? \"_network_\" : \"\") +\n              (useDirectCollection ? \"_direct_\" : \"\");\n        if (useNetwork) {\n          Meteor.call(\"createInsecureCollection\", collName, collectionOptions);\n          coll = new Meteor.Collection(collName, collectionOptions);\n          Meteor.subscribe(\"c-\" + collName);\n        } else {\n          var opts = _.clone(collectionOptions);\n          if (Meteor.isClient)\n            opts.connection = null;\n          coll = new Meteor.Collection(collName, opts);\n          if (useDirectCollection)\n            coll = coll._collection;\n        }\n\n        var result1;\n        var next1 = function (err, result) {\n          result1 = result;\n          test.equal(result1.numberAffected, 1);\n          if (! useUpdate) {\n            test.isTrue(result1.insertedId);\n            test.equal(result1.insertedId, 'foo');\n          }\n          compareResults(test, useUpdate, coll.find().fetch(), [{foo: 'bar', _id: 'foo'}]);\n          upsert(coll, useUpdate, {_id: 'foo'}, {foo: 'baz'}, next2);\n        };\n\n        // Test starts here.\n        upsert(coll, useUpdate, {_id: 'foo'}, {_id: 'foo', foo: 'bar'}, next1);\n\n        var t1, t2, result2;\n        var next2 = function (err, result) {\n          result2 = result;\n          test.equal(result2.numberAffected, 1);\n          if (! useUpdate)\n            test.isFalse(result2.insertedId);\n          compareResults(test, useUpdate, coll.find().fetch(), [{foo: 'baz', _id: result1.insertedId}]);\n          coll.remove({_id: 'foo'});\n          compareResults(test, useUpdate, coll.find().fetch(), []);\n\n          // Test values that require transformation to go into Mongo:\n\n          t1 = new Meteor.Collection.ObjectID();\n          t2 = new Meteor.Collection.ObjectID();\n          upsert(coll, useUpdate, {_id: t1}, {_id: t1, foo: 'bar'}, next3);\n        };\n\n        var result3;\n        var next3 = function (err, result) {\n          result3 = result;\n          test.equal(result3.numberAffected, 1);\n          if (! useUpdate) {\n            test.isTrue(result3.insertedId);\n            test.equal(t1, result3.insertedId);\n          }\n          compareResults(test, useUpdate, coll.find().fetch(), [{_id: t1, foo: 'bar'}]);\n\n          upsert(coll, useUpdate, {_id: t1}, {foo: t2}, next4);\n        };\n\n        var next4 = function (err, result4) {\n          test.equal(result2.numberAffected, 1);\n          if (! useUpdate)\n            test.isFalse(result2.insertedId);\n          compareResults(test, useUpdate, coll.find().fetch(), [{foo: t2, _id: result3.insertedId}]);\n\n          coll.remove({_id: t1});\n\n          // Test modification by upsert\n          upsert(coll, useUpdate, {_id: 'David'}, {$set: {foo: 1}}, next5);\n        };\n\n        var result5;\n        var next5 = function (err, result) {\n          result5 = result;\n          test.equal(result5.numberAffected, 1);\n          if (! useUpdate) {\n            test.isTrue(result5.insertedId);\n            test.equal(result5.insertedId, 'David');\n          }\n          var davidId = result5.insertedId;\n          compareResults(test, useUpdate, coll.find().fetch(), [{foo: 1, _id: davidId}]);\n\n          if (! Meteor.isClient && useDirectCollection) {\n            // test that bad modifier fails\n            // The stub throws an exception about the invalid modifier, which\n            // livedata logs (so we suppress it).\n            Meteor._suppress_log(1);\n            upsert(coll, useUpdate, {_id: 'David'}, {$blah: {foo: 2}}, function (err) {\n              if (! (Meteor.isClient && useDirectCollection))\n                test.isTrue(err);\n              upsert(coll, useUpdate, {_id: 'David'}, {$set: {foo: 2}}, next6);\n            });\n          } else {\n            // XXX skip this test for now for LocalCollection; the fact that\n            // we're in a nested sequence of callbacks means we're inside a\n            // Meteor.defer, which means the exception just gets\n            // logged. Something should be done about this at some point?  Maybe\n            // LocalCollection callbacks don't really have to be deferred.\n            upsert(coll, useUpdate, {_id: 'David'}, {$set: {foo: 2}}, next6);\n          }\n        };\n\n        var result6;\n        var next6 = function (err, result) {\n          result6 = result;\n          test.equal(result6.numberAffected, 1);\n          if (! useUpdate)\n            test.isFalse(result6.insertedId);\n          compareResults(test, useUpdate, coll.find().fetch(), [{_id: 'David', foo: 2}]);\n\n          var emilyId = coll.insert({_id: 'Emily', foo: 2});\n          compareResults(test, useUpdate, coll.find().fetch(), [{_id: 'David', foo: 2},\n                                                                {_id: 'Emily', foo: 2}]);\n\n          // multi update by upsert.\n          // We can't actually update multiple documents since we have to do it by\n          // id, but at least make sure the multi flag doesn't mess anything up.\n          upsert(coll, useUpdate, {_id: 'Emily'},\n                 {$set: {bar: 7},\n                  $setOnInsert: {name: 'Fred', foo: 2}},\n                 {multi: true}, next7);\n        };\n\n        var result7;\n        var next7 = function (err, result) {\n          result7 = result;\n          test.equal(result7.numberAffected, 1);\n          if (! useUpdate)\n            test.isFalse(result7.insertedId);\n          compareResults(test, useUpdate, coll.find().fetch(), [{_id: 'David', foo: 2},\n                                                                {_id: 'Emily', foo: 2, bar: 7}]);\n\n          // insert by multi upsert\n          upsert(coll, useUpdate, {_id: 'Fred'},\n                 {$set: {bar: 7},\n                  $setOnInsert: {name: 'Fred', foo: 2}},\n                 {multi: true}, next8);\n\n        };\n\n        var result8;\n        var next8 = function (err, result) {\n          result8 = result;\n\n          test.equal(result8.numberAffected, 1);\n          if (! useUpdate) {\n            test.isTrue(result8.insertedId);\n            test.equal(result8.insertedId, 'Fred');\n          }\n          var fredId = result8.insertedId;\n          compareResults(test, useUpdate,  coll.find().fetch(),\n                         [{_id: 'David', foo: 2},\n                          {_id: 'Emily', foo: 2, bar: 7},\n                          {name: 'Fred', foo: 2, bar: 7, _id: fredId}]);\n          onComplete();\n        };\n      });\n    });\n  });\n});\n\nif (Meteor.isClient) {\n  Tinytest.addAsync(\"mongo-livedata - async update/remove return values over network \" + idGeneration, function (test, onComplete) {\n    var coll;\n    var run = test.runId();\n    var collName = \"livedata_upsert_collection_\"+run;\n    Meteor.call(\"createInsecureCollection\", collName, collectionOptions);\n    coll = new Meteor.Collection(collName, collectionOptions);\n    Meteor.subscribe(\"c-\" + collName);\n\n    coll.insert({ _id: \"foo\" });\n    coll.insert({ _id: \"bar\" });\n    coll.update({ _id: \"foo\" }, { $set: { foo: 1 } }, { multi: true }, function (err, result) {\n      test.isFalse(err);\n      test.equal(result, 1);\n      coll.update({ _id: \"foo\" }, { _id: \"foo\", foo: 2 }, function (err, result) {\n        test.isFalse(err);\n        test.equal(result, 1);\n        coll.update({ _id: \"baz\" }, { $set: { foo: 1 } }, function (err, result) {\n          test.isFalse(err);\n          test.equal(result, 0);\n          coll.remove({ _id: \"foo\" }, function (err, result) {\n            test.equal(result, 1);\n            coll.remove({ _id: \"baz\" }, function (err, result) {\n              test.equal(result, 0);\n              onComplete();\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\n// Runs a method and its stub which do some upserts. The method throws an error\n// if we don't get the right return values.\nif (Meteor.isClient) {\n  _.each([true, false], function (useUpdate) {\n    Tinytest.addAsync(\"mongo-livedata - \" + (useUpdate ? \"update \" : \"\") + \"upsert in method, \" + idGeneration, function (test, onComplete) {\n      var run = test.runId();\n      upsertTestMethodColl = new Meteor.Collection(upsertTestMethod + \"_collection_\" + run, collectionOptions);\n      var m = {};\n      delete Meteor.connection._methodHandlers[upsertTestMethod];\n      m[upsertTestMethod] = function (run, useUpdate, options) {\n        upsertTestMethodImpl(upsertTestMethodColl, useUpdate, test);\n      };\n      Meteor.methods(m);\n      Meteor.call(upsertTestMethod, run, useUpdate, collectionOptions, function (err, result) {\n        test.isFalse(err);\n        onComplete();\n      });\n    });\n  });\n}\n\n_.each(Meteor.isServer ? [true, false] : [true], function (minimongo) {\n  _.each([true, false], function (useUpdate) {\n    Tinytest.add(\"mongo-livedata - \" + (useUpdate ? \"update \" : \"\") + \"upsert by id\" + (minimongo ? \" minimongo\" : \"\") + \", \" + idGeneration, function (test) {\n      var run = test.runId();\n      var options = collectionOptions;\n      if (minimongo)\n        options = _.extend({}, collectionOptions, { connection: null });\n      var coll = new Meteor.Collection(\"livedata_upsert_by_id_collection_\"+run, options);\n\n      var ret;\n      ret = upsert(coll, useUpdate, {_id: 'foo'}, {$set: {x: 1}});\n      test.equal(ret.numberAffected, 1);\n      if (! useUpdate)\n        test.equal(ret.insertedId, 'foo');\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{_id: 'foo', x: 1}]);\n\n      ret = upsert(coll, useUpdate, {_id: 'foo'}, {$set: {x: 2}});\n      test.equal(ret.numberAffected, 1);\n      if (! useUpdate)\n        test.isFalse(ret.insertedId);\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{_id: 'foo', x: 2}]);\n\n      ret = upsert(coll, useUpdate, {_id: 'bar'}, {$set: {x: 1}});\n      test.equal(ret.numberAffected, 1);\n      if (! useUpdate)\n        test.equal(ret.insertedId, 'bar');\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{_id: 'foo', x: 2},\n                      {_id: 'bar', x: 1}]);\n\n      coll.remove({});\n\n      ret = upsert(coll, useUpdate, {_id: 'traz'}, {x: 1});\n      test.equal(ret.numberAffected, 1);\n      var myId = ret.insertedId;\n      if (! useUpdate) {\n        test.isTrue(myId);\n        // upsert with entire document does NOT take _id from\n        // the query.\n        test.notEqual(myId, 'traz');\n      } else {\n        myId = coll.findOne()._id;\n      }\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{x: 1, _id: myId}]);\n\n      // this time, insert as _id 'traz'\n      ret = upsert(coll, useUpdate, {_id: 'traz'}, {_id: 'traz', x: 2});\n      test.equal(ret.numberAffected, 1);\n      if (! useUpdate)\n        test.equal(ret.insertedId, 'traz');\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{x: 1, _id: myId},\n                      {x: 2, _id: 'traz'}]);\n\n      // now update _id 'traz'\n      ret = upsert(coll, useUpdate, {_id: 'traz'}, {x: 3});\n      test.equal(ret.numberAffected, 1);\n      test.isFalse(ret.insertedId);\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{x: 1, _id: myId},\n                      {x: 3, _id: 'traz'}]);\n\n      // now update, passing _id (which is ok as long as it's the same)\n      ret = upsert(coll, useUpdate, {_id: 'traz'}, {_id: 'traz', x: 4});\n      test.equal(ret.numberAffected, 1);\n      test.isFalse(ret.insertedId);\n      compareResults(test, useUpdate, coll.find().fetch(),\n                     [{x: 1, _id: myId},\n                      {x: 4, _id: 'traz'}]);\n\n    });\n  });\n});\n\n});  // end idGeneration parametrization\n\nTinytest.add('mongo-livedata - rewrite selector', function (test) {\n  test.equal(Meteor.Collection._rewriteSelector({x: /^o+B/im}),\n             {x: {$regex: '^o+B', $options: 'im'}});\n  test.equal(Meteor.Collection._rewriteSelector({x: {$regex: /^o+B/im}}),\n             {x: {$regex: '^o+B', $options: 'im'}});\n  test.equal(Meteor.Collection._rewriteSelector({x: /^o+B/}),\n             {x: {$regex: '^o+B'}});\n  test.equal(Meteor.Collection._rewriteSelector({x: {$regex: /^o+B/}}),\n             {x: {$regex: '^o+B'}});\n  test.equal(Meteor.Collection._rewriteSelector('foo'),\n             {_id: 'foo'});\n\n  test.equal(\n    Meteor.Collection._rewriteSelector(\n      {'$or': [\n        {x: /^o/},\n        {y: /^p/},\n        {z: 'q'},\n        {w: {$regex: /^r/}}\n      ]}\n    ),\n    {'$or': [\n      {x: {$regex: '^o'}},\n      {y: {$regex: '^p'}},\n      {z: 'q'},\n      {w: {$regex: '^r'}}\n    ]}\n  );\n\n  test.equal(\n    Meteor.Collection._rewriteSelector(\n      {'$or': [\n        {'$and': [\n          {x: /^a/i},\n          {y: /^b/},\n          {z: {$regex: /^c/i}},\n          {w: {$regex: '^[abc]', $options: 'i'}}, // make sure we don't break vanilla selectors\n          {v: {$regex: /O/, $options: 'i'}}, // $options should override the ones on the RegExp object\n          {u: {$regex: /O/m, $options: 'i'}} // $options should override the ones on the RegExp object\n        ]},\n        {'$nor': [\n          {s: /^d/},\n          {t: /^e/i},\n          {u: {$regex: /^f/i}},\n          // even empty string overrides built-in flags\n          {v: {$regex: /^g/i, $options: ''}}\n        ]}\n      ]}\n    ),\n    {'$or': [\n      {'$and': [\n        {x: {$regex: '^a', $options: 'i'}},\n        {y: {$regex: '^b'}},\n        {z: {$regex: '^c', $options: 'i'}},\n        {w: {$regex: '^[abc]', $options: 'i'}},\n        {v: {$regex: 'O', $options: 'i'}},\n        {u: {$regex: 'O', $options: 'i'}}\n      ]},\n      {'$nor': [\n        {s: {$regex: '^d'}},\n        {t: {$regex: '^e', $options: 'i'}},\n        {u: {$regex: '^f', $options: 'i'}},\n        {v: {$regex: '^g', $options: ''}}\n      ]}\n    ]}\n  );\n\n  var oid = new Meteor.Collection.ObjectID();\n  test.equal(Meteor.Collection._rewriteSelector(oid),\n             {_id: oid});\n});\n\ntestAsyncMulti('mongo-livedata - specified _id', [\n  function (test, expect) {\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName);\n      Meteor.subscribe('c-' + collectionName);\n    }\n    var expectError = expect(function (err, result) {\n      test.isTrue(err);\n      var doc = coll.findOne();\n      test.equal(doc.name, \"foo\");\n    });\n    var coll = new Meteor.Collection(collectionName);\n    coll.insert({_id: \"foo\", name: \"foo\"}, expect(function (err1, id) {\n      test.equal(id, \"foo\");\n      var doc = coll.findOne();\n      test.equal(doc._id, \"foo\");\n      Meteor._suppress_log(1);\n      coll.insert({_id: \"foo\", name: \"bar\"}, expectError);\n    }));\n  }\n]);\n\ntestAsyncMulti('mongo-livedata - empty string _id', [\n  function (test, expect) {\n    var self = this;\n    self.collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', self.collectionName);\n      Meteor.subscribe('c-' + self.collectionName);\n    }\n    self.coll = new Meteor.Collection(self.collectionName);\n    try {\n      self.coll.insert({_id: \"\", f: \"foo\"});\n      test.fail(\"Insert with an empty _id should fail\");\n    } catch (e) {\n      // ok\n    }\n    self.coll.insert({_id: \"realid\", f: \"bar\"}, expect(function (err, res) {\n      test.equal(res, \"realid\");\n    }));\n  },\n  function (test, expect) {\n    var self = this;\n    var docs = self.coll.find().fetch();\n    test.equal(docs, [{_id: \"realid\", f: \"bar\"}]);\n  },\n  function (test, expect) {\n    var self = this;\n    if (Meteor.isServer) {\n      self.coll._collection.insert({_id: \"\", f: \"baz\"});\n      test.equal(self.coll.find().fetch().length, 2);\n    }\n  }\n]);\n\n\nif (Meteor.isServer) {\n\n  testAsyncMulti(\"mongo-livedata - minimongo on server to server connection\", [\n    function (test, expect) {\n      var self = this;\n      Meteor._debug(\"connection setup\");\n      self.id = Random.id();\n      var C = self.C = new Meteor.Collection(\"ServerMinimongo_\" + self.id);\n      C.allow({\n        insert: function () {return true;},\n        update: function () {return true;},\n        remove: function () {return true;}\n      });\n      C.insert({a: 0, b: 1});\n      C.insert({a: 0, b: 2});\n      C.insert({a: 1, b: 3});\n      Meteor.publish(self.id, function () {\n        return C.find({a: 0});\n      });\n\n      self.conn = DDP.connect(Meteor.absoluteUrl());\n      pollUntil(expect, function () {\n        return self.conn.status().connected;\n      }, 10000);\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (self.conn.status().connected) {\n        self.miniC = new Meteor.Collection(\"ServerMinimongo_\" + self.id, {\n          connection: self.conn\n        });\n        var exp = expect(function (err) {\n          test.isFalse(err);\n        });\n        self.conn.subscribe(self.id, {\n          onError: exp,\n          onReady: exp\n        });\n      }\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (self.miniC) {\n        var contents = self.miniC.find().fetch();\n        test.equal(contents.length, 2);\n        test.equal(contents[0].a, 0);\n      }\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (!self.miniC)\n        return;\n      self.miniC.insert({a:0, b:3});\n      var contents = self.miniC.find({b:3}).fetch();\n      test.equal(contents.length, 1);\n      test.equal(contents[0].a, 0);\n    }\n  ]);\n\n  testAsyncMulti(\"mongo-livedata - minimongo observe on server\", [\n    function (test, expect) {\n      var self = this;\n      self.id = Random.id();\n      self.C = new Meteor.Collection(\"ServerMinimongoObserve_\" + self.id);\n      self.events = [];\n\n      Meteor.publish(self.id, function () {\n        return self.C.find();\n      });\n\n      self.conn = DDP.connect(Meteor.absoluteUrl());\n      pollUntil(expect, function () {\n        return self.conn.status().connected;\n      }, 10000);\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (self.conn.status().connected) {\n        self.miniC = new Meteor.Collection(\"ServerMinimongoObserve_\" + self.id, {\n          connection: self.conn\n        });\n        var exp = expect(function (err) {\n          test.isFalse(err);\n        });\n        self.conn.subscribe(self.id, {\n          onError: exp,\n          onReady: exp\n        });\n      }\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (self.miniC) {\n        self.obs = self.miniC.find().observeChanges({\n          added: function (id, fields) {\n            self.events.push({evt: \"a\", id: id});\n            Meteor._sleepForMs(200);\n            self.events.push({evt: \"b\", id: id});\n          }\n        });\n        self.one = self.C.insert({});\n        self.two = self.C.insert({});\n        pollUntil(expect, function () {\n          return self.events.length === 4;\n        }, 10000);\n      }\n    },\n\n    function (test, expect) {\n      var self = this;\n      if (self.miniC) {\n        test.equal(self.events, [\n          {evt: \"a\", id: self.one},\n          {evt: \"b\", id: self.one},\n          {evt: \"a\", id: self.two},\n          {evt: \"b\", id: self.two}\n        ]);\n      }\n      self.obs && self.obs.stop();\n    }\n  ]);\n}\n\nTinytest.addAsync(\"mongo-livedata - local collections with different connections\", function (test, onComplete) {\n  var cname = Random.id();\n  var cname2 = Random.id();\n  var coll1 = new Meteor.Collection(cname);\n  var doc = { foo: \"bar\" };\n  var coll2 = new Meteor.Collection(cname2, { connection: null });\n  coll2.insert(doc, function (err, id) {\n    test.equal(coll1.find(doc).count(), 0);\n    test.equal(coll2.find(doc).count(), 1);\n    onComplete();\n  });\n});\n\nTinytest.addAsync(\"mongo-livedata - local collection with null connection, w/ callback\", function (test, onComplete) {\n  var cname = Random.id();\n  var coll1 = new Meteor.Collection(cname, { connection: null });\n  var doc = { foo: \"bar\" };\n  var docId = coll1.insert(doc, function (err, id) {\n    test.equal(docId, id);\n    test.equal(coll1.findOne(doc)._id, id);\n    onComplete();\n  });\n});\n\nTinytest.addAsync(\"mongo-livedata - local collection with null connection, w/o callback\", function (test, onComplete) {\n  var cname = Random.id();\n  var coll1 = new Meteor.Collection(cname, { connection: null });\n  var doc = { foo: \"bar\" };\n  var docId = coll1.insert(doc);\n  test.equal(coll1.findOne(doc)._id, docId);\n  onComplete();\n});\n\ntestAsyncMulti(\"mongo-livedata - update handles $push with $each correctly\", [\n  function (test, expect) {\n    var self = this;\n    var collectionName = Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    self.collection = new Meteor.Collection(collectionName);\n\n    self.id = self.collection.insert(\n      {name: 'jens', elements: ['X', 'Y']}, expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(self.id, res);\n        }));\n  },\n  function (test, expect) {\n    var self = this;\n    self.collection.update(self.id, {\n      $push: {\n        elements: {\n          $each: ['A', 'B', 'C'],\n          $slice: -4\n        }}}, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(\n            self.collection.findOne(self.id),\n            {_id: self.id, name: 'jens', elements: ['Y', 'A', 'B', 'C']});\n        }));\n  }\n]);\n\nif (Meteor.isServer) {\n  Tinytest.add(\"mongo-livedata - upsert handles $push with $each correctly\", function (test) {\n    var collection = new Meteor.Collection(Random.id());\n\n    var result = collection.upsert(\n      {name: 'jens'},\n      {$push: {\n        elements: {\n          $each: ['A', 'B', 'C'],\n          $slice: -4\n        }}});\n\n    test.equal(collection.findOne(result.insertedId),\n               {_id: result.insertedId,\n                name: 'jens',\n                elements: ['A', 'B', 'C']});\n\n    var id = collection.insert({name: \"david\", elements: ['X', 'Y']});\n    result = collection.upsert(\n      {name: 'david'},\n      {$push: {\n        elements: {\n          $each: ['A', 'B', 'C'],\n          $slice: -4\n        }}});\n\n    test.equal(collection.findOne(id),\n               {_id: id,\n                name: 'david',\n                elements: ['Y', 'A', 'B', 'C']});\n  });\n}\n\n// This is a VERY white-box test.\nMeteor.isServer && Tinytest.add(\"mongo-livedata - oplog - _disableOplog\", function (test) {\n  var collName = Random.id();\n  var coll = new Meteor.Collection(collName);\n  if (MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle) {\n    var observeWithOplog = coll.find({x: 5})\n          .observeChanges({added: function () {}});\n    test.isTrue(observeWithOplog._observeDriver);\n    test.isTrue(observeWithOplog._observeDriver._usesOplog);\n    observeWithOplog.stop();\n  }\n  var observeWithoutOplog = coll.find({x: 6}, {_disableOplog: true})\n        .observeChanges({added: function () {}});\n  test.isTrue(observeWithoutOplog._observeDriver);\n  test.isFalse(observeWithoutOplog._observeDriver._usesOplog);\n  observeWithoutOplog.stop();\n});\n\nMeteor.isServer && Tinytest.add(\"mongo-livedata - oplog - include selector fields\", function (test) {\n  var collName = \"includeSelector\" + Random.id();\n  var coll = new Meteor.Collection(collName);\n\n  var docId = coll.insert({a: 1, b: [3, 2], c: 'foo'});\n  test.isTrue(docId);\n\n  // Wait until we've processed the insert oplog entry. (If the insert shows up\n  // during the observeChanges, the bug in question is not consistently\n  // reproduced.) We don't have to do this for polling observe (eg\n  // --disable-oplog).\n  var oplog = MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle;\n  oplog && oplog.waitUntilCaughtUp();\n\n  var output = [];\n  var handle = coll.find({a: 1, b: 2}, {fields: {c: 1}}).observeChanges({\n    added: function (id, fields) {\n      output.push(['added', id, fields]);\n    },\n    changed: function (id, fields) {\n      output.push(['changed', id, fields]);\n    },\n    removed: function (id) {\n      output.push(['removed', id]);\n    }\n  });\n  // Initially should match the document.\n  test.length(output, 1);\n  test.equal(output.shift(), ['added', docId, {c: 'foo'}]);\n\n  // Update in such a way that, if we only knew about the published field 'c'\n  // and the changed field 'b' (but not the field 'a'), we would think it didn't\n  // match any more.  (This is a regression test for a bug that existed because\n  // we used to not use the shared projection in the initial query.)\n  runInFence(function () {\n    coll.update(docId, {$set: {'b.0': 2, c: 'bar'}});\n  });\n  test.length(output, 1);\n  test.equal(output.shift(), ['changed', docId, {c: 'bar'}]);\n\n  handle.stop();\n});\n\nMeteor.isServer && Tinytest.add(\"mongo-livedata - oplog - transform\", function (test) {\n  var collName = \"oplogTransform\" + Random.id();\n  var coll = new Meteor.Collection(collName);\n\n  var docId = coll.insert({a: 25, x: {x: 5, y: 9}});\n  test.isTrue(docId);\n\n  // Wait until we've processed the insert oplog entry. (If the insert shows up\n  // during the observeChanges, the bug in question is not consistently\n  // reproduced.) We don't have to do this for polling observe (eg\n  // --disable-oplog).\n  var oplog = MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle;\n  oplog && oplog.waitUntilCaughtUp();\n\n  var cursor = coll.find({}, {transform: function (doc) {\n    return doc.x;\n  }});\n\n  var changesOutput = [];\n  var changesHandle = cursor.observeChanges({\n    added: function (id, fields) {\n      changesOutput.push(['added', fields]);\n    }\n  });\n  // We should get untransformed fields via observeChanges.\n  test.length(changesOutput, 1);\n  test.equal(changesOutput.shift(), ['added', {a: 25, x: {x: 5, y: 9}}]);\n  changesHandle.stop();\n\n  var transformedOutput = [];\n  var transformedHandle = cursor.observe({\n    added: function (doc) {\n      transformedOutput.push(['added', doc]);\n    }\n  });\n  test.length(transformedOutput, 1);\n  test.equal(transformedOutput.shift(), ['added', {x: 5, y: 9}]);\n  transformedHandle.stop();\n});\n\n\nMeteor.isServer && Tinytest.add(\"mongo-livedata - oplog - drop collection\", function (test) {\n  var collName = \"dropCollection\" + Random.id();\n  var coll = new Meteor.Collection(collName);\n\n  var doc1Id = coll.insert({a: 'foo', c: 1});\n  var doc2Id = coll.insert({b: 'bar'});\n  var doc3Id = coll.insert({a: 'foo', c: 2});\n  var tmp;\n\n  var output = [];\n  var handle = coll.find({a: 'foo'}).observeChanges({\n    added: function (id, fields) {\n      output.push(['added', id, fields]);\n    },\n    changed: function (id) {\n      output.push(['changed']);\n    },\n    removed: function (id) {\n      output.push(['removed', id]);\n    }\n  });\n  test.length(output, 2);\n  // make order consistent\n  if (output.length === 2 && output[0][1] === doc3Id) {\n    tmp = output[0];\n    output[0] = output[1];\n    output[1] = tmp;\n  }\n  test.equal(output.shift(), ['added', doc1Id, {a: 'foo', c: 1}]);\n  test.equal(output.shift(), ['added', doc3Id, {a: 'foo', c: 2}]);\n\n  // Wait until we've processed the insert oplog entry, so that we are in a\n  // steady state (and we don't see the dropped docs because we are FETCHING).\n  var oplog = MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle;\n  oplog && oplog.waitUntilCaughtUp();\n\n  // Drop the collection. Should remove all docs.\n  runInFence(function () {\n    coll._dropCollection();\n  });\n\n  test.length(output, 2);\n  // make order consistent\n  if (output.length === 2 && output[0][1] === doc3Id) {\n    tmp = output[0];\n    output[0] = output[1];\n    output[1] = tmp;\n  }\n  test.equal(output.shift(), ['removed', doc1Id]);\n  test.equal(output.shift(), ['removed', doc3Id]);\n\n  // Put something back in.\n  var doc4Id;\n  runInFence(function () {\n    doc4Id = coll.insert({a: 'foo', c: 3});\n  });\n\n  test.length(output, 1);\n  test.equal(output.shift(), ['added', doc4Id, {a: 'foo', c: 3}]);\n\n  handle.stop();\n});\n\nvar TestCustomType = function (head, tail) {\n  // use different field names on the object than in JSON, to ensure we are\n  // actually treating this as an opaque object.\n  this.myHead = head;\n  this.myTail = tail;\n};\n_.extend(TestCustomType.prototype, {\n  clone: function () {\n    return new TestCustomType(this.myHead, this.myTail);\n  },\n  equals: function (other) {\n    return other instanceof TestCustomType\n      && EJSON.equals(this.myHead, other.myHead)\n      && EJSON.equals(this.myTail, other.myTail);\n  },\n  typeName: function () {\n    return 'someCustomType';\n  },\n  toJSONValue: function () {\n    return {head: this.myHead, tail: this.myTail};\n  }\n});\n\nEJSON.addType('someCustomType', function (json) {\n  return new TestCustomType(json.head, json.tail);\n});\n\ntestAsyncMulti(\"mongo-livedata - oplog - update EJSON\", [\n  function (test, expect) {\n    var self = this;\n    var collectionName = \"ejson\" + Random.id();\n    if (Meteor.isClient) {\n      Meteor.call('createInsecureCollection', collectionName);\n      Meteor.subscribe('c-' + collectionName);\n    }\n\n    self.collection = new Meteor.Collection(collectionName);\n    self.date = new Date;\n    self.objId = new Meteor.Collection.ObjectID;\n\n    self.id = self.collection.insert(\n      {d: self.date, oi: self.objId,\n       custom: new TestCustomType('a', 'b')},\n      expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(self.id, res);\n      }));\n  },\n  function (test, expect) {\n    var self = this;\n    self.changes = [];\n    self.handle = self.collection.find({}).observeChanges({\n      added: function (id, fields) {\n        self.changes.push(['a', id, fields]);\n      },\n      changed: function (id, fields) {\n        self.changes.push(['c', id, fields]);\n      },\n      removed: function (id) {\n        self.changes.push(['r', id]);\n      }\n    });\n    test.length(self.changes, 1);\n    test.equal(self.changes.shift(),\n               ['a', self.id,\n                {d: self.date, oi: self.objId,\n                 custom: new TestCustomType('a', 'b')}]);\n\n    // First, replace the entire custom object.\n    // (runInFence is useful for the server, using expect() is useful for the\n    // client)\n    runInFence(function () {\n      self.collection.update(\n        self.id, {$set: {custom: new TestCustomType('a', 'c')}},\n        expect(function (err) {\n          test.isFalse(err);\n        }));\n    });\n  },\n  function (test, expect) {\n    var self = this;\n    test.length(self.changes, 1);\n    test.equal(self.changes.shift(),\n               ['c', self.id, {custom: new TestCustomType('a', 'c')}]);\n\n    // Now, sneakily replace just a piece of it. Meteor won't do this, but\n    // perhaps you are accessing Mongo directly.\n    runInFence(function () {\n      self.collection.update(\n        self.id, {$set: {'custom.EJSON$value.EJSONtail': 'd'}},\n      expect(function (err) {\n        test.isFalse(err);\n      }));\n    });\n  },\n  function (test, expect) {\n    var self = this;\n    test.length(self.changes, 1);\n    test.equal(self.changes.shift(),\n               ['c', self.id, {custom: new TestCustomType('a', 'd')}]);\n\n    // Update a date and an ObjectID too.\n    self.date2 = new Date(self.date.valueOf() + 1000);\n    self.objId2 = new Meteor.Collection.ObjectID;\n    runInFence(function () {\n      self.collection.update(\n        self.id, {$set: {d: self.date2, oi: self.objId2}},\n      expect(function (err) {\n        test.isFalse(err);\n      }));\n    });\n  },\n  function (test, expect) {\n    var self = this;\n    test.length(self.changes, 1);\n    test.equal(self.changes.shift(),\n               ['c', self.id, {d: self.date2, oi: self.objId2}]);\n\n    self.handle.stop();\n  }\n]);\n","if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Meteor.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true)\n          throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Meteor.Collection(\n          fullName, {idGeneration: idGeneration, transform: transform});\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false)\n          throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function() {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\n      \"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\n      \"collection-locked-down\", false /*insecure*/);\n    // resticted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", false, function (doc) {\n        return doc.a;\n      });\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.cantInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([\n        restrictedCollectionDefaultSecure,\n        restrictedCollectionDefaultInsecure,\n        restrictedCollectionForUpdateOptionsTest\n      ], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function() { return true; }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Meteor.Collection(\n        fullName, {idGeneration: idGeneration, transform: transform});\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // resticted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", function (doc) {\n        return doc.a;\n      });\n\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialAllowTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialDenyTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [\n      function (test, expect) {\n        var fetchId = restrictedCollectionForFetchTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        var fetchAllId = restrictedCollectionForFetchAllTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        restrictedCollectionForFetchTest.update(\n          fetchId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: field1,field2,field3,_id\");\n          }));\n        restrictedCollectionForFetchTest.remove(\n          fetchId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: field1,field2,field3,_id\");\n          }));\n\n        restrictedCollectionForFetchAllTest.update(\n          fetchAllId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: field1,field2,field3,field4,_id\");\n          }));\n        restrictedCollectionForFetchAllTest.remove(\n          fetchAllId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: field1,field2,field3,field4,_id\");\n          }));\n      }\n    ]);\n\n    (function(){\n      var item1;\n      var item2;\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [\n        function (test, expect) {\n          restrictedCollectionWithTransform.callClearMethod(expect(function () {\n            test.equal(restrictedCollectionWithTransform.find().count(), 0);\n          }));\n        },\n        function (test, expect) {\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"bar\", baz: \"baz\"}\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            item1 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            item2 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"adsfadf\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"bar\"},\n            topLevelField: true\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n          }));\n        },\n        function (test, expect) {\n          test.equal(\n            restrictedCollectionWithTransform.findOne({\"a.bar\": \"bar\"}),\n            {foo: \"foo\", bar: \"bar\", baz: \"baz\"});\n          restrictedCollectionWithTransform.remove(item1, expect(function (e, res) {\n            test.isFalse(e);\n          }));\n          restrictedCollectionWithTransform.remove(item2, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n        }\n      ]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [\n      function (test, expect) {\n        insecureCollection.callClearMethod(expect(function () {\n          test.equal(insecureCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        var id = insecureCollection.insert({foo: 'bar'}, expect(function(err, res) {\n          test.equal(res, id);\n          test.equal(insecureCollection.find(id).count(), 1);\n          test.equal(insecureCollection.findOne(id).foo, 'bar');\n        }));\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }\n    ]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [\n      function (test, expect) {\n        lockedDownCollection.callClearMethod(expect(function() {\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        lockedDownCollection.insert({foo: 'bar'}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      }\n    ]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n        // init\n        function (test, expect) {\n          collection.callClearMethod(expect(function () {\n            test.equal(collection.find().count(), 0);\n          }));\n        },\n        // put a few objects\n        function (test, expect) {\n          var doc = {canInsert: true, canUpdate: true};\n          id1 = collection.insert(doc);\n          id2 = collection.insert(doc);\n          collection.insert(doc);\n          collection.insert(doc, expect(function (err, res) {\n            test.isFalse(err);\n            test.equal(collection.find().count(), 4);\n          }));\n        },\n        // update by id\n        function (test, expect) {\n          collection.update(\n            id1,\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(collection.find({updated: true}).count(), 1);\n            }));\n        },\n        // update by id in an object\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update with replacement operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {_id: id2, updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /In a restricted/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // upsert not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: { upserted: true }},\n            { upsert: true },\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /in a restricted/);\n              test.equal(collection.find({ upserted: true }).count(), 0);\n            }));\n        },\n        // update with rename operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$rename: {updated: 'asdf'}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /not allowed/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.update(\n              {updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/update',\n            {updated: {$exists: false}},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n        function (test, expect) {\n          test.throws(function () {\n            collection.update(\n              {_id: id1, updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n        },\n        // remove method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.remove({updated: true});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/remove',\n            {updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        }\n      ]);\n    }) ();\n\n    _.each(\n      [restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure],\n      function(collection) {\n        var canUpdateId, canRemoveId;\n\n        testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n          // init\n          function (test, expect) {\n            collection.callClearMethod(expect(function () {\n              test.equal(collection.find().count(), 0);\n            }));\n          },\n\n          // insert with no allows passing. request is denied.\n          function (test, expect) {\n            collection.insert(\n              {},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and one deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and other deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert2: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert one allow passes. allowed.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 1);\n              }));\n          },\n          // insert other allow passes. allowed.\n          // includes canUpdate for later.\n          function (test, expect) {\n            canUpdateId = collection.insert(\n              {canInsert2: true, canUpdate: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 2);\n              }));\n          },\n          // yet a third insert executes. this one has canRemove and\n          // cantRemove set for later.\n          function (test, expect) {\n            canRemoveId = collection.insert(\n              {canInsert: true, canRemove: true, cantRemove: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // can't update with a non-operator mutation\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {newObject: 1},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // updating dotted fields works as if we are changing their\n          // top part\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"dotted.field\": 1}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n              }));\n          },\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"verySecret.field\": 1}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find({verySecret: {$exists: true}}).count(), 0);\n              }));\n          },\n\n          // update doesn't do anything if no docs match\n          function (test, expect) {\n            collection.update(\n              \"doesn't exist\",\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when access is denied trying to set `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to set two fields, one of which is\n          // `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {updated: true, verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to modify docs that don't\n          // have `canUpdate` set\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update executes when it should\n          function (test, expect) {\n            collection.update(\n              canUpdateId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find({updated: true}).count(), 1);\n              }));\n          },\n\n          // remove fails when trying to modify a doc with no `canRemove` set\n          function (test, expect) {\n            collection.remove(canUpdateId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n          // remove fails when trying to modify an doc with `cantRemove`\n          // set\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n\n          // update the doc to remove cantRemove.\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {cantRemove: false, canUpdate2: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find({cantRemove: true}).count(), 0);\n              }));\n          },\n\n          // now remove can remove it.\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.isFalse(err);\n              // successfully removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // methods can still bypass restrictions\n          function (test, expect) {\n            collection.callClearMethod(\n              expect(function (err, res) {\n                test.isFalse(err);\n                // successfully removed\n                test.equal(collection.find().count(), 0);\n            }));\n          }\n        ]);\n      });\n  });  // end idGeneration loop\n}  // end if isClient\n\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Meteor.Collection(null);\n\n    test.throws(function () {\n      collection.allow({invalidOption: true});\n    });\n    test.throws(function () {\n      collection.deny({invalidOption: true});\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({fetch: function () {}}); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Meteor.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object! This may collide with itself if run multiple\n    // times (but is better than the old test which had the same problem)\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Meteor.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage)\n      Package.insecure = insecurePackage;\n    else\n      delete Package.insecure;\n  });\n}\n","Tinytest.add(\n  'collection - call Meteor.Collection without new',\n  function (test) {\n    test.throws(\n      function () {\n        Meteor.Collection(null);\n      },\n      /use \"new\" to construct a Meteor\\.Collection/\n    );\n  }\n);\n","var makeCollection = function () {\n  if (Meteor.isServer)\n    return new Meteor.Collection(Random.id());\n  else\n    return new Meteor.Collection(null);\n};\n\n_.each ([{added:'added', forceOrdered: true},\n         {added:'added', forceOrdered: false},\n         {added: 'addedBefore', forceOrdered: false}], function (options) {\n           var added = options.added;\n           var forceOrdered = options.forceOrdered;\n  Tinytest.addAsync(\"observeChanges - single id - basics \"\n                    + added\n                    + (forceOrdered ? \" force ordered\" : \"\"),\n                    function (test, onComplete) {\n    var c = makeCollection();\n    var counter = 0;\n    var callbacks = [added, \"changed\", \"removed\"];\n    if (forceOrdered)\n      callbacks.push(\"movedBefore\");\n    withCallbackLogger(test,\n                       callbacks,\n                       Meteor.isServer,\n                       function (logger) {\n    var barid = c.insert({thing: \"stuff\"});\n    var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n    var handle = c.find(fooid).observeChanges(logger);\n    if (added === 'added')\n      logger.expectResult(added, [fooid, {noodles: \"good\", bacon: \"bad\",apples: \"ok\"}]);\n    else\n      logger.expectResult(added,\n                          [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}, null]);\n    c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n    logger.expectResult(\"changed\",\n                        [fooid, {noodles: \"alright\", potatoes: \"tasty\", bacon: undefined}]);\n\n    c.remove(fooid);\n    logger.expectResult(\"removed\", [fooid]);\n\n    c.remove(barid);\n\n    c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n    });\n  });\n});\n\nTinytest.addAsync(\"observeChanges - callback isolation\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handles = [];\n    var cursor = c.find();\n    handles.push(cursor.observeChanges(logger));\n    // fields-tampering observer\n    handles.push(cursor.observeChanges({\n      added: function(id, fields) {\n        fields.apples = 'green';\n      },\n      changed: function(id, fields) {\n        fields.apples = 'green';\n      },\n    }));\n\n    var fooid = c.insert({apples: \"ok\"});\n    logger.expectResult(\"added\", [fooid, {apples: \"ok\"}]);\n\n    c.update(fooid, {apples: \"not ok\"})\n    logger.expectResult(\"changed\", [fooid, {apples: \"not ok\"}]);\n\n    test.equal(c.findOne(fooid).apples, \"not ok\");\n\n    _.each(handles, function(handle) { handle.stop(); });\n    onComplete();\n  });\n\n});\n\nTinytest.addAsync(\"observeChanges - single id - initial adds\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n  var handle = c.find(fooid).observeChanges(logger);\n  logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\n\n\nTinytest.addAsync(\"observeChanges - unordered - initial adds\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n  var barid = c.insert({noodles: \"good\", bacon: \"weird\", apples: \"ok\"});\n  var handle = c.find().observeChanges(logger);\n  logger.expectResultUnordered([\n    {callback: \"added\",\n     args: [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]},\n    {callback: \"added\",\n     args: [barid, {noodles: \"good\", bacon: \"weird\", apples: \"ok\"}]}\n  ]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\nTinytest.addAsync(\"observeChanges - unordered - basics\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var handle = c.find().observeChanges(logger);\n  var barid = c.insert({thing: \"stuff\"});\n  logger.expectResultOnly(\"added\", [barid, {thing: \"stuff\"}]);\n\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n  logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n\n  c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n  c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n  logger.expectResultOnly(\"changed\",\n                      [fooid, {noodles: \"alright\", potatoes: \"tasty\", bacon: undefined}]);\n  c.remove(fooid);\n  logger.expectResultOnly(\"removed\", [fooid]);\n  c.remove(barid);\n  logger.expectResultOnly(\"removed\", [barid]);\n\n  fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n  logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\nif (Meteor.isServer) {\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({}, {fields:{noodles: 1, bacon: 1}}).observeChanges(logger);\n      var barid = c.insert({thing: \"stuff\"});\n      logger.expectResultOnly(\"added\", [barid, {}]);\n\n      var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n      logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n\n      c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n      logger.expectResultOnly(\"changed\",\n                              [fooid, {noodles: \"alright\", bacon: undefined}]);\n      c.update(fooid, {noodles: \"alright\", potatoes: \"meh\", apples: \"ok\"});\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      c.remove(barid);\n      logger.expectResultOnly(\"removed\", [barid]);\n\n      fooid = c.insert({noodles: \"good\", bacon: \"bad\"});\n\n      logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields + selector on excluded fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({ mac: 1, cheese: 2 },\n                          {fields:{noodles: 1, bacon: 1, eggs: 1}}).observeChanges(logger);\n      var barid = c.insert({thing: \"stuff\", mac: 1, cheese: 2});\n      logger.expectResultOnly(\"added\", [barid, {}]);\n\n      var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\", mac: 1, cheese: 2});\n\n      logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n\n      c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\", mac: 1, cheese: 2});\n      logger.expectResultOnly(\"changed\",\n                              [fooid, {noodles: \"alright\", bacon: undefined}]);\n\n      // Doesn't get update event, since modifies only hidden fields\n      c.update(fooid, {noodles: \"alright\", potatoes: \"meh\", apples: \"ok\", mac: 1, cheese: 2});\n      logger.expectNoResult();\n\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      c.remove(barid);\n      logger.expectResultOnly(\"removed\", [barid]);\n\n      fooid = c.insert({noodles: \"good\", bacon: \"bad\", mac: 1, cheese: 2});\n\n      logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields + modify on excluded fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({ mac: 1, cheese: 2 },\n                          {fields:{noodles: 1, bacon: 1, eggs: 1}}).observeChanges(logger);\n      var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\", mac: 1, cheese: 2});\n\n      logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n\n\n      // Noodles go into shadow, mac appears as eggs\n      c.update(fooid, {$rename: { noodles: 'shadow', apples: 'eggs' }});\n      logger.expectResultOnly(\"changed\",\n                              [fooid, {eggs:\"ok\", noodles: undefined}]);\n\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n}\n\n\nTinytest.addAsync(\"observeChanges - unordered - enters and exits result set through change\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var handle = c.find({noodles: \"good\"}).observeChanges(logger);\n  var barid = c.insert({thing: \"stuff\"});\n\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n  logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n\n  c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n  logger.expectResultOnly(\"removed\",\n                      [fooid]);\n  c.remove(fooid);\n  c.remove(barid);\n\n  fooid = c.insert({noodles: \"ok\", bacon: \"bad\", apples: \"ok\"});\n  c.update(fooid, {noodles: \"good\", potatoes: \"tasty\", apples: \"ok\"});\n  logger.expectResult(\"added\", [fooid, {noodles: \"good\", potatoes: \"tasty\", apples: \"ok\"}]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\n\nif (Meteor.isServer) {\n  testAsyncMulti(\"observeChanges - tailable\", [\n    function (test, expect) {\n      var self = this;\n      var collName = \"cap_\" + Random.id();\n      var coll = new Meteor.Collection(collName);\n      coll._createCappedCollection(1000000);\n      self.xs = [];\n      self.expects = [];\n      self.insert = function (fields) {\n        coll.insert(_.extend({ts: new MongoInternals.MongoTimestamp(0, 0)},\n                             fields));\n      };\n\n      // Tailable observe shouldn't show things that are in the initial\n      // contents.\n      self.insert({x: 1});\n      // Wait for one added call before going to the next test function.\n      self.expects.push(expect());\n\n      var cursor = coll.find({y: {$ne: 7}}, {tailable: true});\n      self.handle = cursor.observeChanges({\n        added: function (id, fields) {\n          self.xs.push(fields.x);\n          test.notEqual(self.expects.length, 0);\n          self.expects.pop()();\n        },\n        changed: function () {\n          test.fail({unexpected: \"changed\"});\n        },\n        removed: function () {\n          test.fail({unexpected: \"removed\"});\n        }\n      });\n\n      // Nothing happens synchronously.\n      test.equal(self.xs, []);\n    },\n    function (test, expect) {\n      var self = this;\n      // The cursors sees the first element.\n      test.equal(self.xs, [1]);\n      self.xs = [];\n\n      self.insert({x: 2, y: 3});\n      self.insert({x: 3, y: 7});  // filtered out by the query\n      self.insert({x: 4});\n      // Expect two added calls to happen.\n      self.expects = [expect(), expect()];\n    },\n    function (test, expect) {\n      var self = this;\n      test.equal(self.xs, [2, 4]);\n      self.xs = [];\n      self.handle.stop();\n\n      self.insert({x: 5});\n      // XXX This timeout isn't perfect but it's pretty hard to prove that an\n      // event WON'T happen without something like a write fence.\n      Meteor.setTimeout(expect(), 1000);\n    },\n    function (test, expect) {\n      var self = this;\n      test.equal(self.xs, []);\n    }\n  ]);\n}\n","var OplogCollection = new Meteor.Collection(\"oplog-\" + Random.id());\n\nTinytest.add(\"mongo-livedata - oplog - cursorSupported\", function (test) {\n  var supported = function (expected, selector) {\n    var cursor = OplogCollection.find(selector);\n    test.equal(\n      MongoTest.OplogObserveDriver.cursorSupported(cursor._cursorDescription),\n      expected);\n  };\n\n  supported(true, \"asdf\");\n  supported(true, 1234);\n  supported(true, new Meteor.Collection.ObjectID());\n\n  supported(true, {_id: \"asdf\"});\n  supported(true, {_id: 1234});\n  supported(true, {_id: new Meteor.Collection.ObjectID()});\n\n  supported(true, {foo: \"asdf\",\n                   bar: 1234,\n                   baz: new Meteor.Collection.ObjectID(),\n                   eeney: true,\n                   miney: false,\n                   moe: null});\n\n  supported(true, {});\n\n  supported(false, {$and: [{foo: \"asdf\"}, {bar: \"baz\"}]});\n  supported(false, {foo: {x: 1}});\n  supported(false, {foo: {$gt: 1}});\n  supported(false, {foo: [1, 2, 3]});\n});\n","var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\ntestAsyncMulti(\"mongo-livedata - doc fetcher\", [\n  function (test, expect) {\n    var self = this;\n    var collName = \"docfetcher-\" + Random.id();\n    var collection = new Meteor.Collection(collName);\n    var id1 = collection.insert({x: 1});\n    var id2 = collection.insert({y: 2});\n\n    var fetcher = new MongoTest.DocFetcher(\n      MongoInternals.defaultRemoteCollectionDriver().mongo);\n\n    // Test basic operation.\n    fetcher.fetch(collName, id1, Random.id(), expect(null, {_id: id1, x: 1}));\n    fetcher.fetch(collName, \"nonexistent!\", Random.id(), expect(null, null));\n\n    var fetched = false;\n    var cacheKey = Random.id();\n    var expected = {_id: id2, y: 2};\n    fetcher.fetch(collName, id2, cacheKey, expect(function (e, d) {\n      fetched = true;\n      test.isFalse(e);\n      test.equal(d, expected);\n    }));\n    // The fetcher yields.\n    test.isFalse(fetched);\n\n    // Now ask for another document with the same cache key. Because a fetch for\n    // that cache key is in flight, we will get the other fetch's document, not\n    // this random document.\n    fetcher.fetch(collName, Random.id(), cacheKey, expect(function (e, d) {\n      test.isFalse(e);\n      test.equal(d, expected);\n    }));\n  }\n]);\n"]}