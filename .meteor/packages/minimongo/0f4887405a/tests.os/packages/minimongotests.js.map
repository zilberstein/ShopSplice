{"version":3,"file":"/packages/minimongo:tests.js","sources":["minimongo/minimongo_server_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,uE;AACA,iD;AACA,6E;AACA,G;;AAEA,qB;AACA,U;AACA,a;AACA,a;AACA,K;AACA,yB;;AAEA,qB;AACA,Y;AACA,W;AACA,gC;;AAEA,qB;AACA,yB;AACA,e;AACA,gC;;AAEA,qB;AACA,kB;AACA,2B;AACA,6D;AACA,+D;;AAEA,qB;AACA,iD;AACA,gE;AACA,8D;;AAEA,mE;AACA,0D;AACA,8E;AACA,8E;AACA,+E;AACA,gF;AACA,e;AACA,qB;AACA,Q;AACA,a;AACA,Y;AACA,M;AACA,Y;AACA,wB;AACA,kD;AACA,K;AACA,qC;;AAEA,iE;AACA,Y;AACA,iF;AACA,Q;AACA,kF;AACA,G;;AAEA,qC;AACA,sD;AACA,G;AACA,wC;AACA,sD;AACA,G;;AAEA,4D;AACA,yD;AACA,+D;AACA,wE;AACA,mE;AACA,uE;;AAEA,+E;AACA,iF;AACA,mF;;AAEA,0G;AACA,qG;;AAEA,6F;;AAEA,uH;AACA,qH;AACA,oH;AACA,kH;;AAEA,6H;AACA,G;;AAEA,iF;AACA,8D;AACA,yF;AACA,G;;AAEA,mC;AACA,uH;AACA,sK;AACA,yB;AACA,sB;AACA,c;AACA,a;AACA,M;AACA,W;AACA,U;AACA,M;AACA,gB;AACA,c;AACA,gB;AACA,c;AACA,a;AACA,0C;;AAEA,yB;AACA,c;AACA,2C;AACA,M;AACA,iB;AACA,iB;AACA,e;AACA,M;AACA,c;AACA,Y;AACA,W;AACA,wC;;AAEA,yB;AACA,iB;AACA,iB;AACA,iB;AACA,gB;AACA,M;AACA,e;AACA,iB;AACA,c;AACA,M;AACA,kB;AACA,kB;AACA,kB;AACA,gB;AACA,gB;AACA,iB;AACA,mC;;AAEA,yB;AACA,mB;AACA,oB;AACA,kB;AACA,M;AACA,Y;AACA,M;AACA,gB;AACA,oB;AACA,qC;;AAEA,yB;AACA,e;AACA,oB;AACA,M;AACA,iB;AACA,Y;AACA,M;AACA,gB;AACA,e;AACA,qC;;AAEA,yB;AACA,c;AACA,M;AACA,c;AACA,M;AACA,iB;AACA,0B;;AAEA,yB;AACA,gB;AACA,e;AACA,M;AACA,Y;AACA,M;AACA,gB;AACA,gB;AACA,a;AACA,yC;;AAEA,yB;AACA,gB;AACA,wC;AACA,M;AACA,a;AACA,Y;AACA,0C;;AAEA,yB;AACA,U;AACA,oB;AACA,6C;AACA,K;AACA,M;AACA,a;AACA,Y;AACA,0C;;AAEA,mC;AACA,uG;AACA,6I;AACA,yB;AACA,sB;AACA,c;AACA,a;AACA,M;AACA,W;AACA,U;AACA,M;AACA,a;AACA,Y;AACA,0C;;AAEA,yB;AACA,c;AACA,2C;AACA,M;AACA,iB;AACA,iB;AACA,e;AACA,M;AACA,wC;;AAEA,yB;AACA,iB;AACA,iB;AACA,iB;AACA,gB;AACA,M;AACA,e;AACA,iB;AACA,c;AACA,M;AACA,mB;AACA,kB;AACA,mC;;AAEA,yB;AACA,mB;AACA,oB;AACA,kB;AACA,M;AACA,Y;AACA,M;AACA,qC;;AAEA,yB;AACA,e;AACA,oB;AACA,M;AACA,iB;AACA,Y;AACA,M;AACA,qC;;AAEA,yB;AACA,c;AACA,M;AACA,c;AACA,M;AACA,0B;;AAEA,yB;AACA,e;AACA,iB;AACA,c;AACA,M;AACA,a;AACA,e;AACA,a;AACA,M;AACA,mB;AACA,iB;AACA,2C;;AAEA,yB;AACA,e;AACA,M;AACA,c;AACA,M;AACA,kB;AACA,kC;;AAEA,yB;AACA,qB;AACA,mC;AACA,M;AACA,mB;AACA,gB;AACA,M;AACA,kC;;AAEA,yB;AACA,gB;AACA,e;AACA,M;AACA,a;AACA,Y;AACA,M;AACA,iB;AACA,yC;;AAEA,yB;AACA,gB;AACA,wC;AACA,M;AACA,a;AACA,Y;AACA,0C;;AAEA,yB;AACA,U;AACA,oB;AACA,6C;AACA,K;AACA,M;AACA,a;AACA,Y;AACA,0C;;AAEA,G;;AAEA,c;AACA,2E;AACA,gF;AACA,2E;AACA,0D;AACA,+E;AACA,2B;AACA,4E;AACA,iB;AACA,2E;AACA,2B;;AAEA,oE;AACA,2B;AACA,4B;AACA,+B;AACA,kF;AACA,G;AACA,+B;AACA,mF;AACA,G;;AAEA,+G;AACA,a;;AAEA,oB;AACA,iB;AACA,kB;AACA,mB;AACA,Q;AACA,2D;AACA,yB;AACA,M;;AAEA,uC;AACA,qC;AACA,uC;AACA,yC;AACA,4C;AACA,sC;AACA,kD;AACA,yC;AACA,0C;;AAEA,uC;AACA,2C;AACA,6C;AACA,+C;AACA,2C;AACA,0C;AACA,yC;AACA,uD;AACA,kD;AACA,6C;;AAEA,8C;AACA,wC;AACA,gD;AACA,qD;AACA,+C;AACA,K;;AAEA,0G;AACA,a;AACA,gD;AACA,oD;AACA,wD;AACA,uD;AACA,gD;;AAEA,gH;AACA,mH;AACA,+G;AACA,kG;AACA,sG;AACA,K;;AAEA,2F;AACA,a;;AAEA,a;AACA,mF;AACA,oF;AACA,gG;AACA,oF;AACA,uG;AACA,kF;AACA,K;;AAEA,kG;AACA,a;AACA,wB;AACA,qF;AACA,+F;AACA,+F;AACA,yG;AACA,gG;AACA,2G;AACA,yE;AACA,+E;AACA,qE;AACA,2E;;AAEA,K;;AAEA,wG;AACA,a;AACA,iF;AACA,sD;AACA,sI;AACA,8G;AACA,kF;AACA,yC;AACA,+F;AACA,+G;AACA,+H;AACA,8E;AACA,kE;AACA,2E;AACA,K;;AAEA,mI;AACA,a;AACA,gG;AACA,yG;AACA,gH;AACA,wG;AACA,K;;AAEA,K","sourcesContent":["Tinytest.add(\"minimongo - modifier affects selector\", function (test) {\n  function testSelectorPaths (sel, paths, desc) {\n    test.isTrue(_.isEqual(MinimongoTest.getSelectorPaths(sel), paths), desc);\n  }\n\n  testSelectorPaths({\n    foo: {\n      bar: 3,\n      baz: 42\n    }\n  }, ['foo'], \"literal\");\n\n  testSelectorPaths({\n    foo: 42,\n    bar: 33\n  }, ['foo', 'bar'], \"literal\");\n\n  testSelectorPaths({\n    foo: [ 'something' ],\n    bar: \"asdf\"\n  }, ['foo', 'bar'], \"literal\");\n\n  testSelectorPaths({\n    a: { $lt: 3 },\n    b: \"you know, literal\",\n    'path.is.complicated': { $not: { $regex: 'acme.*corp' } }\n  }, ['a', 'b', 'path.is.complicated'], \"literal + operators\");\n\n  testSelectorPaths({\n    $or: [{ 'a.b': 1 }, { 'a.b.c': { $lt: 22 } },\n     {$and: [{ 'x.d': { $ne: 5, $gte: 433 } }, { 'a.b': 234 }]}]\n  }, ['a.b', 'a.b.c', 'x.d'], 'group operators + duplicates');\n\n  // When top-level value is an object, it is treated as a literal,\n  // so when you query col.find({ a: { foo: 1, bar: 2 } })\n  // it doesn't mean you are looking for anything that has 'a.foo' to be 1 and\n  // 'a.bar' to be 2, instead you are looking for 'a' to be exatly that object\n  // with exatly that order of keys. { a: { foo: 1, bar: 2, baz: 3 } } wouldn't\n  // match it. That's why in this selector 'a' would be important key, not a.foo\n  // and a.bar.\n  testSelectorPaths({\n    a: {\n      foo: 1,\n      bar: 2\n    },\n    'b.c': {\n      literal: \"object\",\n      but: \"we still observe any changes in 'b.c'\"\n    }\n  }, ['a', 'b.c'], \"literal object\");\n\n  function testSelectorAffectedByModifier (sel, mod, yes, desc) {\n    if (yes)\n      test.isTrue(LocalCollection._isSelectorAffectedByModifier(sel, mod, desc));\n    else\n      test.isFalse(LocalCollection._isSelectorAffectedByModifier(sel, mod, desc));\n  }\n\n  function affected(sel, mod, desc) {\n    testSelectorAffectedByModifier(sel, mod, 1, desc);\n  }\n  function notAffected(sel, mod, desc) {\n    testSelectorAffectedByModifier(sel, mod, 0, desc);\n  }\n\n  notAffected({ foo: 0 }, { $set: { bar: 1 } }, \"simplest\");\n  affected({ foo: 0 }, { $set: { foo: 1 } }, \"simplest\");\n  affected({ foo: 0 }, { $set: { 'foo.bar': 1 } }, \"simplest\");\n  notAffected({ 'foo.bar': 0 }, { $set: { 'foo.baz': 1 } }, \"simplest\");\n  affected({ 'foo.bar': 0 }, { $set: { 'foo.1': 1 } }, \"simplest\");\n  affected({ 'foo.bar': 0 }, { $set: { 'foo.2.bar': 1 } }, \"simplest\");\n\n  notAffected({ 'foo': 0 }, { $set: { 'foobaz': 1 } }, \"correct prefix check\");\n  notAffected({ 'foobar': 0 }, { $unset: { 'foo': 1 } }, \"correct prefix check\");\n  notAffected({ 'foo.bar': 0 }, { $unset: { 'foob': 1 } }, \"correct prefix check\");\n\n  notAffected({ 'foo.Infinity.x': 0 }, { $unset: { 'foo.x': 1 } }, \"we convert integer fields correctly\");\n  notAffected({ 'foo.1e3.x': 0 }, { $unset: { 'foo.x': 1 } }, \"we convert integer fields correctly\");\n\n  affected({ 'foo.3.bar': 0 }, { $set: { 'foo.3.bar': 1 } }, \"observe for an array element\");\n\n  notAffected({ 'foo.4.bar.baz': 0 }, { $unset: { 'foo.3.bar': 1 } }, \"delicate work with numeric fields in selector\");\n  notAffected({ 'foo.4.bar.baz': 0 }, { $unset: { 'foo.bar': 1 } }, \"delicate work with numeric fields in selector\");\n  affected({ 'foo.4.bar.baz': 0 }, { $unset: { 'foo.4.bar': 1 } }, \"delicate work with numeric fields in selector\");\n  affected({ 'foo.bar.baz': 0 }, { $unset: { 'foo.3.bar': 1 } }, \"delicate work with numeric fields in selector\");\n\n  affected({ 'foo.0.bar': 0 }, { $set: { 'foo.0.0.bar': 1 } }, \"delicate work with nested arrays and selectors by indecies\");\n});\n\nTinytest.add(\"minimongo - selector and projection combination\", function (test) {\n  function testSelProjectionComb (sel, proj, expected, desc) {\n    test.equal(LocalCollection._combineSelectorAndProjection(sel, proj), expected, desc);\n  }\n\n  // Test with inclusive projection\n  testSelProjectionComb({ a: 1, b: 2 }, { b: 1, c: 1, d: 1 }, { a: true, b: true, c: true, d: true }, \"simplest incl\");\n  testSelProjectionComb({ $or: [{ a: 1234, e: {$lt: 5} }], b: 2 }, { b: 1, c: 1, d: 1 }, { a: true, b: true, c: true, d: true, e: true }, \"simplest incl, branching\");\n  testSelProjectionComb({\n    'a.b': { $lt: 3 },\n    'y.0': -1,\n    'a.c': 15\n  }, {\n    'd': 1,\n    'z': 1\n  }, {\n    'a.b': true,\n    'y': true,\n    'a.c': true,\n    'd': true,\n    'z': true\n  }, \"multikey paths in selector - incl\");\n\n  testSelProjectionComb({\n    foo: 1234,\n    $and: [{ k: -1 }, { $or: [{ b: 15 }] }]\n  }, {\n    'foo.bar': 1,\n    'foo.zzz': 1,\n    'b.asdf': 1\n  }, {\n    foo: true,\n    b: true,\n    k: true\n  }, \"multikey paths in fields - incl\");\n\n  testSelProjectionComb({\n    'a.b.c': 123,\n    'a.b.d': 321,\n    'b.c.0': 111,\n    'a.e': 12345\n  }, {\n    'a.b.z': 1,\n    'a.b.d.g': 1,\n    'c.c.c': 1\n  }, {\n    'a.b.c': true,\n    'a.b.d': true,\n    'a.b.z': true,\n    'b.c': true,\n    'a.e': true,\n    'c.c.c': true\n  }, \"multikey both paths - incl\");\n\n  testSelProjectionComb({\n    'a.b.c.d': 123,\n    'a.b1.c.d': 421,\n    'a.b.c.e': 111\n  }, {\n    'a.b': 1\n  }, {\n    'a.b': true,\n    'a.b1.c.d': true\n  }, \"shadowing one another - incl\");\n\n  testSelProjectionComb({\n    'a.b': 123,\n    'foo.bar': false\n  }, {\n    'a.b.c.d': 1,\n    'foo': 1\n  }, {\n    'a.b': true,\n    'foo': true\n  }, \"shadowing one another - incl\");\n\n  testSelProjectionComb({\n    'a.b.c': 1\n  }, {\n    'a.b.c': 1\n  }, {\n    'a.b.c': true\n  }, \"same paths - incl\");\n\n  testSelProjectionComb({\n    'x.4.y': 42,\n    'z.0.1': 33\n  }, {\n    'x.x': 1\n  }, {\n    'x.x': true,\n    'x.y': true,\n    'z': true\n  }, \"numbered keys in selector - incl\");\n\n  testSelProjectionComb({\n    'a.b.c': 42,\n    $where: function () { return true; }\n  }, {\n    'a.b': 1,\n    'z.z': 1\n  }, {}, \"$where in the selector - incl\");\n\n  testSelProjectionComb({\n    $or: [\n      {'a.b.c': 42},\n      {$where: function () { return true; } }\n    ]\n  }, {\n    'a.b': 1,\n    'z.z': 1\n  }, {}, \"$where in the selector - incl\");\n\n  // Test with exclusive projection\n  testSelProjectionComb({ a: 1, b: 2 }, { b: 0, c: 0, d: 0 }, { c: false, d: false }, \"simplest excl\");\n  testSelProjectionComb({ $or: [{ a: 1234, e: {$lt: 5} }], b: 2 }, { b: 0, c: 0, d: 0 }, { c: false, d: false }, \"simplest excl, branching\");\n  testSelProjectionComb({\n    'a.b': { $lt: 3 },\n    'y.0': -1,\n    'a.c': 15\n  }, {\n    'd': 0,\n    'z': 0\n  }, {\n    d: false,\n    z: false\n  }, \"multikey paths in selector - excl\");\n\n  testSelProjectionComb({\n    foo: 1234,\n    $and: [{ k: -1 }, { $or: [{ b: 15 }] }]\n  }, {\n    'foo.bar': 0,\n    'foo.zzz': 0,\n    'b.asdf': 0\n  }, {\n  }, \"multikey paths in fields - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 123,\n    'a.b.d': 321,\n    'b.c.0': 111,\n    'a.e': 12345\n  }, {\n    'a.b.z': 0,\n    'a.b.d.g': 0,\n    'c.c.c': 0\n  }, {\n    'a.b.z': false,\n    'c.c.c': false\n  }, \"multikey both paths - excl\");\n\n  testSelProjectionComb({\n    'a.b.c.d': 123,\n    'a.b1.c.d': 421,\n    'a.b.c.e': 111\n  }, {\n    'a.b': 0\n  }, {\n  }, \"shadowing one another - excl\");\n\n  testSelProjectionComb({\n    'a.b': 123,\n    'foo.bar': false\n  }, {\n    'a.b.c.d': 0,\n    'foo': 0\n  }, {\n  }, \"shadowing one another - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 1\n  }, {\n    'a.b.c': 0\n  }, {\n  }, \"same paths - excl\");\n\n  testSelProjectionComb({\n    'a.b': 123,\n    'a.c.d': 222,\n    'ddd': 123\n  }, {\n    'a.b': 0,\n    'a.c.e': 0,\n    'asdf': 0\n  }, {\n    'a.c.e': false,\n    'asdf': false\n  }, \"intercept the selector path - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 14\n  }, {\n    'a.b.d': 0\n  }, {\n    'a.b.d': false\n  }, \"different branches - excl\");\n\n  testSelProjectionComb({\n    'a.b.c.d': \"124\",\n    'foo.bar.baz.que': \"some value\"\n  }, {\n    'a.b.c.d.e': 0,\n    'foo.bar': 0\n  }, {\n  }, \"excl on incl paths - excl\");\n\n  testSelProjectionComb({\n    'x.4.y': 42,\n    'z.0.1': 33\n  }, {\n    'x.x': 0,\n    'x.y': 0\n  }, {\n    'x.x': false,\n  }, \"numbered keys in selector - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 42,\n    $where: function () { return true; }\n  }, {\n    'a.b': 0,\n    'z.z': 0\n  }, {}, \"$where in the selector - excl\");\n\n  testSelProjectionComb({\n    $or: [\n      {'a.b.c': 42},\n      {$where: function () { return true; } }\n    ]\n  }, {\n    'a.b': 0,\n    'z.z': 0\n  }, {}, \"$where in the selector - excl\");\n\n});\n\n(function () {\n  // TODO: Tests for \"can selector become true by modifier\" are incomplete,\n  // absent or test the functionality of \"not ideal\" implementation (test checks\n  // that certain case always returns true as implementation is incomplete)\n  // - tests with $and/$or/$nor/$not branches (are absent)\n  // - more tests with arrays fields and numeric keys (incomplete and test \"not\n  // ideal\" implementation)\n  // - tests when numeric keys actually mean numeric keys, not array indexes\n  // (are absent)\n  // - tests with $-operators in the selector (are incomplete and test \"not\n  // ideal\" implementation)\n\n  var test = null; // set this global in the beginning of every test\n  // T - should return true\n  // F - should return false\n  function T (sel, mod, desc) {\n    test.isTrue(LocalCollection._canSelectorBecomeTrueByModifier(sel, mod), desc);\n  }\n  function F (sel, mod, desc) {\n    test.isFalse(LocalCollection._canSelectorBecomeTrueByModifier(sel, mod), desc);\n  }\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals (structured tests)\", function (t) {\n    test = t;\n\n    var selector = {\n      'a.b.c': 2,\n      'foo.bar': {\n        z: { y: 1 }\n      },\n      'foo.baz': [ {ans: 42}, \"string\", false, undefined ],\n      'empty.field': null\n    };\n\n    T(selector, {$set:{ 'a.b.c': 2 }});\n    F(selector, {$unset:{ 'a': 1 }});\n    F(selector, {$unset:{ 'a.b': 1 }});\n    F(selector, {$unset:{ 'a.b.c': 1 }});\n    T(selector, {$set:{ 'a.b': { c: 2 } }});\n    F(selector, {$set:{ 'a.b': {} }});\n    T(selector, {$set:{ 'a.b': { c: 2, x: 5 } }});\n    F(selector, {$set:{ 'a.b.c.k': 3 }});\n    F(selector, {$set:{ 'a.b.c.k': {} }});\n\n    F(selector, {$unset:{ 'foo': 1 }});\n    F(selector, {$unset:{ 'foo.bar': 1 }});\n    F(selector, {$unset:{ 'foo.bar.z': 1 }});\n    F(selector, {$unset:{ 'foo.bar.z.y': 1 }});\n    F(selector, {$set:{ 'foo.bar.x': 1 }});\n    F(selector, {$set:{ 'foo.bar': {} }});\n    F(selector, {$set:{ 'foo.bar': 3 }});\n    T(selector, {$set:{ 'foo.bar': { z: { y: 1 } } }});\n    T(selector, {$set:{ 'foo.bar.z': { y: 1 } }});\n    T(selector, {$set:{ 'foo.bar.z.y': 1 }});\n\n    F(selector, {$set:{ 'empty.field': {} }});\n    T(selector, {$set:{ 'empty': {} }});\n    T(selector, {$set:{ 'empty.field': null }});\n    T(selector, {$set:{ 'empty.field': undefined }});\n    F(selector, {$set:{ 'empty.field.a': 3 }});\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals (adhoc tests)\", function (t) {\n    test = t;\n    T({x:1}, {$set:{x:1}}, \"simple set scalar\");\n    T({x:\"a\"}, {$set:{x:\"a\"}}, \"simple set scalar\");\n    T({x:false}, {$set:{x:false}}, \"simple set scalar\");\n    F({x:true}, {$set:{x:false}}, \"simple set scalar\");\n    F({x:2}, {$set:{x:3}}, \"simple set scalar\");\n\n    F({'foo.bar.baz': 1, x:1}, {$unset:{'foo.bar.baz': 1}, $set:{x:1}}, \"simple unset of the interesting path\");\n    F({'foo.bar.baz': 1, x:1}, {$unset:{'foo.bar': 1}, $set:{x:1}}, \"simple unset of the interesting path prefix\");\n    F({'foo.bar.baz': 1, x:1}, {$unset:{'foo': 1}, $set:{x:1}}, \"simple unset of the interesting path prefix\");\n    F({'foo.bar.baz': 1}, {$unset:{'foo.baz': 1}}, \"simple unset of the interesting path prefix\");\n    F({'foo.bar.baz': 1}, {$unset:{'foo.bar.bar': 1}}, \"simple unset of the interesting path prefix\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - regexps\", function (t) {\n    test = t;\n\n    // Regexp\n    T({ 'foo.bar': /^[0-9]+$/i }, { $set: {'foo.bar': '01233'} }, \"set of regexp\");\n    // XXX this test should be False, should be fixed within improved implementation\n    T({ 'foo.bar': /^[0-9]+$/i, x: 1 }, { $set: {'foo.bar': '0a1233', x: 1} }, \"set of regexp\");\n    // XXX this test should be False, should be fixed within improved implementation\n    T({ 'foo.bar': /^[0-9]+$/i, x: 1 }, { $unset: {'foo.bar': 1}, $set: { x: 1 } }, \"unset of regexp\");\n    T({ 'foo.bar': /^[0-9]+$/i, x: 1 }, { $set: { x: 1 } }, \"don't touch regexp\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - undefined/null\", function (t) {\n    test = t;\n    // Nulls / Undefined\n    T({ 'foo.bar': null }, {$set:{'foo.bar': null}}, \"set of null looking for null\");\n    T({ 'foo.bar': null }, {$set:{'foo.bar': undefined}}, \"set of undefined looking for null\");\n    T({ 'foo.bar': undefined }, {$set:{'foo.bar': null}}, \"set of null looking for undefined\");\n    T({ 'foo.bar': undefined }, {$set:{'foo.bar': undefined}}, \"set of undefined looking for undefined\");\n    T({ 'foo.bar': null }, {$set:{'foo': null}}, \"set of null of parent path looking for null\");\n    F({ 'foo.bar': null }, {$set:{'foo.bar.baz': null}}, \"set of null of different path looking for null\");\n    T({ 'foo.bar': null }, { $unset: { 'foo': 1 } }, \"unset the parent\");\n    T({ 'foo.bar': null }, { $unset: { 'foo.bar': 1 } }, \"unset tracked path\");\n    T({ 'foo.bar': null }, { $set: { 'foo': 3 } }, \"set the parent\");\n    T({ 'foo.bar': null }, { $set: { 'foo': {baz:1} } }, \"set the parent\");\n\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals with arrays\", function (t) {\n    test = t;\n    // These tests are incomplete and in theory they all should return true as we\n    // don't support any case with numeric fields yet.\n    T({'a.1.b': 1, x:1}, {$unset:{'a.1.b': 1}, $set:{x:1}}, \"unset of array element's field with exactly the same index as selector\");\n    F({'a.2.b': 1}, {$unset:{'a.1.b': 1}}, \"unset of array element's field with different index as selector\");\n    // This is false, because if you are looking for array but in reality it is an\n    // object, it just can't get to true.\n    F({'a.2.b': 1}, {$unset:{'a.b': 1}}, \"unset of field while selector is looking for index\");\n    T({ 'foo.bar': null }, {$set:{'foo.1.bar': null}}, \"set array's element's field to null looking for null\");\n    T({ 'foo.bar': null }, {$set:{'foo.0.bar': 1, 'foo.1.bar': null}}, \"set array's element's field to null looking for null\");\n    // This is false, because there may remain other array elements that match\n    // but we modified this test as we don't support this case yet\n    T({'a.b': 1}, {$unset:{'a.1.b': 1}}, \"unset of array element's field\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - set an object literal whose fields are selected\", function (t) {\n    test = t;\n    T({ 'a.b.c': 1 }, { $set: { 'a.b': { c: 1 } } }, \"a simple scalar selector and simple set\");\n    F({ 'a.b.c': 1 }, { $set: { 'a.b': { c: 2 } } }, \"a simple scalar selector and simple set to false\");\n    F({ 'a.b.c': 1 }, { $set: { 'a.b': { d: 1 } } }, \"a simple scalar selector and simple set a wrong literal\");\n    F({ 'a.b.c': 1 }, { $set: { 'a.b': 222 } }, \"a simple scalar selector and simple set a wrong type\");\n  });\n\n})();\n\n"]}