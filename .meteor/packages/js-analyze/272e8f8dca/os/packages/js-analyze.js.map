{"version":3,"file":"/packages/js-analyze.js","sources":["js-analyze/js_analyze.js"],"names":[],"mappings":";;;;;;;;AAAA,qC;AACA,mC;;AAEA,e;;AAEA,8E;AACA,sC;AACA,O;AACA,iC;AACA,e;AACA,4C;AACA,8C;AACA,2B;AACA,K;AACA,Y;AACA,G;AACA,E;;AAEA,6E;AACA,6E;AACA,kB;AACA,E;AACA,0E;AACA,4E;AACA,2B;AACA,E;AACA,+E;AACA,+E;AACA,mD;AACA,8E;AACA,iE;AACA,8C;;AAEA,uC;AACA,+E;AACA,2E;AACA,wD;AACA,I;AACA,yB;AACA,oB;AACA,2B;AACA,6B;AACA,2B;AACA,U;AACA,Q;AACA,I;AACA,4E;AACA,Y;AACA,6D;AACA,qC;;AAEA,2B;AACA,iD;AACA,8D;AACA,0C;AACA,K;;AAEA,yB;AACA,E","sourcesContent":["var esprima = Npm.require('esprima');\nvar escope = Npm.require('escope');\n\nJSAnalyze = {};\n\n// Like esprima.parse, but annotates any thrown error with $ParseError = true.\nvar esprimaParse = function (source) {\n  try {\n    return esprima.parse(source);\n  } catch (e) {\n    if ('index' in e && 'lineNumber' in e &&\n        'column' in e && 'description' in e) {\n      e.$ParseError = true;\n    }\n    throw e;\n  }\n};\n\n// Analyze the JavaScript source code `source` and return a dictionary of all\n// globals which are assigned to in the package. The values in the dictionary\n// are all `true`.\n//\n// This is intended for use in detecting package-scope variables in Meteor\n// packages, where the linker needs to add a \"var\" statement to prevent them\n// from staying as globals.\n//\n// It only cares about assignments to variables; an assignment to a field on an\n// object (`Foo.Bar = true`) neither causes `Foo` nor `Foo.Bar` to be returned.\nJSAnalyze.findAssignedGlobals = function (source) {\n  // escope's analyzer treats vars in the top-level \"Program\" node as globals.\n  // The newline is necessary in case source ends with a comment.\n  source = '(function () {' + source + '\\n})';\n\n  var parseTree = esprimaParse(source);\n  // We have to pass ignoreEval; otherwise, the existence of a direct eval call\n  // causes escope to not bother to resolve references in the eval's scope.\n  // This is because an eval can pull references inward:\n  //\n  //   function outer() {\n  //     var i = 42;\n  //     function inner() {\n  //       eval('var i = 0');\n  //       i;  // 0, not 42\n  //     }\n  //   }\n  //\n  // But it can't pull references outward, so for our purposes it is safe to\n  // ignore.\n  var scoper = escope.analyze(parseTree, {ignoreEval: true});\n  var globalScope = scoper.scopes[0];\n\n  var assignedGlobals = {};\n  // Underscore is not available in this package.\n  globalScope.implicit.variables.forEach(function (variable) {\n    assignedGlobals[variable.name] = true;\n  });\n\n  return assignedGlobals;\n};\n"]}