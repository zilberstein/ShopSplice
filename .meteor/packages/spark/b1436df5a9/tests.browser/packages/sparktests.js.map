{"version":3,"file":"/packages/spark:tests.js","sources":["spark/spark_tests.js","spark/patch_tests.js"],"names":[],"mappings":";;;;;;;;AAAA,qF;AACA,yE;AACA,mD;AACA,gF;;;AAGA,qC;;AAEA,mE;AACA,wE;AACA,yE;AACA,oC;;AAEA,oB;AACA,4C;AACA,E;;AAEA,kD;AACA,oC;AACA,qE;AACA,K;AACA,E;;AAEA,oC;AACA,wC;AACA,uB;AACA,qE;AACA,8C;AACA,uB;AACA,G;AACA,kB;AACA,qC;AACA,kC;AACA,mC;AACA,4B;AACA,4D;AACA,qC;AACA,M;AACA,K;AACA,gB;AACA,E;;AAEA,qC;AACA,wE;AACA,sD;AACA,kC;AACA,E;;AAEA,kD;;AAEA,oC;AACA,2D;AACA,yD;AACA,0D;AACA,uB;AACA,O;AACA,I;;AAEA,gC;AACA,yC;AACA,4C;AACA,+C;AACA,S;AACA,O;AACA,oB;AACA,uD;AACA,+B;AACA,uB;AACA,oB;AACA,yB;AACA,iB;AACA,O;AACA,8B;AACA,6C;;AAEA,0B;AACA,uD;AACA,6C;AACA,wE;AACA,wD;AACA,mE;AACA,O;AACA,yD;AACA,I;;AAEA,kD;AACA,kE;AACA,6D;AACA,gE;AACA,2D;AACA,S;AACA,sF;AACA,+B;AACA,uB;AACA,gD;AACA,yC;AACA,6C;AACA,oE;;AAEA,uB;AACA,8E;AACA,mE;AACA,K;;AAEA,2B;AACA,yB;AACA,yB;AACA,iB;AACA,O;AACA,K;;AAEA,uC;AACA,4B;AACA,yC;AACA,yB;AACA,K;AACA,4B;AACA,kC;AACA,0C;AACA,6D;AACA,2D;AACA,G;;;AAGA,yD;AACA,0B;AACA,wC;AACA,8C;AACA,mB;AACA,O;AACA,K;AACA,G;;;AAGA,8D;;AAEA,oC;;AAEA,kC;AACA,4B;AACA,iB;AACA,e;AACA,kC;AACA,gC;AACA,qD;AACA,O;AACA,M;;AAEA,kB;;AAEA,e;AACA,I;;AAEA,a;;AAEA,uB;;AAEA,2B;AACA,qC;AACA,6B;AACA,qB;AACA,O;AACA,iC;AACA,iB;AACA,uD;AACA,K;;AAEA,wB;;AAEA,2B;AACA,6C;AACA,6B;AACA,4D;AACA,O;;AAEA,kE;AACA,wC;AACA,iB;AACA,uE;AACA,K;;AAEA,wB;;AAEA,2B;AACA,6C;AACA,6B;AACA,2E;AACA,O;;AAEA,kE;AACA,wC;AACA,iB;AACA,uE;AACA,K;;AAEA,qB;;AAEA,2B;AACA,oC;AACA,6B;AACA,qE;AACA,O;;AAEA,kE;AACA,+B;AACA,iB;AACA,uE;AACA,K;;AAEA,qB;;AAEA,2B;AACA,oC;AACA,6B;AACA,sD;AACA,O;;AAEA,kE;AACA,+B;AACA,iB;AACA,uE;AACA,K;;AAEA,yB;;AAEA,2B;AACA,4C;AACA,6B;AACA,8D;AACA,O;;AAEA,sE;AACA,uC;AACA,iB;AACA,2E;AACA,K;;AAEA,2B;;AAEA,2B;AACA,kC;AACA,4C;AACA,+C;AACA,6B;AACA,mD;AACA,kE;AACA,+E;AACA,Y;AACA,oB;AACA,O;;AAEA,wC;AACA,yD;AACA,M;;AAEA,6C;AACA,qD;AACA,uD;AACA,0D;AACA,4B;AACA,mD;AACA,iB;AACA,6C;AACA,qD;AACA,uD;AACA,0D;AACA,8D;AACA,4B;AACA,yB;AACA,yB;AACA,iB;AACA,6C;AACA,qD;AACA,8D;AACA,4B;AACA,iB;AACA,iB;AACA,6C;AACA,qD;AACA,0B;AACA,4B;AACA,4C;AACA,+C;AACA,iB;AACA,6C;AACA,qD;AACA,uD;AACA,0D;AACA,4B;AACA,K;;AAEA,G;;;AAGA,uD;;AAEA,6B;;AAEA,kD;AACA,gD;AACA,4C;AACA,kB;AACA,M;;AAEA,wD;AACA,e;AACA,wD;AACA,e;AACA,wD;AACA,e;AACA,e;AACA,wD;;AAEA,a;AACA,e;AACA,G;;AAEA,oD;;AAEA,6B;;AAEA,oD;AACA,mB;AACA,a;;AAEA,kC;;AAEA,mC;AACA,iC;AACA,e;AACA,uD;AACA,iC;AACA,e;AACA,uC;AACA,iC;AACA,qD;AACA,e;AACA,e;AACA,e;AACA,+D;AACA,iC;;AAEA,mC;AACA,kC;;AAEA,6D;AACA,gD;AACA,c;AACA,M;AACA,qC;;AAEA,oD;AACA,c;AACA,gD;AACA,6D;AACA,a;AACA,8D;AACA,e;AACA,e;AACA,qC;AACA,c;AACA,e;AACA,8D;AACA,kC;AACA,iB;AACA,e;AACA,kC;;AAEA,6B;AACA,W;AACA,gD;AACA,oB;AACA,kC;AACA,mE;AACA,4C;AACA,K;AACA,2B;AACA,a;AACA,yB;AACA,4E;AACA,W;AACA,e;AACA,yB;AACA,2E;AACA,2E;AACA,4E;AACA,W;AACA,e;AACA,yB;AACA,2E;AACA,4E;AACA,iB;AACA,e;AACA,kC;;AAEA,mC;AACA,8D;AACA,G;;AAEA,4D;;AAEA,2B;;AAEA,mD;AACA,4E;AACA,M;;AAEA,mF;AACA,kC;AACA,e;AACA,gD;AACA,mF;AACA,2D;AACA,e;AACA,mF;AACA,kC;;AAEA,e;AACA,kF;AACA,e;AACA,kC;AACA,G;;AAEA,iD;;AAEA,0B;AACA,0B;;AAEA,0B;AACA,0B;AACA,0B;AACA,yC;;AAEA,oD;AACA,8C;AACA,iC;AACA,kD;AACA,qC;AACA,+C;AACA,a;AACA,S;AACA,a;;AAEA,yC;;AAEA,wB;AACA,yC;;AAEA,wB;AACA,yC;;AAEA,wB;AACA,yC;;AAEA,wB;AACA,yC;;AAEA,wB;AACA,yC;;AAEA,iB;AACA,e;AACA,mC;AACA,mC;AACA,mC;;AAEA,Y;AACA,Y;AACA,Y;;AAEA,gD;AACA,iB;AACA,gD;AACA,wC;AACA,mB;AACA,qC;AACA,4C;AACA,2C;AACA,Y;AACA,O;AACA,0B;AACA,Q;AACA,uB;AACA,wB;AACA,a;;AAEA,6D;AACA,0B;AACA,+C;AACA,sD;AACA,yB;;AAEA,0B;AACA,+C;AACA,sD;AACA,yB;;AAEA,0B;AACA,+C;AACA,sD;AACA,yB;;AAEA,0B;AACA,+C;AACA,8B;AACA,yB;;AAEA,2B;AACA,gD;AACA,8B;AACA,yB;;AAEA,0B;AACA,gD;AACA,0C;AACA,yB;;AAEA,0B;AACA,gD;AACA,0C;AACA,yB;;AAEA,iB;;AAEA,6C;AACA,kE;;AAEA,mC;;AAEA,2B;AACA,+B;AACA,kC;AACA,O;AACA,K;;;AAGA,mB;;AAEA,6B;AACA,6B;AACA,yC;AACA,wB;AACA,+B;AACA,qB;AACA,O;AACA,c;AACA,K;AACA,e;AACA,oD;AACA,qD;AACA,gC;AACA,e;AACA,kC;;AAEA,Y;;AAEA,gC;AACA,mD;AACA,sC;AACA,uE;AACA,oB;AACA,S;AACA,O;AACA,M;AACA,iC;AACA,mB;AACA,e;AACA,gC;AACA,a;AACA,e;;AAEA,iB;;AAEA,gC;AACA,gC;AACA,gC;AACA,6B;AACA,gD;AACA,yB;AACA,O;AACA,I;AACA,Y;;AAEA,mD;AACA,sC;AACA,qC;AACA,mC;AACA,yC;AACA,uC;AACA,iD;AACA,e;AACA,W;AACA,O;AACA,M;AACA,+B;AACA,Y;AACA,e;AACA,+B;AACA,Y;AACA,e;AACA,+B;AACA,Y;AACA,e;AACA,+B;AACA,Y;AACA,e;AACA,+B;AACA,Y;AACA,e;AACA,+B;AACA,e;AACA,e;;AAEA,iD;AACA,yB;AACA,e;AACA,qC;AACA,qC;AACA,qC;AACA,G;;AAEA,sD;AACA,kB;AACA,kB;AACA,kB;AACA,kB;AACA,kB;;AAEA,kC;AACA,iB;AACA,0C;AACA,yE;AACA,iD;AACA,gD;AACA,gD;AACA,S;AACA,8C;AACA,6B;AACA,O;AACA,M;AACA,uB;AACA,e;AACA,I;;AAEA,kD;AACA,6D;AACA,I;;AAEA,6B;AACA,gB;AACA,K;;AAEA,8B;AACA,2B;AACA,K;;AAEA,8B;AACA,+D;AACA,K;;AAEA,8B;AACA,gC;AACA,+D;AACA,K;;AAEA,8B;AACA,gC;AACA,mB;AACA,gC;AACA,8D;AACA,kB;AACA,K;;AAEA,8B;AACA,gC;AACA,mB;AACA,gC;AACA,8D;AACA,kB;AACA,K;;AAEA,8B;AACA,oC;AACA,mB;AACA,gC;AACA,8D;AACA,kB;AACA,0C;AACA,K;;AAEA,+B;AACA,iD;AACA,wC;AACA,K;;AAEA,sC;AACA,oB;AACA,+C;AACA,0D;AACA,qB;AACA,+C;AACA,gC;AACA,wC;AACA,oE;AACA,qC;AACA,K;AACA,G;;AAEA,gD;AACA,yB;;AAEA,qD;AACA,iB;AACA,wB;AACA,gC;AACA,8C;AACA,yB;AACA,wB;AACA,M;;AAEA,W;AACA,e;AACA,gF;;AAEA,Y;AACA,gF;AACA,e;AACA,4C;AACA,qC;AACA,qC;AACA,qC;AACA,qC;AACA,qC;AACA,qC;AACA,qC;AACA,qC;AACA,qC;AACA,sC;AACA,mC;;AAEA,W;AACA,e;AACA,8C;AACA,e;AACA,e;AACA,kC;;AAEA,0B;AACA,0D;AACA,+D;AACA,iB;AACA,gC;AACA,8C;AACA,wB;AACA,M;AACA,mD;AACA,W;AACA,e;AACA,0C;AACA,qC;AACA,qC;AACA,qC;AACA,mC;AACA,mD;AACA,W;AACA,e;AACA,mD;AACA,a;AACA,e;;AAEA,kC;;AAEA,sB;AACA,8E;AACA,W;AACA,qE;AACA,iB;AACA,mB;AACA,kC;AACA,uC;AACA,0B;AACA,Q;AACA,wB;AACA,kE;AACA,wC;AACA,W;AACA,e;AACA,wB;AACA,oE;AACA,a;AACA,e;AACA,kC;;AAEA,uD;AACA,8D;AACA,M;AACA,e;AACA,mC;AACA,e;AACA,a;AACA,e;AACA,mF;AACA,a;AACA,e;;AAEA,kC;AACA,G;;AAEA,wD;AACA,qB;AACA,6B;AACA,uC;AACA,I;;AAEA,U;;AAEA,4C;AACA,uC;AACA,4B;AACA,uB;AACA,sD;AACA,2B;AACA,4D;AACA,gB;AACA,I;;AAEA,6C;AACA,qC;AACA,sC;AACA,O;AACA,I;;;AAGA,mC;AACA,uB;AACA,wC;AACA,uC;AACA,yD;AACA,+B;AACA,mC;AACA,a;AACA,e;;AAEA,4C;AACA,uB;AACA,wC;AACA,uC;AACA,6D;AACA,+B;AACA,uC;AACA,a;AACA,e;;AAEA,gD;AACA,uB;AACA,wC;AACA,oD;AACA,8D;AACA,0C;AACA,wC;AACA,a;AACA,e;;AAEA,0D;AACA,iE;AACA,2B;AACA,uB;AACA,wC;AACA,8B;AACA,2D;AACA,O;AACA,yD;AACA,+B;AACA,mC;AACA,uB;AACA,+D;AACA,e;AACA,mD;AACA,mC;AACA,uB;AACA,a;AACA,e;AACA,+B;AACA,mC;AACA,uB;AACA,a;AACA,e;;AAEA,yD;AACA,gB;AACA,uB;AACA,wC;AACA,4D;AACA,+B;AACA,8D;AACA,e;AACA,qD;AACA,wC;AACA,a;AACA,e;;AAEA,gF;AACA,uB;AACA,wC;AACA,4D;AACA,+B;AACA,yE;AACA,e;AACA,qD;AACA,mD;AACA,a;AACA,e;;AAEA,gD;AACA,uB;AACA,wC;AACA,8B;AACA,gC;AACA,6D;AACA,+D;AACA,6D;AACA,4D;AACA,+B;AACA,8D;AACA,uB;AACA,a;AACA,e;;AAEA,0D;AACA,uB;AACA,uB;AACA,wC;AACA,8B;AACA,gC;AACA,6D;AACA,+D;AACA,6C;AACA,6D;AACA,4D;AACA,+B;AACA,8D;AACA,uB;AACA,a;AACA,e;;AAEA,kC;AACA,uB;AACA,wC;AACA,8B;AACA,gC;AACA,6D;AACA,+D;AACA,6C;AACA,iC;AACA,0C;AACA,4D;AACA,+B;AACA,kD;AACA,uB;AACA,a;AACA,e;;AAEA,4C;AACA,uB;AACA,wB;AACA,wC;AACA,8B;AACA,qF;AACA,6C;AACA,mC;AACA,mB;AACA,oC;AACA,oC;AACA,kC;AACA,S;AACA,M;AACA,kB;AACA,+B;AACA,uD;AACA,qD;AACA,uB;AACA,a;AACA,e;;AAEA,2D;AACA,0D;AACA,8C;AACA,6C;AACA,uB;AACA,yB;AACA,wC;AACA,+B;AACA,yB;AACA,iD;AACA,mE;AACA,8B;AACA,8E;AACA,e;AACA,e;AACA,mB;AACA,4D;AACA,6C;AACA,qE;AACA,uB;AACA,a;AACA,e;;AAEA,wC;AACA,uB;AACA,yB;AACA,wC;AACA,+B;AACA,yB;AACA,iD;AACA,mE;AACA,8B;AACA,6D;AACA,e;AACA,e;AACA,mB;AACA,4D;AACA,a;AACA,c;AACA,4E;AACA,uB;AACA,a;AACA,e;;AAEA,2D;AACA,uB;AACA,yB;AACA,wC;AACA,wC;AACA,gC;AACA,0D;AACA,M;AACA,mC;AACA,2D;AACA,mC;AACA,uB;AACA,e;AACA,e;AACA,mC;AACA,2D;AACA,mC;AACA,uB;AACA,a;AACA,e;;AAEA,0D;AACA,8C;AACA,uB;AACA,wC;AACA,yB;AACA,qD;AACA,e;AACA,wD;AACA,2C;AACA,M;AACA,+B;AACA,kE;AACA,4B;AACA,uB;AACA,e;AACA,+B;AACA,2B;AACA,wC;AACA,uB;AACA,a;AACA,e;;AAEA,gE;AACA,oB;AACA,wC;AACA,qC;AACA,2C;AACA,8C;AACA,iC;AACA,sE;AACA,iC;AACA,wC;AACA,a;AACA,e;AACA,G;;;AAGA,4D;AACA,qB;AACA,U;;AAEA,yE;AACA,uB;AACA,e;AACA,4C;AACA,8B;AACA,Y;AACA,wB;AACA,6B;AACA,O;AACA,M;AACA,I;AACA,8C;AACA,+B;AACA,gE;AACA,M;AACA,oC;AACA,2B;AACA,sC;AACA,+E;AACA,8B;AACA,iD;AACA,8E;AACA,oC;AACA,gB;AACA,M;AACA,e;AACA,iD;AACA,mB;AACA,4B;AACA,8D;AACA,+C;AACA,uE;AACA,yB;AACA,I;AACA,Y;AACA,a;AACA,wB;AACA,sD;AACA,e;AACA,gD;AACA,Y;AACA,qC;AACA,oC;AACA,Y;AACA,e;AACA,iD;AACA,Y;AACA,Y;AACA,a;AACA,e;;AAEA,G;;;AAGA,yD;AACA,6B;AACA,a;AACA,gC;AACA,wB;AACA,W;AACA,I;;AAEA,a;;AAEA,kD;AACA,sC;AACA,sB;AACA,8B;AACA,gC;AACA,wB;AACA,uB;AACA,Y;AACA,iC;AACA,gC;AACA,Y;AACA,kC;AACA,gC;AACA,W;AACA,wC;AACA,O;AACA,M;;AAEA,gB;AACA,e;AACA,mB;AACA,e;AACA,a;AACA,e;AACA,a;AACA,e;AACA,mB;AACA,e;AACA,a;AACA,e;AACA,a;AACA,e;AACA,a;AACA,a;AACA,e;AACA,mB;AACA,G;;AAEA,2D;AACA,a;AACA,8B;AACA,4B;;AAEA,a;AACA,a;AACA,0C;AACA,0B;AACA,0B;AACA,W;AACA,W;AACA,I;;AAEA,4B;AACA,6B;AACA,8C;;AAEA,4C;AACA,iB;AACA,8C;AACA,mC;AACA,gB;;AAEA,yB;AACA,gC;;AAEA,mC;AACA,8B;AACA,0B;AACA,6B;AACA,uB;AACA,U;AACA,+B;AACA,0B;AACA,6B;AACA,kC;AACA,U;AACA,gC;AACA,0B;AACA,6B;AACA,kC;AACA,S;AACA,mB;AACA,M;;AAEA,+B;AACA,wD;AACA,Q;AACA,iB;AACA,I;;AAEA,gC;;AAEA,0B;AACA,sB;AACA,I;;AAEA,oC;AACA,kD;AACA,0C;AACA,c;AACA,gB;AACA,iE;AACA,kC;AACA,2B;AACA,wE;AACA,kC;AACA,2B;AACA,2C;AACA,mI;AACA,iC;AACA,iD;AACA,4C;AACA,gD;AACA,yD;AACA,2C;AACA,sD;AACA,oD;AACA,yE;AACA,wD;AACA,O;AACA,gB;AACA,M;;AAEA,kC;AACA,oE;AACA,e;AACA,oE;AACA,gC;AACA,gB;AACA,mB;AACA,iB;AACA,oD;AACA,2D;AACA,I;;AAEA,gC;AACA,iB;AACA,e;AACA,kD;AACA,+B;;AAEA,iC;AACA,gC;AACA,iB;AACA,e;AACA,0D;AACA,mC;;AAEA,gC;AACA,iC;AACA,iB;AACA,e;AACA,0E;AACA,2C;;AAEA,iC;AACA,iB;AACA,e;AACA,0D;AACA,mC;;AAEA,6B;AACA,iB;AACA,e;AACA,kD;AACA,+B;;AAEA,gC;AACA,oB;AACA,uE;AACA,uB;AACA,uE;AACA,uB;AACA,uE;AACA,+C;AACA,+C;AACA,gD;AACA,iD;AACA,gD;AACA,S;AACA,gB;AACA,mB;AACA,iB;AACA,iC;AACA,I;;AAEA,gC;AACA,e;AACA,oD;;AAEA,iC;AACA,gC;AACA,e;AACA,oD;;AAEA,iC;AACA,e;AACA,iE;;AAEA,a;AACA,e;AACA,G;;;AAGA,mE;AACA,6D;AACA,+D;AACA,oD;;AAEA,8B;AACA,+B;;AAEA,4D;AACA,oF;AACA,4C;AACA,a;AACA,qC;AACA,sE;AACA,oC;AACA,sC;AACA,iD;AACA,qD;;AAEA,gB;AACA,iB;AACA,e;AACA,iD;AACA,qD;;AAEA,iB;AACA,e;AACA,mC;AACA,mC;;AAEA,Q;AACA,yB;AACA,wD;AACA,2F;AACA,a;AACA,6E;AACA,mC;AACA,e;AACA,mC;AACA,c;AACA,mC;AACA,e;AACA,kC;AACA,e;AACA,kC;AACA,e;AACA,mC;AACA,c;AACA,e;AACA,kC;AACA,iB;AACA,wB;AACA,wD;AACA,kF;AACA,a;AACA,kC;AACA,e;AACA,kC;AACA,e;AACA,kC;AACA,e;AACA,mC;AACA,iB;;;AAGA,8C;AACA,6B;AACA,6D;AACA,oE;AACA,Q;AACA,qC;AACA,uB;AACA,mB;AACA,4C;AACA,O;AACA,M;AACA,qB;AACA,uE;AACA,qE;AACA,sC;AACA,oC;AACA,qC;AACA,iB;AACA,qC;AACA,c;AACA,qC;AACA,iB;AACA,qD;AACA,kB;AACA,qD;AACA,iB;AACA,yD;AACA,2C;AACA,mB;AACA,iB;AACA,8C;AACA,0D;AACA,e;AACA,wB;AACA,yD;AACA,oE;AACA,Q;AACA,qB;AACA,gC;AACA,iB;AACA,gC;AACA,iB;AACA,gC;AACA,iB;AACA,mD;AACA,e;AACA,iB;AACA,K;AACA,G;;AAEA,mD;AACA,mE;AACA,+D;;AAEA,mC;AACA,8B;AACA,8D;AACA,qC;AACA,e;;AAEA,iB;AACA,iB;AACA,mC;AACA,mB;AACA,I;;AAEA,uB;;AAEA,8D;AACA,sD;AACA,oD;AACA,iD;AACA,+C;AACA,sD;AACA,+C;;AAEA,qB;AACA,gC;AACA,6B;;AAEA,gC;AACA,gE;AACA,sD;AACA,gE;AACA,iE;;AAEA,oB;AACA,6E;AACA,0D;AACA,G;;;AAGA,0D;;AAEA,W;;AAEA,sD;AACA,oC;AACA,yD;AACA,iB;AACA,4B;AACA,gD;AACA,e;AACA,I;;AAEA,kD;AACA,e;;AAEA,6B;AACA,kB;AACA,sC;AACA,Y;;AAEA,+C;AACA,+B;AACA,yC;AACA,oC;AACA,+B;AACA,+C;AACA,sD;AACA,S;AACA,Y;;AAEA,6B;AACA,qC;AACA,6B;AACA,uC;;AAEA,wB;AACA,wB;AACA,c;AACA,wD;AACA,O;AACA,K;;AAEA,kF;AACA,kC;AACA,iC;;AAEA,a;AACA,I;;AAEA,yD;AACA,6B;AACA,8B;AACA,sD;AACA,qB;AACA,2B;AACA,gB;AACA,mC;AACA,mB;AACA,yC;AACA,qB;AACA,6C;AACA,wB;AACA,oD;AACA,yC;AACA,S;AACA,O;AACA,O;AACA,wC;AACA,I;;AAEA,kE;AACA,kC;AACA,W;AACA,mB;AACA,wE;AACA,S;AACA,mD;AACA,2E;AACA,4D;AACA,gD;AACA,gD;AACA,yD;AACA,gD;AACA,K;AACA,I;;AAEA,uC;AACA,iB;AACA,kB;AACA,qB;AACA,6B;AACA,K;AACA,e;AACA,I;;AAEA,uC;AACA,8B;AACA,mB;AACA,mC;AACA,wB;AACA,qB;AACA,K;AACA,gB;AACA,I;;AAEA,yD;AACA,6B;;AAEA,8B;AACA,yD;AACA,6B;AACA,sE;AACA,S;AACA,gD;AACA,O;AACA,O;;AAEA,e;AACA,I;;AAEA,0B;AACA,qE;AACA,iE;AACA,wD;AACA,wE;;AAEA,+B;AACA,4C;AACA,sD;AACA,2E;AACA,kD;AACA,S;AACA,e;AACA,2E;AACA,oD;AACA,yD;AACA,gB;AACA,iB;AACA,0E;AACA,sC;AACA,qE;AACA,O;;AAEA,mB;AACA,iB;AACA,oC;AACA,G;;AAEA,G;;AAEA,0D;;AAEA,a;;AAEA,iC;;AAEA,qB;AACA,kB;AACA,8C;AACA,iC;AACA,iC;AACA,qB;AACA,4B;AACA,0B;AACA,O;AACA,8C;AACA,M;;AAEA,kD;AACA,8B;AACA,e;AACA,+B;AACA,W;AACA,e;AACA,iE;AACA,mD;AACA,+B;AACA,sC;AACA,sC;AACA,sC;AACA,a;AACA,e;AACA,kC;;AAEA,kB;;AAEA,Y;AACA,oD;AACA,iD;AACA,6D;AACA,gD;AACA,iD;AACA,2B;AACA,8B;;AAEA,mE;;AAEA,+B;AACA,oD;AACA,qD;AACA,oE;AACA,8C;AACA,8B;AACA,kC;AACA,4C;AACA,mB;AACA,yC;AACA,0C;AACA,yC;AACA,gC;AACA,uE;AACA,oC;AACA,sB;AACA,6D;AACA,6D;AACA,oB;AACA,+C;AACA,qE;AACA,uC;AACA,Y;;AAEA,8D;AACA,wB;;AAEA,8B;AACA,6C;AACA,2B;AACA,6C;;AAEA,qB;AACA,qB;;AAEA,+D;AACA,kC;AACA,8B;AACA,6C;AACA,sD;AACA,6C;AACA,6D;AACA,6D;AACA,0B;AACA,2D;;AAEA,qB;AACA,qB;;AAEA,wD;AACA,8B;AACA,6C;AACA,sD;AACA,6C;;AAEA,uD;AACA,qB;AACA,qB;AACA,8B;AACA,6C;AACA,0B;AACA,6C;;AAEA,gC;AACA,0B;AACA,uB;AACA,0B;AACA,qB;AACA,iE;AACA,8B;AACA,kD;AACA,sD;AACA,kD;;AAEA,2B;AACA,oB;AACA,qB;AACA,+B;AACA,8B;AACA,4C;AACA,2B;AACA,4C;;AAEA,mB;AACA,qB;AACA,S;AACA,O;AACA,K;;AAEA,6D;AACA,sB;;AAEA,kB;;AAEA,kB;AACA,yB;AACA,+C;AACA,sD;AACA,iE;AACA,mB;AACA,oB;AACA,U;AACA,yC;AACA,M;AACA,e;AACA,6B;;AAEA,iC;AACA,e;AACA,8C;AACA,6B;;AAEA,kC;AACA,e;AACA,0C;AACA,6B;;AAEA,gB;AACA,e;AACA,+C;AACA,6B;;AAEA,a;AACA,e;AACA,G;;AAEA,qD;AACA,qE;AACA,2D;;AAEA,sC;AACA,sC;;AAEA,8D;AACA,0B;AACA,4C;AACA,wB;AACA,oE;AACA,4C;AACA,sB;AACA,6D;AACA,wC;AACA,gB;AACA,+B;;AAEA,sD;AACA,6D;AACA,mE;AACA,sD;AACA,wC;AACA,uC;AACA,2C;AACA,wB;AACA,a;AACA,W;AACA,S;AACA,+B;AACA,4B;AACA,sC;AACA,O;AACA,a;AACA,gB;AACA,M;AACA,Y;AACA,gC;AACA,sC;AACA,M;AACA,oE;;AAEA,iE;AACA,mE;AACA,mE;AACA,uE;AACA,6D;AACA,8D;AACA,wC;AACA,+D;;AAEA,yB;AACA,8D;AACA,I;;AAEA,0C;AACA,yD;AACA,uC;AACA,oC;AACA,O;AACA,I;;AAEA,e;AACA,oD;AACA,kC;AACA,qD;AACA,6D;AACA,gC;AACA,e;AACA,gD;AACA,kC;AACA,sE;AACA,wD;AACA,4B;AACA,+C;AACA,a;AACA,2D;AACA,uE;;AAEA,S;AACA,e;;AAEA,iE;AACA,sD;AACA,8D;AACA,gE;AACA,0B;AACA,kD;AACA,sE;AACA,a;AACA,2D;AACA,uE;;AAEA,S;AACA,e;;AAEA,iE;AACA,a;AACA,2D;AACA,wE;;AAEA,gB;AACA,e;AACA,gD;AACA,G;AACA,G;;AAEA,yD;AACA,iE;;AAEA,qB;AACA,oB;AACA,iC;AACA,qC;AACA,qC;AACA,iB;AACA,mB;AACA,uB;AACA,0B;AACA,uB;AACA,S;AACA,Q;AACA,K;AACA,I;;AAEA,4B;AACA,qD;AACA,uB;AACA,K;AACA,iC;AACA,e;AACA,yD;AACA,4B;;;AAGA,yB;AACA,mD;AACA,oB;AACA,gE;AACA,c;AACA,a;AACA,4B;AACA,e;AACA,4B;AACA,W;AACA,e;AACA,4B;AACA,Y;AACA,e;AACA,4B;;AAEA,iB;AACA,e;AACA,G;;AAEA,mD;AACA,gC;;AAEA,yC;AACA,0C;;AAEA,wB;;AAEA,oD;AACA,iB;AACA,wB;AACA,wB;AACA,oC;AACA,qB;AACA,uD;AACA,4C;AACA,4E;AACA,2B;AACA,wC;AACA,uC;AACA,2C;AACA,wB;AACA,a;AACA,W;AACA,Q;AACA,kB;AACA,6C;AACA,U;AACA,yB;AACA,wB;AACA,a;;AAEA,e;;AAEA,sC;AACA,wB;AACA,uC;AACA,iB;AACA,mC;AACA,oB;AACA,I;AACA,qC;AACA,iC;AACA,+B;AACA,Y;AACA,uC;AACA,yD;AACA,qC;AACA,K;AACA,I;;AAEA,kE;;AAEA,iB;AACA,oD;AACA,4C;;AAEA,gB;AACA,uD;AACA,wD;AACA,2C;;AAEA,e;AACA,e;AACA,sC;;AAEA,qC;AACA,qC;AACA,sC;AACA,sC;AACA,sC;AACA,uC;AACA,sC;AACA,uC;AACA,iE;;AAEA,iC;AACA,a;AACA,mD;AACA,kE;;AAEA,a;AACA,kE;;AAEA,Y;AACA,gD;AACA,kE;;AAEA,oB;AACA,a;AACA,kE;;AAEA,Y;AACA,mD;AACA,oD;AACA,mD;AACA,iD;AACA,a;AACA,a;AACA,mE;;AAEA,yB;AACA,gC;AACA,6D;AACA,a;AACA,iF;;AAEA,yB;AACA,oC;AACA,qC;AACA,iF;;AAEA,qE;AACA,yB;AACA,oC;AACA,4C;AACA,8B;AACA,S;AACA,wE;;AAEA,qD;;AAEA,gE;AACA,8B;AACA,6B;AACA,gF;AACA,K;;AAEA,e;AACA,8B;AACA,S;AACA,wE;AACA,iE;AACA,+B;AACA,6C;AACA,8B;AACA,iC;AACA,K;;AAEA,uD;AACA,iF;AACA,yB;AACA,mC;AACA,6C;AACA,8B;AACA,S;AACA,yE;AACA,iE;AACA,+B;AACA,8B;AACA,iC;AACA,K;;AAEA,kB;;AAEA,G;;;AAGA,wD;AACA,2B;;AAEA,yB;AACA,yB;AACA,Y;AACA,kD;AACA,0B;AACA,O;AACA,4C;AACA,yD;AACA,yD;AACA,mC;AACA,8B;AACA,2D;AACA,2D;AACA,Y;AACA,yC;AACA,S;AACA,Q;AACA,qB;AACA,8C;AACA,iC;AACA,+C;AACA,W;AACA,+C;AACA,oB;AACA,O;AACA,M;AACA,+B;AACA,iC;AACA,gC;AACA,wD;AACA,O;AACA,a;AACA,gB;AACA,M;;AAEA,6B;AACA,uE;AACA,sC;AACA,I;;AAEA,U;AACA,e;AACA,2C;AACA,2C;AACA,2C;AACA,2C;;AAEA,gC;AACA,6B;AACA,kC;AACA,iB;AACA,I;;AAEA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;;AAEA,a;AACA,e;;AAEA,G;;;AAGA,kE;AACA,6B;AACA,4D;AACA,0C;AACA,yC;AACA,uE;AACA,wE;AACA,iB;AACA,O;AACA,+B;AACA,iC;AACA,mC;AACA,O;AACA,a;AACA,gB;AACA,M;;AAEA,0B;AACA,+D;AACA,I;;AAEA,6B;AACA,2B;AACA,Y;AACA,iB;AACA,iC;AACA,G;;AAEA,c;AACA,e;AACA,G;;;AAGA,gD;;AAEA,qC;AACA,oC;;AAEA,4B;AACA,iC;AACA,+B;AACA,wB;AACA,+B;AACA,yC;;AAEA,+C;;AAEA,2B;;AAEA,iD;AACA,sB;AACA,mB;AACA,kB;AACA,kE;AACA,Q;AACA,kB;AACA,kE;AACA,S;AACA,M;;AAEA,+B;AACA,e;AACA,+B;AACA,kC;;AAEA,e;AACA,e;AACA,+B;AACA,oE;;AAEA,Y;AACA,e;AACA,+B;AACA,uE;;AAEA,Y;AACA,e;AACA,iC;AACA,kC;;AAEA,e;AACA,e;AACA,+B;AACA,0E;;AAEA,a;AACA,e;AACA,kC;;AAEA,uC;;AAEA,uB;AACA,oB;AACA,gB;AACA,0C;AACA,qB;AACA,c;AACA,2B;AACA,sB;AACA,S;AACA,Q;AACA,K;AACA,I;;AAEA,8C;AACA,iC;AACA,sD;AACA,wB;AACA,gB;AACA,M;AACA,iE;AACA,+D;AACA,sE;AACA,mE;AACA,oE;AACA,gB;AACA,gD;;AAEA,a;AACA,e;AACA,G;;;AAGA,uD;AACA,e;;AAEA,wC;AACA,iC;AACA,oD;AACA,G;AACA,mC;AACA,iE;AACA,G;;AAEA,yB;AACA,wB;AACA,uC;AACA,mC;AACA,+B;AACA,8C;AACA,6C;AACA,kB;AACA,Q;AACA,iB;;AAEA,2B;AACA,0B;AACA,mB;AACA,e;AACA,I;;AAEA,W;AACA,iB;AACA,kC;AACA,qC;;AAEA,sB;AACA,4D;AACA,U;AACA,wB;AACA,M;AACA,iC;AACA,oC;;AAEA,sB;AACA,4D;AACA,U;AACA,wB;AACA,M;AACA,uB;AACA,qC;AACA,sB;AACA,M;AACA,sB;AACA,iB;AACA,iB;AACA,mB;AACA,M;AACA,2B;AACA,yD;AACA,M;AACA,wB;AACA,yB;AACA,mB;AACA,K;AACA,I;AACA,E;;AAEA,uE;AACA,4D;AACA,2C;AACA,e;;AAEA,6C;AACA,4E;;AAEA,sE;AACA,qC;AACA,4D;AACA,gD;AACA,oC;AACA,wB;AACA,wB;AACA,W;AACA,Q;AACA,M;;AAEA,qE;AACA,qC;AACA,4D;AACA,gD;AACA,uB;AACA,mC;AACA,wB;AACA,wB;AACA,W;AACA,Q;AACA,M;;AAEA,Y;;AAEA,iC;AACA,6D;;AAEA,oC;AACA,mB;AACA,6D;;AAEA,gB;AACA,iE;AACA,iE;;AAEA,wB;AACA,+D;;AAEA,6B;AACA,+C;;AAEA,mC;AACA,0D;AACA,0D;AACA,6C;;AAEA,gC;AACA,kE;AACA,kE;AACA,+D;AACA,M;AACA,Q;;;AAGA,sD;;AAEA,mD;AACA,kD;AACA,sD;;;AAGA,iB;AACA,oE;AACA,kD;AACA,mB;;AAEA,oC;AACA,mD;AACA,mE;AACA,iE;AACA,iE;AACA,qB;AACA,iE;AACA,mB;;AAEA,gE;AACA,oC;AACA,kD;AACA,mC;AACA,kD;AACA,mB;;AAEA,oC;AACA,mB;AACA,iD;AACA,iE;AACA,mB;;AAEA,G;;;AAGA,e;AACA,0B;AACA,e;AACA,qB;AACA,qC;AACA,0B;AACA,M;;AAEA,wD;AACA,mD;AACA,sE;AACA,qE;AACA,oD;;AAEA,Y;AACA,8B;;AAEA,gF;AACA,+E;AACA,0E;AACA,+E;AACA,6E;AACA,gF;AACA,+E;AACA,iC;AACA,U;AACA,iD;;AAEA,uD;AACA,2E;AACA,sC;AACA,sC;AACA,qD;AACA,mD;AACA,gB;AACA,mD;;AAEA,wC;AACA,mD;AACA,mD;AACA,Y;AACA,0C;AACA,0C;AACA,Y;AACA,U;AACA,kD;AACA,0D;AACA,qC;AACA,kD;AACA,gB;AACA,mD;;AAEA,iE;AACA,iC;AACA,a;AACA,mE;AACA,0C;AACA,uC;AACA,gD;AACA,Y;AACA,4B;AACA,U;AACA,kD;AACA,0D;AACA,uD;AACA,2B;AACA,iD;AACA,4B;AACA,U;;AAEA,0D;AACA,oC;AACA,gD;AACA,uC;AACA,sD;AACA,oD;AACA,0B;AACA,kD;;AAEA,4B;AACA,gD;AACA,uC;AACA,oE;AACA,kE;AACA,0B;AACA,kD;;AAEA,8C;AACA,gD;AACA,uC;AACA,wC;AACA,4C;AACA,+C;AACA,wD;AACA,yC;AACA,qC;AACA,gB;AACA,2C;AACA,+C;AACA,wD;AACA,wC;AACA,gB;AACA,yC;AACA,sC;AACA,e;AACA,a;AACA,Y;AACA,kE;AACA,0B;AACA,mD;;AAEA,Q;AACA,8B;AACA,yC;AACA,uB;AACA,W;AACA,qB;AACA,O;AACA,M;AACA,Q;;;AAGA,yD;AACA,0B;AACA,2B;AACA,sB;AACA,2D;AACA,wE;AACA,a;;AAEA,iB;AACA,uB;AACA,+C;AACA,kE;AACA,mD;AACA,iD;AACA,O;AACA,sB;AACA,4B;;AAEA,+B;AACA,uC;AACA,qD;AACA,sD;AACA,uD;AACA,uD;AACA,qB;AACA,qD;AACA,+C;AACA,+B;AACA,0B;AACA,+B;AACA,gC;AACA,sB;AACA,S;AACA,O;AACA,a;AACA,gB;AACA,M;;AAEA,e;;AAEA,+D;AACA,8C;AACA,oE;;AAEA,8D;AACA,mC;;AAEA,wB;AACA,iC;AACA,wB;AACA,e;AACA,6D;AACA,qC;;AAEA,mB;AACA,e;AACA,6B;AACA,6D;AACA,qC;;AAEA,wB;AACA,iC;AACA,wB;AACA,e;AACA,6D;AACA,qC;;AAEA,wB;AACA,iC;AACA,wB;AACA,e;AACA,6D;AACA,qC;;AAEA,wB;AACA,iC;AACA,wB;AACA,e;AACA,6D;AACA,qC;;AAEA,a;AACA,G;;AAEA,4D;AACA,qC;AACA,c;AACA,mC;AACA,mC;AACA,K;AACA,qB;AACA,2D;AACA,iB;AACA,qC;AACA,+D;AACA,uD;AACA,kD;AACA,O;AACA,wB;AACA,M;;AAEA,e;;AAEA,gF;AACA,2B;AACA,qE;;AAEA,+D;;AAEA,sC;AACA,mB;AACA,e;AACA,8D;;AAEA,8C;AACA,oB;AACA,e;AACA,+D;;AAEA,gC;AACA,yB;AACA,8D;AACA,e;AACA,8D;;AAEA,6E;AACA,wB;AACA,mB;AACA,e;AACA,6D;;AAEA,qC;AACA,yB;AACA,yB;AACA,+D;AACA,e;AACA,+D;;AAEA,gF;AACA,Y;AACA,mB;AACA,e;AACA,8D;;AAEA,qE;AACA,oB;AACA,e;AACA,+D;;AAEA,a;AACA,G;;AAEA,2D;AACA,uD;AACA,6D;AACA,oC;AACA,6B;AACA,6D;AACA,0E;AACA,e;AACA,gC;AACA,8E;AACA,qC;AACA,4D;AACA,0E;AACA,+D;AACA,qE;AACA,4E;AACA,+D;AACA,kC;AACA,c;AACA,2E;AACA,2B;AACA,O;AACA,Q;AACA,mB;AACA,uC;;AAEA,sC;AACA,mD;AACA,qD;AACA,Y;AACA,0C;AACA,mC;AACA,K;AACA,kE;AACA,sE;;AAEA,+B;AACA,wB;AACA,iB;AACA,oE;AACA,wE;;AAEA,mB;AACA,0B;AACA,0B;AACA,wB;AACA,mB;AACA,sE;AACA,0E;;AAEA,sC;AACA,yB;AACA,mB;AACA,sE;AACA,0E;AACA,K;AACA,sB;AACA,iB;AACA,kE;AACA,sE;;AAEA,+E;AACA,6E;AACA,kB;AACA,8C;AACA,qB;AACA,iB;AACA,0D;AACA,sE;;AAEA,6E;AACA,4B;AACA,iB;AACA,wE;AACA,4E;;AAEA,gF;AACA,8E;AACA,4E;AACA,wB;AACA,wD;AACA,wB;AACA,iB;AACA,oE;AACA,wE;;AAEA,mB;AACA,8E;AACA,gF;AACA,+E;AACA,iD;AACA,0D;AACA,0B;AACA,0B;AACA,mB;AACA,sE;AACA,0E;AACA,K;;AAEA,e;AACA,K;AACA,G;;AAEA,oE;;AAEA,uD;AACA,yC;;AAEA,U;AACA,a;;AAEA,0D;AACA,+B;AACA,2B;AACA,kC;AACA,kD;AACA,6C;AACA,wC;AACA,uC;AACA,+B;AACA,Q;AACA,6C;AACA,+B;AACA,Q;AACA,6B;AACA,+B;AACA,O;AACA,8C;AACA,I;;AAEA,W;AACA,c;AACA,2B;AACA,kD;AACA,mE;AACA,6B;AACA,O;AACA,gB;AACA,wB;;AAEA,0B;;AAEA,8B;AACA,e;AACA,gC;AACA,8B;;AAEA,a;AACA,e;AACA,sC;AACA,8B;;;AAGA,a;AACA,e;AACA,4C;;AAEA,kB;;AAEA,W;AACA,c;AACA,uB;AACA,8C;AACA,Y;AACA,+D;AACA,uD;AACA,qD;AACA,kE;AACA,S;AACA,uC;AACA,O;AACA,M;;AAEA,gC;AACA,e;AACA,+C;AACA,iE;AACA,4C;AACA,iB;;AAEA,a;AACA,e;AACA,sC;AACA,iB;;AAEA,a;AACA,e;AACA,a;AACA,sC;AACA,G;;;AAGA,8D;;AAEA,a;;AAEA,wD;;AAEA,gB;AACA,yB;AACA,8C;AACA,iC;AACA,gD;AACA,wC;AACA,M;;AAEA,e;AACA,e;AACA,e;AACA,e;AACA,e;;AAEA,6B;AACA,mC;AACA,mC;;AAEA,a;AACA,e;;AAEA,kD;;AAEA,U;AACA,a;;AAEA,0D;AACA,+B;AACA,2B;AACA,kC;AACA,kD;AACA,6C;AACA,wC;AACA,uC;AACA,+B;AACA,Q;AACA,6C;AACA,gC;AACA,Q;AACA,6B;AACA,iC;AACA,O;AACA,8C;AACA,I;;AAEA,kB;AACA,+C;AACA,wB;AACA,8C;;AAEA,kD;AACA,kC;AACA,2B;AACA,qB;AACA,2C;AACA,4B;AACA,uC;AACA,gD;AACA,wC;AACA,yB;AACA,6C;AACA,wB;AACA,c;AACA,8B;AACA,W;AACA,O;AACA,I;;AAEA,qD;;AAEA,W;AACA,c;;AAEA,yB;AACA,8C;AACA,8B;AACA,yB;AACA,Q;AACA,mD;AACA,oD;AACA,iD;AACA,kC;AACA,M;;AAEA,e;AACA,a;AACA,wE;AACA,iB;;AAEA,e;AACA,e;AACA,a;AACA,gD;AACA,iB;;AAEA,mB;AACA,e;AACA,a;AACA,oD;AACA,iB;;AAEA,a;AACA,e;;AAEA,sD;;AAEA,W;AACA,c;;AAEA,yB;AACA,8C;AACA,8B;AACA,yB;AACA,Q;AACA,mD;AACA,qD;AACA,iD;AACA,kC;AACA,M;;AAEA,e;AACA,a;AACA,wE;AACA,iB;;AAEA,e;AACA,e;AACA,a;AACA,gE;AACA,iB;;AAEA,a;AACA,e;AACA,a;AACA,sE;AACA,qD;AACA,iB;;;AAGA,0C;AACA,2C;AACA,G;;AAEA,iE;;AAEA,oE;AACA,mE;AACA,6D;;AAEA,yB;AACA,gD;AACA,gC;AACA,6B;AACA,mB;AACA,0C;AACA,+C;AACA,W;AACA,S;AACA,M;;AAEA,iC;AACA,6D;AACA,W;AACA,e;AACA,iC;AACA,6D;AACA,6B;AACA,W;AACA,e;;AAEA,oE;AACA,8D;AACA,oE;AACA,6D;;AAEA,qB;AACA,4C;AACA,gC;AACA,iC;AACA,mB;AACA,kD;AACA,+C;AACA,oB;AACA,S;AACA,M;;AAEA,6C;AACA,kC;AACA,8C;AACA,W;AACA,e;AACA,6C;AACA,kC;AACA,8C;AACA,6B;AACA,W;AACA,e;AACA,G;;AAEA,oE;AACA,gB;AACA,oE;AACA,I;;AAEA,a;AACA,gD;AACA,2D;AACA,6D;AACA,+D;AACA,uC;AACA,kD;AACA,mD;AACA,mD;AACA,2C;AACA,W;AACA,S;AACA,O;AACA,M;;AAEA,e;AACA,+B;AACA,S;AACA,W;AACA,e;AACA,8B;AACA,G;;AAEA,0D;AACA,yB;AACA,oB;AACA,iD;AACA,qC;AACA,4B;AACA,mB;AACA,6B;AACA,kC;AACA,oB;AACA,Q;AACA,6B;AACA,8B;AACA,8B;AACA,mC;AACA,oC;AACA,Y;AACA,mC;AACA,2B;AACA,oB;AACA,Q;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,oB;AACA,O;AACA,sB;AACA,mC;;AAEA,0B;AACA,iC;AACA,4B;AACA,iB;AACA,iB;AACA,gC;AACA,iC;AACA,kB;AACA,O;;AAEA,0B;AACA,iC;AACA,4B;AACA,4B;AACA,4B;AACA,sC;AACA,O;;AAEA,kB;AACA,O;;;AAGA,uB;AACA,uD;AACA,yC;AACA,gC;AACA,8B;AACA,Y;AACA,iC;AACA,2D;AACA,W;AACA,0B;AACA,0C;AACA,gC;AACA,uD;AACA,sD;AACA,6C;AACA,oC;AACA,mC;AACA,gB;AACA,qC;AACA,+D;AACA,e;AACA,8B;AACA,+C;AACA,qC;AACA,0B;AACA,e;AACA,wB;AACA,a;AACA,sB;AACA,W;;AAEA,4C;AACA,sD;AACA,6C;AACA,oC;AACA,mC;AACA,gB;AACA,qC;AACA,+D;AACA,e;AACA,8B;AACA,+C;AACA,qC;AACA,yD;AACA,8C;AACA,0B;AACA,e;AACA,wB;AACA,a;AACA,S;AACA,oB;AACA,S;AACA,K;AACA,gB;AACA,M;;AAEA,+B;AACA,2C;AACA,I;;AAEA,gC;AACA,mC;AACA,I;;AAEA,gC;AACA,oC;AACA,I;;AAEA,2B;AACA,e;AACA,2B;AACA,6D;AACA,gE;AACA,uB;AACA,uB;AACA,2B;AACA,Y;AACA,e;AACA,2B;;AAEA,U;AACA,e;AACA,2B;;AAEA,U;AACA,e;AACA,2B;;AAEA,iE;AACA,mE;AACA,mE;AACA,yE;AACA,0E;AACA,0E;;AAEA,U;AACA,e;AACA,2B;AACA,yE;AACA,0E;;AAEA,U;AACA,e;AACA,2B;AACA,yE;AACA,0E;AACA,0E;;AAEA,U;AACA,e;AACA,2B;AACA,yE;AACA,0E;AACA,0E;;AAEA,W;AACA,e;AACA,2B;;AAEA,e;AACA,2B;AACA,G;;AAEA,kE;AACA,a;AACA,yB;;AAEA,gD;AACA,0C;AACA,0C;AACA,qC;AACA,gC;AACA,kD;AACA,mB;AACA,mC;AACA,sB;AACA,W;AACA,wB;AACA,2C;AACA,gD;AACA,mC;AACA,6B;AACA,0B;AACA,8C;AACA,qB;AACA,4C;AACA,8D;AACA,+B;AACA,+C;AACA,kC;AACA,uB;AACA,oC;AACA,+D;AACA,yD;AACA,uB;AACA,mB;AACA,2B;AACA,W;AACA,iD;AACA,M;;AAEA,8B;AACA,kC;AACA,mC;AACA,yC;AACA,I;;AAEA,8B;AACA,qC;;AAEA,0C;AACA,0C;;AAEA,sC;AACA,qC;;AAEA,mD;AACA,mD;;AAEA,qC;AACA,qC;;AAEA,sD;AACA,wC;AACA,I;;AAEA,e;AACA,c;AACA,W;AACA,e;AACA,e;AACA,c;;AAEA,W;AACA,e;AACA,G;;AAEA,2D;;AAEA,U;AACA,6B;AACA,sB;AACA,qB;AACA,yC;AACA,0C;AACA,0C;AACA,M;AACA,e;AACA,I;;AAEA,sB;AACA,kB;AACA,oE;AACA,2B;;AAEA,gC;AACA,kB;AACA,2B;AACA,c;AACA,4E;AACA,c;AACA,K;AACA,2B;AACA,e;AACA,2B;;AAEA,oD;AACA,2B;AACA,uB;AACA,uB;AACA,yB;AACA,kD;AACA,2B;AACA,+E;AACA,+E;AACA,M;AACA,uC;AACA,4B;AACA,e;AACA,wC;AACA,4B;AACA,W;AACA,e;AACA,iE;AACA,uC;;AAEA,a;AACA,e;AACA,4B;AACA,yC;AACA,G;;AAEA,yD;AACA,6B;AACA,sB;AACA,qB;AACA,yC;AACA,0C;AACA,0C;AACA,M;AACA,e;AACA,I;;AAEA,uB;AACA,uB;;AAEA,6B;AACA,kD;AACA,6D;AACA,oD;AACA,iE;AACA,4C;AACA,2B;AACA,a;AACA,W;AACA,S;AACA,O;AACA,M;;AAEA,e;AACA,gC;AACA,4B;AACA,4B;;AAEA,e;AACA,e;AACA,gC;AACA,4B;AACA,4B;;AAEA,a;AACA,e;AACA,G;;AAEA,sD;AACA,kD;AACA,iC;AACA,4B;AACA,oC;AACA,Q;AACA,6B;AACA,4B;AACA,qD;AACA,+C;AACA,sC;AACA,iD;AACA,uC;AACA,Q;AACA,8B;AACA,oC;AACA,O;AACA,oB;AACA,iC;AACA,6C;AACA,mD;AACA,kD;AACA,wC;AACA,sD;AACA,S;AACA,6C;AACA,O;AACA,M;;AAEA,wC;AACA,e;AACA,kD;AACA,+C;AACA,kD;;AAEA,a;AACA,e;AACA,G;;AAEA,2D;AACA,6B;;AAEA,0B;AACA,gE;AACA,qB;AACA,O;AACA,I;;AAEA,mD;AACA,gD;AACA,mE;AACA,e;AACA,M;;AAEA,gE;AACA,gD;AACA,e;AACA,e;AACA,gE;AACA,gD;;AAEA,mC;AACA,mC;;AAEA,a;AACA,e;AACA,G;;AAEA,uE;AACA,oE;AACA,sE;AACA,kB;;AAEA,6B;;AAEA,6C;AACA,gE;AACA,0B;AACA,gE;AACA,qB;AACA,O;AACA,I;;AAEA,mD;AACA,iE;AACA,mD;AACA,mE;AACA,e;AACA,M;;AAEA,uE;AACA,mC;AACA,gD;AACA,e;AACA,e;AACA,uE;AACA,mC;AACA,gD;;AAEA,8B;AACA,mC;AACA,mC;;AAEA,a;AACA,e;AACA,G;;AAEA,sD;AACA,e;AACA,4B;AACA,e;AACA,2B;AACA,mB;AACA,e;AACA,I;;AAEA,0B;AACA,8D;AACA,2E;AACA,4E;AACA,8E;AACA,+D;AACA,O;AACA,I;;AAEA,6B;;AAEA,mD;AACA,8C;AACA,M;AACA,e;AACA,iC;AACA,e;AACA,e;AACA,oC;;AAEA,a;AACA,e;AACA,8B;;AAEA,G;;AAEA,qD;AACA,6B;;AAEA,e;AACA,qB;AACA,4C;AACA,kC;AACA,6B;AACA,4C;AACA,O;AACA,Y;AACA,wB;AACA,4D;AACA,O;AACA,M;AACA,I;AACA,6B;AACA,uB;AACA,6B;AACA,gD;AACA,sD;AACA,O;AACA,I;AACA,kD;AACA,kD;AACA,oB;AACA,O;AACA,M;;AAEA,gB;AACA,e;AACA,oC;;AAEA,gB;AACA,e;AACA,e;AACA,wC;;AAEA,e;AACA,gB;AACA,e;AACA,4C;;AAEA,a;AACA,e;AACA,G;;AAEA,0D;AACA,qD;;AAEA,e;AACA,e;;AAEA,6B;AACA,8D;AACA,qC;AACA,wB;AACA,oB;AACA,wB;AACA,M;AACA,I;AACA,mD;AACA,qB;AACA,8C;AACA,oC;AACA,8D;AACA,+D;AACA,iE;AACA,+C;AACA,sE;AACA,qC;AACA,M;AACA,0B;AACA,kE;AACA,sD;AACA,kE;AACA,gB;AACA,M;AACA,e;AACA,e;AACA,e;AACA,a;AACA,e;;AAEA,qC;AACA,4B;AACA,uB;AACA,uB;AACA,uB;AACA,uB;AACA,uB;AACA,uB;;AAEA,G;;AAEA,+D;AACA,6B;AACA,gC;;AAEA,4D;AACA,iC;AACA,mE;AACA,mE;AACA,+D;AACA,uB;AACA,kE;AACA,mC;AACA,M;;;AAGA,uE;AACA,e;AACA,e;AACA,uE;AACA,yC;AACA,yC;AACA,yC;AACA,yC;;AAEA,mB;AACA,e;AACA,uE;AACA,yC;;AAEA,a;AACA,e;AACA,G;;AAEA,8D;AACA,4D;AACA,mE;AACA,I;AACA,qD;;AAEA,6B;;AAEA,kD;AACA,6C;AACA,qB;AACA,gB;AACA,M;;AAEA,uC;AACA,e;AACA,e;AACA,kC;AACA,uC;AACA,kD;AACA,uC;AACA,e;AACA,yC;AACA,2C;AACA,kC;;AAEA,O;;AAEA,yB;;AAEA,8C;AACA,wC;AACA,S;AACA,2C;AACA,uB;AACA,+B;AACA,M;;AAEA,oD;AACA,e;AACA,e;AACA,kC;AACA,oD;AACA,kD;AACA,uC;AACA,e;AACA,yC;AACA,2C;AACA,kC;;AAEA,G;;;;;;;;;;;;;;;;;;;AC9yHA,sD;;AAEA,kC;;AAEA,4B;AACA,0C;AACA,uB;AACA,a;AACA,I;AACA,4C;AACA,0D;AACA,I;AACA,gD;AACA,sE;AACA,8E;AACA,6D;AACA,I;;AAEA,gB;;AAEA,yC;AACA,yC;AACA,wB;AACA,0C;AACA,mB;AACA,sC;AACA,mB;AACA,mB;AACA,gD;;AAEA,yC;AACA,yC;AACA,wB;AACA,mB;AACA,mB;AACA,gD;;AAEA,qE;AACA,U;AACA,gF;AACA,wB;AACA,0C;AACA,mB;AACA,+E;AACA,0C;AACA,mB;AACA,c;AACA,M;AACA,wE;AACA,mB;AACA,mB;AACA,c;AACA,M;AACA,gF;;AAEA,+C;;AAEA,yC;AACA,gD;AACA,uB;AACA,0C;AACA,mB;AACA,gD;AACA,0C;AACA,oB;AACA,gD;AACA,mB;AACA,mB;AACA,sD;;AAEA,gD;AACA,yC;AACA,uB;AACA,0C;AACA,mB;AACA,uD;AACA,0C;AACA,oB;AACA,iE;AACA,mB;AACA,mB;AACA,gD;;AAEA,gD;AACA,yC;AACA,yC;AACA,wB;AACA,0C;AACA,oB;AACA,mB;AACA,mB;AACA,gD;;AAEA,iB;AACA,+C;AACA,+C;AACA,I;;AAEA,oC;AACA,yC;AACA,mD;AACA,2C;AACA,qC;AACA,qC;AACA,2C;AACA,oD;AACA,gD;AACA,2C;AACA,2C;AACA,M;AACA,0D;AACA,qB;AACA,gD;AACA,qB;AACA,qB;AACA,0D;AACA,6C;AACA,I;;AAEA,sE;AACA,G;;AAEA,+D;;AAEA,+C;AACA,a;AACA,0B;AACA,kB;AACA,gB;AACA,0B;AACA,qB;AACA,+B;AACA,kC;AACA,iC;AACA,2B;AACA,+B;AACA,mC;AACA,W;AACA,sC;AACA,oC;AACA,qD;AACA,gC;AACA,sD;AACA,qB;AACA,mB;AACA,gB;AACA,qD;AACA,S;AACA,uB;AACA,4C;AACA,+B;AACA,W;AACA,kC;AACA,8B;AACA,2C;AACA,kB;AACA,qC;AACA,W;AACA,W;AACA,oB;AACA,Q;AACA,yB;AACA,yC;AACA,yB;AACA,qC;AACA,8B;AACA,4C;AACA,qC;AACA,wC;AACA,uC;AACA,4D;AACA,4C;AACA,uC;AACA,sC;AACA,uD;AACA,kB;AACA,4D;AACA,W;AACA,kD;AACA,W;AACA,Q;AACA,uC;AACA,M;AACA,gB;AACA,yB;AACA,gB;AACA,I;;AAEA,2B;AACA,8C;AACA,mE;AACA,Y;AACA,qD;;AAEA,oD;AACA,Y;AACA,oD;;AAEA,oC;AACA,Y;AACA,6C;AACA,uC;;AAEA,e;AACA,uB;AACA,wC;AACA,Y;AACA,gF;;;AAGA,gF;AACA,Y;AACA,qC;AACA,wC;AACA,Y;AACA,sC;AACA,2D;AACA,Y;AACA,qC;AACA,wC;AACA,Y;AACA,sC;;AAEA,6D;AACA,sC;AACA,2D;AACA,Y;AACA,qC;AACA,wC;AACA,Y;AACA,sC;AACA,2D;AACA,Y;AACA,qC;AACA,wC;AACA,Y;AACA,sC;AACA,4D;AACA,Y;AACA,qC;;AAEA,wC;AACA,2E;AACA,mD;;AAEA,qC;AACA,2E;AACA,qD;;;AAGA,G","sourcesContent":["// XXX make sure that when tests use id=\"...\" to trigger patching, \"preserve\" happens\n// XXX test that events inside constant regions still work after patching\n// XXX test arguments to landmark rendered callback\n// XXX test variable wrapping (eg TR vs THEAD) inside each branch of Spark.list?\n\n\nSparkTest.setCheckIECompliance(true);\n\n// Tests can use {preserve: idNameLabels} or renderWithPreservation\n// to cause any element with an id or name to be preserved.  This effect\n// is similar to what the preserve-inputs package does, though it applies\n// to all elements, not just inputs.\n\nvar idNameLabels = {\n  '*[id], *[name]': Spark._labelFromIdOrName\n};\n\nvar renderWithPreservation = function (htmlFunc) {\n  return Meteor.render(function () {\n    return Spark.createLandmark({ preserve: idNameLabels}, htmlFunc);\n  });\n};\n\nvar eventmap = function (/*args*/) {\n  // support event_buf as final argument\n  var event_buf = null;\n  if (arguments.length && _.isArray(arguments[arguments.length-1])) {\n    event_buf = arguments[arguments.length-1];\n    arguments.length--;\n  }\n  var events = {};\n  _.each(arguments, function (esel) {\n    var etyp = esel.split(' ')[0];\n    events[esel] = function (evt) {\n      if (evt.type !== etyp)\n        throw new Error(etyp+\" event arrived as \"+evt.type);\n      (event_buf || this).push(esel);\n    };\n  });\n  return events;\n};\n\nvar nodesToArray = function (array) {\n  // Starting in underscore 1.4, _.toArray does not work right on a node\n  // list in IE8. This is a workaround to support IE8.\n  return _.map(array, _.identity);\n};\n\nTinytest.add(\"spark - assembly\", function (test) {\n\n  var furtherCanon = function(str) {\n    // further canonicalize innerHTML in IE by adding close\n    // li tags to \"<ul><li>one<li>two<li>three</li></ul>\"\n    return str.replace(/<li>(\\w*)(?=<li>)/g, function(s) {\n      return s+\"</li>\";\n    });\n  };\n\n  var doTest = function (calc) {\n    var frag = Spark.render(function () {\n      return calc(function (str, expected) {\n        return Spark.setDataContext(null, str);\n      });\n    });\n    var groups = [];\n    var html = calc(function (str, expected, noRange) {\n      if (arguments.length > 1)\n        str = expected;\n      if (! noRange)\n        groups.push(str);\n      return str;\n    });\n    var f = WrappedFrag(frag);\n    test.equal(furtherCanon(f.html()), html);\n\n    var actualGroups = [];\n    var tempRange = new LiveRange(SparkTest.TAG, frag);\n    tempRange.visit(function (isStart, rng) {\n      if (! isStart && rng.type === \"data\" /* Spark._ANNOTATION_DATA */)\n        actualGroups.push(furtherCanon(canonicalizeHtml(\n          DomUtils.rangeToHtml(rng.firstNode(), rng.lastNode()))));\n    });\n    test.equal(actualGroups.join(','), groups.join(','));\n  };\n\n  doTest(function (A) { return \"<p>Hello</p>\"; });\n  doTest(function (A) { return \"<td>Hello</td><td>World</td>\"; });\n  doTest(function (A) { return \"<td>\"+A(\"Hello\")+\"</td>\"; });\n  doTest(function (A) { return A(\"<td>\"+A(\"Hello\")+\"</td>\"); });\n  doTest(function (A) { return A(A(A(A(A(A(\"foo\")))))); });\n  doTest(\n    function (A) { return \"<div>Yo\"+A(\"<p>Hello \"+A(A(\"World\")),\"<p>Hello World</p>\")+\n                  \"</div>\"; });\n  doTest(function (A) {\n    return A(\"<ul>\"+A(\"<li>one\",\"<li>one</li>\")+\n             A(\"<li>two\",\"<li>two</li>\")+\n             A(\"<li>three\",\"<li>three</li>\"),\n             \"<ul><li>one</li><li>two</li><li>three</li></ul>\"); });\n\n  doTest(function (A) {\n    return A(\"<table>\"+A(\"<tr>\"+A(\"<td>\"+A(\"Hi\")+\"</td>\")+\"</tr>\")+\"</table>\",\n             \"<table><tbody><tr><td>Hi</td></tr></tbody></table>\");\n  });\n\n  test.throws(function () {\n    doTest(function (A) {\n      var z = A(\"Hello\");\n      return z+z;\n    });\n  });\n\n  var frag = Spark.render(function () {\n    return '<div foo=\"abc' +\n      Spark.setDataContext(null, \"bar\") +\n      'xyz\">Hello</div>';\n  });\n  var div = frag.firstChild;\n  test.equal(div.nodeName, \"DIV\");\n  var attrValue = div.getAttribute('foo');\n  test.isTrue(attrValue.indexOf('abc<!--') === 0, attrValue);\n  test.isTrue(attrValue.indexOf('-->xyz') >= 0, attrValue);\n});\n\n\nTinytest.add(\"spark - repeat inclusion\", function(test) {\n  test.throws(function() {\n    var frag = Spark.render(function() {\n      var x = Spark.setDataContext({}, \"abc\");\n      return x + x;\n    });\n  });\n});\n\n\nTinytest.add(\"spark - replace tag contents\", function (test) {\n\n  // adapted from nateps / metamorph\n\n  var do_onscreen = function (f) {\n    var div = OnscreenDiv();\n    var stuff = {\n      div: div,\n      node: _.bind(div.node, div),\n      render: function (rfunc) {\n        div.node().appendChild(Meteor.render(rfunc));\n      }\n    };\n\n    f.call(stuff);\n\n    div.kill();\n  };\n\n  var R, div;\n\n  // basic text replace\n\n  do_onscreen(function () {\n    R = ReactiveVar(\"one two three\");\n    this.render(function () {\n      return R.get();\n    });\n    R.set(\"three four five six\");\n    Deps.flush();\n    test.equal(this.div.html(), \"three four five six\");\n  });\n\n  // work inside a table\n\n  do_onscreen(function () {\n    R = ReactiveVar(\"<tr><td>HI!</td></tr>\");\n    this.render(function () {\n      return \"<table id='morphing'>\" + R.get() + \"</table>\";\n    });\n\n    test.equal($(this.node()).find(\"#morphing td\").text(), \"HI!\");\n    R.set(\"<tr><td>BUH BYE!</td></tr>\");\n    Deps.flush();\n    test.equal($(this.node()).find(\"#morphing td\").text(), \"BUH BYE!\");\n  });\n\n  // work inside a tbody\n\n  do_onscreen(function () {\n    R = ReactiveVar(\"<tr><td>HI!</td></tr>\");\n    this.render(function () {\n      return \"<table id='morphing'><tbody>\" + R.get() + \"</tbody></table>\";\n    });\n\n    test.equal($(this.node()).find(\"#morphing td\").text(), \"HI!\");\n    R.set(\"<tr><td>BUH BYE!</td></tr>\");\n    Deps.flush();\n    test.equal($(this.node()).find(\"#morphing td\").text(), \"BUH BYE!\");\n  });\n\n  // work inside a tr\n\n  do_onscreen(function () {\n    R = ReactiveVar(\"<td>HI!</td>\");\n    this.render(function () {\n      return \"<table id='morphing'><tr>\" + R.get() + \"</tr></table>\";\n    });\n\n    test.equal($(this.node()).find(\"#morphing td\").text(), \"HI!\");\n    R.set(\"<td>BUH BYE!</td>\");\n    Deps.flush();\n    test.equal($(this.node()).find(\"#morphing td\").text(), \"BUH BYE!\");\n  });\n\n  // work inside a ul\n\n  do_onscreen(function () {\n    R = ReactiveVar(\"<li>HI!</li>\");\n    this.render(function () {\n      return \"<ul id='morphing'>\" + R.get() + \"</ul>\";\n    });\n\n    test.equal($(this.node()).find(\"#morphing li\").text(), \"HI!\");\n    R.set(\"<li>BUH BYE!</li>\");\n    Deps.flush();\n    test.equal($(this.node()).find(\"#morphing li\").text(), \"BUH BYE!\");\n  });\n\n  // work inside a select\n\n  do_onscreen(function () {\n    R = ReactiveVar(\"<option>HI!</option>\");\n    this.render(function () {\n      return \"<select id='morphing'>\" + R.get() + \"</select>\";\n    });\n\n    test.equal($(this.node()).find(\"#morphing option\").text(), \"HI!\");\n    R.set(\"<option>BUH BYE!</option>\");\n    Deps.flush();\n    test.equal($(this.node()).find(\"#morphing option\").text(), \"BUH BYE!\");\n  });\n\n  // list of select options\n\n  do_onscreen(function () {\n    var c = new LocalCollection();\n    c.insert({name: 'Hamburger', value: 1});\n    c.insert({name: 'Cheeseburger', value: 2});\n    this.render(function () {\n      return \"<select id='morphing' name='fred'>\" +\n        Spark.list(c.find({}, {sort: ['value']}), function (doc) {\n          return '<option value=\"' + doc.value + '\">' + doc.name + '</option>';\n        }) +\n        \"</select>\";\n    });\n\n    var furtherCanon = function (html) {\n      return html.replace(/\\s*selected=\"selected\"/g, '');\n    };\n\n    test.equal(furtherCanon(this.div.html()),\n               '<select id=\"morphing\" name=\"fred\">' +\n               '<option value=\"1\">Hamburger</option>' +\n               '<option value=\"2\">Cheeseburger</option>' +\n               '</select>');\n    c.insert({name: 'Chicken Snickers', value: 8});\n    Deps.flush();\n    test.equal(furtherCanon(this.div.html()),\n               '<select id=\"morphing\" name=\"fred\">' +\n               '<option value=\"1\">Hamburger</option>' +\n               '<option value=\"2\">Cheeseburger</option>' +\n               '<option value=\"8\">Chicken Snickers</option>' +\n               '</select>');\n    c.remove({value: 1});\n    c.remove({value: 2});\n    Deps.flush();\n    test.equal(furtherCanon(this.div.html()),\n               '<select id=\"morphing\" name=\"fred\">' +\n               '<option value=\"8\">Chicken Snickers</option>' +\n               '</select>');\n    c.remove({});\n    Deps.flush();\n    test.equal(furtherCanon(this.div.html()),\n               '<select id=\"morphing\" name=\"fred\">' +\n               '<!---->' +\n               '</select>');\n    c.insert({name: 'Hamburger', value: 1});\n    c.insert({name: 'Cheeseburger', value: 2});\n    Deps.flush();\n    test.equal(furtherCanon(this.div.html()),\n               '<select id=\"morphing\" name=\"fred\">' +\n               '<option value=\"1\">Hamburger</option>' +\n               '<option value=\"2\">Cheeseburger</option>' +\n               '</select>');\n  });\n\n});\n\n\nTinytest.add(\"spark - basic isolate\", function (test) {\n\n  var R = ReactiveVar('foo');\n\n  var div = OnscreenDiv(Spark.render(function () {\n    return '<div>' + Spark.isolate(function () {\n      return '<span>' + R.get() + '</span>';\n    }) + '</div>';\n  }));\n\n  test.equal(div.html(), '<div><span>foo</span></div>');\n  R.set('bar');\n  test.equal(div.html(), '<div><span>foo</span></div>');\n  Deps.flush();\n  test.equal(div.html(), '<div><span>bar</span></div>');\n  R.set('baz');\n  Deps.flush();\n  test.equal(div.html(), '<div><span>baz</span></div>');\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - one render\", function (test) {\n\n  var R = ReactiveVar(\"foo\");\n\n  var frag = WrappedFrag(Meteor.render(function () {\n    return R.get();\n  })).hold();\n\n  test.equal(R.numListeners(), 1);\n\n  // frag should be \"foo\" initially\n  test.equal(frag.html(), \"foo\");\n  R.set(\"bar\");\n  // haven't flushed yet, so update won't have happened\n  test.equal(frag.html(), \"foo\");\n  Deps.flush();\n  // flushed now, frag should say \"bar\"\n  test.equal(frag.html(), \"bar\");\n  frag.release(); // frag is now considered offscreen\n  Deps.flush();\n  R.set(\"baz\");\n  Deps.flush();\n  // no update should have happened, offscreen range dep killed\n  test.equal(frag.html(), \"bar\");\n\n  // should be back to no listeners\n  test.equal(R.numListeners(), 0);\n\n  // empty return value should work, and show up as a comment\n  frag = WrappedFrag(Meteor.render(function () {\n    return \"\";\n  }));\n  test.equal(frag.html(), \"<!---->\");\n\n  // nodes coming and going at top level of fragment\n  R.set(true);\n  frag = WrappedFrag(Meteor.render(function () {\n    return R.get() ? \"<div>hello</div><div>world</div>\" : \"\";\n  })).hold();\n  test.equal(frag.html(), \"<div>hello</div><div>world</div>\");\n  R.set(false);\n  Deps.flush();\n  test.equal(frag.html(), \"<!---->\");\n  R.set(true);\n  Deps.flush();\n  test.equal(frag.html(), \"<div>hello</div><div>world</div>\");\n  test.equal(R.numListeners(), 1);\n  frag.release();\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n\n  // more complicated changes\n  R.set(1);\n  frag = WrappedFrag(Meteor.render(function () {\n    var result = [];\n    for(var i=0; i<R.get(); i++) {\n      result.push('<div id=\"x'+i+'\" class=\"foo\" name=\"bar\"><p><b>'+\n                  R.get()+'</b></p></div>');\n    }\n    return result.join('');\n  })).hold();\n  test.equal(frag.html(),\n               '<div class=\"foo\" id=\"x0\" name=\"bar\"><p><b>1</b></p></div>');\n  R.set(3);\n  Deps.flush();\n  test.equal(frag.html(),\n               '<div class=\"foo\" id=\"x0\" name=\"bar\"><p><b>3</b></p></div>'+\n               '<div class=\"foo\" id=\"x1\" name=\"bar\"><p><b>3</b></p></div>'+\n               '<div class=\"foo\" id=\"x2\" name=\"bar\"><p><b>3</b></p></div>');\n  R.set(2);\n  Deps.flush();\n  test.equal(frag.html(),\n               '<div class=\"foo\" id=\"x0\" name=\"bar\"><p><b>2</b></p></div>'+\n               '<div class=\"foo\" id=\"x1\" name=\"bar\"><p><b>2</b></p></div>');\n  frag.release();\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n\n  // caller violating preconditions\n  test.equal(WrappedFrag(Meteor.render(\"foo\")).html(), \"foo\");\n});\n\nTinytest.add(\"spark - heuristic finalize\", function (test) {\n\n  var R = ReactiveVar(123);\n\n  var div = OnscreenDiv(Meteor.render(function () {\n    return \"<p>The number is \"+R.get()+\".</p><hr><br><br><u>underlined</u>\";\n  }));\n\n  test.equal(div.html(), \"<p>The number is 123.</p><hr><br><br><u>underlined</u>\");\n  test.equal(R.numListeners(), 1);\n  Deps.flush();\n  R.set(456); // won't take effect until flush()\n  test.equal(div.html(), \"<p>The number is 123.</p><hr><br><br><u>underlined</u>\");\n  test.equal(R.numListeners(), 0); // listener already gone\n  Deps.flush();\n  test.equal(div.html(), \"<p>The number is 456.</p><hr><br><br><u>underlined</u>\");\n  test.equal(R.numListeners(), 1);\n\n  div.remove();\n  R.set(789); // update should force div dependency to be GCed when div is updated\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n});\n\nTinytest.add(\"spark - isolate\", function (test) {\n\n  var inc = function (v) {\n    v.set(v.get() + 1); };\n\n  var R1 = ReactiveVar(0);\n  var R2 = ReactiveVar(0);\n  var R3 = ReactiveVar(0);\n  var count1 = 0, count2 = 0, count3 = 0;\n\n  var frag = WrappedFrag(Meteor.render(function () {\n    return R1.get() + \",\" + (count1++) + \" \" +\n      Spark.isolate(function () {\n        return R2.get() + \",\" + (count2++) + \" \" +\n          Spark.isolate(function () {\n            return R3.get() + \",\" + (count3++);\n          });\n      });\n  })).hold();\n\n  test.equal(frag.html(), \"0,0 0,0 0,0\");\n\n  inc(R1); Deps.flush();\n  test.equal(frag.html(), \"1,1 0,1 0,1\");\n\n  inc(R2); Deps.flush();\n  test.equal(frag.html(), \"1,1 1,2 0,2\");\n\n  inc(R3); Deps.flush();\n  test.equal(frag.html(), \"1,1 1,2 1,3\");\n\n  inc(R2); Deps.flush();\n  test.equal(frag.html(), \"1,1 2,3 1,4\");\n\n  inc(R1); Deps.flush();\n  test.equal(frag.html(), \"2,2 2,4 1,5\");\n\n  frag.release();\n  Deps.flush();\n  test.equal(R1.numListeners(), 0);\n  test.equal(R2.numListeners(), 0);\n  test.equal(R3.numListeners(), 0);\n\n  R1.set(0);\n  R2.set(0);\n  R3.set(0);\n\n  frag = WrappedFrag(Meteor.render(function () {\n    var buf = [];\n    buf.push('<div class=\"foo', R1.get(), '\">');\n    buf.push(Spark.isolate(function () {\n      var buf = [];\n      for(var i=0; i<R2.get(); i++) {\n        buf.push(Spark.isolate(function () {\n          return '<div>'+R3.get()+'</div>';\n        }));\n      }\n      return buf.join('');\n    }));\n    buf.push('</div>');\n    return buf.join('');\n  })).hold();\n\n  test.equal(frag.html(), '<div class=\"foo0\"><!----></div>');\n  R2.set(3); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo0\">'+\n               '<div>0</div><div>0</div><div>0</div>'+\n               '</div>');\n\n  R3.set(5); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo0\">'+\n               '<div>5</div><div>5</div><div>5</div>'+\n               '</div>');\n\n  R1.set(7); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo7\">'+\n               '<div>5</div><div>5</div><div>5</div>'+\n               '</div>');\n\n  R2.set(1); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo7\">'+\n               '<div>5</div>'+\n               '</div>');\n\n  R1.set(11); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo11\">'+\n               '<div>5</div>'+\n               '</div>');\n\n  R2.set(2); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo11\">'+\n               '<div>5</div><div>5</div>'+\n               '</div>');\n\n  R3.set(4); Deps.flush();\n  test.equal(frag.html(), '<div class=\"foo11\">'+\n               '<div>4</div><div>4</div>'+\n               '</div>');\n\n  frag.release();\n\n  // calling isolate() outside of render mode\n  test.equal(Spark.isolate(function () { return \"foo\"; }), \"foo\");\n\n  // caller violating preconditions\n\n  test.throws(function () {\n    Meteor.render(function () {\n      return Spark.isolate(\"foo\");\n    });\n  });\n\n\n  // unused isolate\n\n  var Q = ReactiveVar(\"foo\");\n  Meteor.render(function () {\n    // create an isolate, in render mode,\n    // but don't use it.\n    Spark.isolate(function () {\n      return Q.get();\n    });\n    return \"\";\n  });\n  Q.set(\"bar\");\n  // might get an error on flush() if implementation\n  // deals poorly with unused isolates, or a listener\n  // still existing after flush.\n  Deps.flush();\n  test.equal(Q.numListeners(), 0);\n\n  // nesting\n\n  var stuff = ReactiveVar(true);\n  var div = OnscreenDiv(Meteor.render(function () {\n    return Spark.isolate(function () {\n      return \"x\"+(stuff.get() ? 'y' : '') + Spark.isolate(function () {\n        return \"hi\";\n      });\n    });\n  }));\n  test.equal(div.html(), \"xyhi\");\n  stuff.set(false);\n  Deps.flush();\n  test.equal(div.html(), \"xhi\");\n  div.kill();\n  Deps.flush();\n\n  // more nesting\n\n  var num1 = ReactiveVar(false);\n  var num2 = ReactiveVar(false);\n  var num3 = ReactiveVar(false);\n  var numset = function (n) {\n    _.each([num1, num2, num3], function (v, i) {\n      v.set((i+1) === n);\n    });\n  };\n  numset(1);\n\n  var div = OnscreenDiv(Meteor.render(function () {\n    return Spark.isolate(function () {\n      return (num1.get() ? '1' : '')+\n        Spark.isolate(function () {\n          return (num2.get() ? '2' : '')+\n            Spark.isolate(function () {\n              return (num3.get() ? '3' : '')+'x';\n            });\n        });\n    });\n  }));\n  test.equal(div.html(), \"1x\");\n  numset(2);\n  Deps.flush();\n  test.equal(div.html(), \"2x\");\n  numset(3);\n  Deps.flush();\n  test.equal(div.html(), \"3x\");\n  numset(1);\n  Deps.flush();\n  test.equal(div.html(), \"1x\");\n  numset(3);\n  Deps.flush();\n  test.equal(div.html(), \"3x\");\n  numset(2);\n  Deps.flush();\n  test.equal(div.html(), \"2x\");\n  div.remove();\n  Deps.flush();\n\n  // the real test for slow-path GC finalization:\n  num2.set(! num2.get());\n  Deps.flush();\n  test.equal(num1.numListeners(), 0);\n  test.equal(num2.numListeners(), 0);\n  test.equal(num3.numListeners(), 0);\n});\n\nTinytest.add(\"spark - data context\", function (test) {\n  var d1 = {x: 1};\n  var d2 = {x: 2};\n  var d3 = {x: 3};\n  var d4 = {x: 4};\n  var d5 = {x: 5};\n\n  var traverse = function (frag) {\n    var out = '';\n    var walkChildren = function (parent) {\n      for (var node = parent.firstChild; node; node = node.nextSibling) {\n        if (node.nodeType !== 8 /* COMMENT */)  {\n          var data = Spark.getDataContext(node);\n          out += (data === null) ? \"_\" : data.x;\n        }\n        if (node.nodeType === 1 /* ELEMENT */)\n          walkChildren(node);\n      }\n    };\n    walkChildren(frag);\n    return out;\n  };\n\n  var testData = function (serialized, htmlFunc) {\n    test.equal(traverse(Spark.render(htmlFunc)), serialized);\n  };\n\n  testData(\"_\", function () {\n    return \"hi\";\n  });\n\n  testData(\"__\", function () {\n    return \"<div>hi</div>\";\n  });\n\n  testData(\"_1\", function () {\n    return \"<div>\" + Spark.setDataContext(d1, \"hi\") + \"</div>\";\n  });\n\n  testData(\"21\", function () {\n    return Spark.setDataContext(\n      d2, \"<div>\" + Spark.setDataContext(d1, \"hi\") + \"</div>\");\n  });\n\n  testData(\"21\", function () {\n    return Spark.setDataContext(\n      d2, \"<div>\" +\n        Spark.setDataContext(d3,\n                             Spark.setDataContext(d1, \"hi\")) +\n        \"</div>\");\n  });\n\n  testData(\"23\", function () {\n    return Spark.setDataContext(\n      d2, \"<div>\" +\n        Spark.setDataContext(d1,\n                             Spark.setDataContext(d3, \"hi\")) +\n        \"</div>\");\n  });\n\n  testData(\"23\", function () {\n    var html = Spark.setDataContext(\n      d2, \"<div>\" +\n        Spark.setDataContext(d1,\n                             Spark.setDataContext(d3, \"hi\")) +\n        \"</div>\");\n    return Spark.setDataContext(d4, html);\n  });\n\n  testData(\"1_2\", function () {\n    return Spark.setDataContext(d1, \"hi\") + \"-\" +\n      Spark.setDataContext(d2, \"there\");\n  });\n\n  testData(\"_122_3__45\", function () {\n    return \"<div>\" +\n      Spark.setDataContext(d1, \"<div></div>\") +\n      Spark.setDataContext(d2, \"<div><div></div></div>\") +\n      \"<div></div>\" +\n      Spark.setDataContext(d3, \"<div></div>\") +\n      \"<div><div></div></div>\" +\n      Spark.setDataContext(d4, \"<div>\" +\n                           Spark.setDataContext(d5, \"<div></div>\") +\n                           \"</div>\");\n  });\n});\n\nTinytest.add(\"spark - tables\", function (test) {\n  var R = ReactiveVar(0);\n\n  var table = OnscreenDiv(Meteor.render(function () {\n    var buf = [];\n    buf.push(\"<table>\");\n    for(var i=0; i<R.get(); i++)\n      buf.push(\"<tr><td>\"+(i+1)+\"</td></tr>\");\n    buf.push(\"</table>\");\n    return buf.join('');\n  }));\n\n  R.set(1);\n  Deps.flush();\n  test.equal(table.html(), \"<table><tbody><tr><td>1</td></tr></tbody></table>\");\n\n  R.set(10);\n  test.equal(table.html(), \"<table><tbody><tr><td>1</td></tr></tbody></table>\");\n  Deps.flush();\n  test.equal(table.html(), \"<table><tbody>\"+\n               \"<tr><td>1</td></tr>\"+\n               \"<tr><td>2</td></tr>\"+\n               \"<tr><td>3</td></tr>\"+\n               \"<tr><td>4</td></tr>\"+\n               \"<tr><td>5</td></tr>\"+\n               \"<tr><td>6</td></tr>\"+\n               \"<tr><td>7</td></tr>\"+\n               \"<tr><td>8</td></tr>\"+\n               \"<tr><td>9</td></tr>\"+\n               \"<tr><td>10</td></tr>\"+\n               \"</tbody></table>\");\n\n  R.set(0);\n  Deps.flush();\n  test.equal(table.html(), \"<table></table>\");\n  table.kill();\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n\n  var div = OnscreenDiv();\n  div.node().appendChild(document.createElement(\"TABLE\"));\n  div.node().firstChild.appendChild(Meteor.render(function () {\n    var buf = [];\n    for(var i=0; i<R.get(); i++)\n      buf.push(\"<tr><td>\"+(i+1)+\"</td></tr>\");\n    return buf.join('');\n  }));\n  test.equal(div.html(), \"<table><!----></table>\");\n  R.set(3);\n  Deps.flush();\n  test.equal(div.html(), \"<table><tbody>\"+\n               \"<tr><td>1</td></tr>\"+\n               \"<tr><td>2</td></tr>\"+\n               \"<tr><td>3</td></tr>\"+\n               \"</tbody></table>\");\n  test.equal(div.node().firstChild.rows.length, 3);\n  R.set(0);\n  Deps.flush();\n  test.equal(div.html(), \"<table><!----></table>\");\n  div.kill();\n  Deps.flush();\n\n  test.equal(R.numListeners(), 0);\n\n  div = OnscreenDiv();\n  div.node().appendChild(DomUtils.htmlToFragment(\"<table><tr></tr></table>\"));\n  R.set(3);\n  div.node().getElementsByTagName(\"tr\")[0].appendChild(Meteor.render(\n    function () {\n      var buf = [];\n      for(var i=0; i<R.get(); i++)\n        buf.push(\"<td>\"+(i+1)+\"</td>\");\n      return buf.join('');\n    }));\n  test.equal(div.html(),\n               \"<table><tbody><tr><td>1</td><td>2</td><td>3</td>\"+\n               \"</tr></tbody></table>\");\n  R.set(1);\n  Deps.flush();\n  test.equal(div.html(),\n               \"<table><tbody><tr><td>1</td></tr></tbody></table>\");\n  div.kill();\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n\n  div = OnscreenDiv(renderWithPreservation(function() {\n    return '<table id=\"my-awesome-table\">'+R.get()+'</table>';\n  }));\n  Deps.flush();\n  R.set(\"<tr><td>Hello</td></tr>\");\n  Deps.flush();\n  test.equal(\n    div.html(),\n    '<table id=\"my-awesome-table\"><tbody><tr><td>Hello</td></tr></tbody></table>');\n  div.kill();\n  Deps.flush();\n\n  test.equal(R.numListeners(), 0);\n});\n\nTinytest.add(\"spark - event handling\", function (test) {\n  var event_buf = [];\n  var getid = function (id) {\n    return document.getElementById(id);\n  };\n\n  var div;\n\n  var chunk = function (htmlFunc, options) {\n    var html = Spark.isolate(htmlFunc);\n    options = options || {};\n    if (options.events)\n      html = Spark.attachEvents(options.events, html);\n    if (options.event_data)\n      html = Spark.setDataContext(options.event_data, html);\n    return html;\n  };\n\n  var render = function (htmlFunc, options) {\n    return Spark.render(function () {\n      return chunk(htmlFunc, options);\n    });\n  };\n\n\n  // clicking on a div at top level\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return '<div id=\"foozy\">Foo</div>';\n  }, {events: eventmap(\"click\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click']);\n  div.kill();\n  Deps.flush();\n\n  // selector that specifies a top-level div\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return '<div id=\"foozy\">Foo</div>';\n  }, {events: eventmap(\"click div\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click div']);\n  div.kill();\n  Deps.flush();\n\n  // selector that specifies a second-level span\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return '<div id=\"foozy\"><span>Foo</span></div>';\n  }, {events: eventmap(\"click span\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\").firstChild);\n  test.equal(event_buf, ['click span']);\n  div.kill();\n  Deps.flush();\n\n  // replaced top-level elements still have event handlers\n  // even if replaced by an isolate above the handlers in the DOM\n  var R = ReactiveVar(\"p\");\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return chunk(function () {\n      return '<'+R.get()+' id=\"foozy\">Hello</'+R.get()+'>';\n    });\n  }, {events: eventmap(\"click\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click']);\n  event_buf.length = 0;\n  R.set(\"div\"); // change tag, which is sure to replace element\n  Deps.flush();\n  clickElement(getid(\"foozy\")); // still clickable?\n  test.equal(event_buf, ['click']);\n  event_buf.length = 0;\n  R.set(\"p\");\n  Deps.flush();\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // bubbling from event on descendent of element matched\n  // by selector\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return '<div id=\"foozy\"><span><u><b>Foo</b></u></span>'+\n      '<span>Bar</span></div>';\n  }, {events: eventmap(\"click span\"), event_data:event_buf}));\n  clickElement(\n    getid(\"foozy\").firstChild.firstChild.firstChild);\n  test.equal(event_buf, ['click span']);\n  div.kill();\n  Deps.flush();\n\n  // bubbling order (for same event, same render node, different selector nodes)\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return '<div id=\"foozy\"><span><u><b>Foo</b></u></span>'+\n      '<span>Bar</span></div>';\n  }, {events: eventmap(\"click span\", \"click b\"), event_data:event_buf}));\n  clickElement(\n    getid(\"foozy\").firstChild.firstChild.firstChild);\n  test.equal(event_buf, ['click b', 'click span']);\n  div.kill();\n  Deps.flush();\n\n  // \"bubbling\" order for handlers at same level\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return chunk(function () {\n      return chunk(function () {\n        return '<span id=\"foozy\" class=\"a b c\">Hello</span>';\n      }, {events: eventmap(\"click .c\"), event_data:event_buf});\n    }, {events: eventmap(\"click .b\"), event_data:event_buf});\n  }, {events: eventmap(\"click .a\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click .c', 'click .b', 'click .a']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // stopPropagation doesn't prevent other event maps from\n  // handling same node\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return chunk(function () {\n      return chunk(function () {\n        return '<span id=\"foozy\" class=\"a b c\">Hello</span>';\n      }, {events: eventmap(\"click .c\"), event_data:event_buf});\n    }, {events: {\"click .b\": function (evt) {\n      event_buf.push(\"click .b\"); evt.stopPropagation();}}});\n  }, {events: eventmap(\"click .a\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click .c', 'click .b', 'click .a']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // stopImmediatePropagation DOES\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return chunk(function () {\n      return chunk(function () {\n        return '<span id=\"foozy\" class=\"a b c\">Hello</span>';\n      }, {events: eventmap(\"click .c\"), event_data:event_buf});\n    }, {events: {\"click .b\": function (evt) {\n      event_buf.push(\"click .b\");\n      evt.stopImmediatePropagation();}}});\n  }, {events: eventmap(\"click .a\"), event_data:event_buf}));\n  clickElement(getid(\"foozy\"));\n  test.equal(event_buf, ['click .c', 'click .b']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // bubbling continues even with DOM change\n  event_buf.length = 0;\n  R = ReactiveVar(true);\n  div = OnscreenDiv(render(function () {\n    return chunk(function () {\n      return '<div id=\"blarn\">'+(R.get()?'<span id=\"foozy\">abcd</span>':'')+'</div>';\n    }, {events: { 'click span': function () {\n      event_buf.push('click span');\n      R.set(false);\n      Deps.flush(); // kill the span\n    }, 'click div': function (evt) {\n      event_buf.push('click div');\n    }}});\n  }));\n  // click on span\n  clickElement(getid(\"foozy\"));\n  test.expect_fail(); // doesn't seem to work in old IE\n  test.equal(event_buf, ['click span', 'click div']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // \"deep reach\" from high node down to replaced low node.\n  // Tests that events are registered correctly to work in\n  // old IE.  Also tests change event bubbling\n  // and proper interpretation of event maps.\n  event_buf.length = 0;\n  R = ReactiveVar('foo');\n  div = OnscreenDiv(render(function () {\n    return '<div><p><span><b>'+\n      chunk(function () {\n        return '<input type=\"checkbox\">'+R.get();\n      }, {events: eventmap('click input'), event_data:event_buf}) +\n      '</b></span></p></div>';\n  }, { events: eventmap('change b', 'change input'), event_data:event_buf }));\n  R.set('bar');\n  Deps.flush();\n  // click on input\n  clickElement(div.node().getElementsByTagName('input')[0]);\n  event_buf.sort(); // don't care about order\n  test.equal(event_buf, ['change b', 'change input', 'click input']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // test that 'click *' fires on bubble\n  event_buf.length = 0;\n  R = ReactiveVar('foo');\n  div = OnscreenDiv(render(function () {\n    return '<div><p><span><b>'+\n      chunk(function () {\n        return '<input type=\"checkbox\">'+R.get();\n      }, {events: eventmap('click input'), event_data:event_buf}) +\n      '</b></span></p></div>';\n  }, { events: eventmap('click *'), event_data:event_buf }));\n  R.set('bar');\n  Deps.flush();\n  // click on input\n  clickElement(div.node().getElementsByTagName('input')[0]);\n  test.equal(\n    event_buf,\n    ['click input', 'click *', 'click *', 'click *', 'click *', 'click *']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // clicking on a div in a nested chunk (without patching)\n  event_buf.length = 0;\n  R = ReactiveVar('foo');\n  div = OnscreenDiv(render(function () {\n    return R.get() + chunk(function () {\n      return '<span>ism</span>';\n    }, {events: eventmap(\"click\"), event_data:event_buf});\n  }));\n  test.equal(div.text(), 'fooism');\n  clickElement(div.node().getElementsByTagName('SPAN')[0]);\n  test.equal(event_buf, ['click']);\n  event_buf.length = 0;\n  R.set('bar');\n  Deps.flush();\n  test.equal(div.text(), 'barism');\n  clickElement(div.node().getElementsByTagName('SPAN')[0]);\n  test.equal(event_buf, ['click']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // Test that reactive fragments manually inserted inside\n  // a reactive fragment eventually get wired.\n  event_buf.length = 0;\n  div = OnscreenDiv(render(function () {\n    return \"<div></div>\";\n  }, { events: eventmap(\"click span\", event_buf) }));\n  Deps.flush();\n  div.node().firstChild.appendChild(render(function () {\n    return '<span id=\"foozy\">hello</span>';\n  }));\n  clickElement(getid(\"foozy\"));\n  // implementation has no way to know we've inserted the fragment\n  test.equal(event_buf, []);\n  event_buf.length = 0;\n  Deps.flush();\n  clickElement(getid(\"foozy\"));\n  // now should be wired up\n  test.equal(event_buf, ['click span']);\n  event_buf.length = 0;\n  div.kill();\n  Deps.flush();\n\n  // Event data comes from event.currentTarget, not event.target\n  var data_buf = [];\n  div = OnscreenDiv(render(function () {\n    return \"<ul>\"+chunk(function () {\n      return '<li id=\"funyard\">Hello</li>';\n    }, { event_data: {x:'listuff'} })+\"</ul>\";\n  }, { event_data: {x:'ulstuff'},\n       events: { 'click ul': function () { data_buf.push(this); }}}));\n  clickElement(getid(\"funyard\"));\n  test.equal(data_buf, [{x:'ulstuff'}]);\n  div.kill();\n  Deps.flush();\n});\n\n\nTinytest.add(\"spark - list event handling\", function(test) {\n  var event_buf = [];\n  var div;\n\n  // same thing, but with events wired by listChunk \"added\" and \"removed\"\n  event_buf.length = 0;\n  var lst = [];\n  lst.observeChanges = function(callbacks) {\n    lst.callbacks = callbacks;\n    return {\n      stop: function() {\n        lst.callbacks = null;\n      }\n    };\n  };\n  div = OnscreenDiv(Meteor.render(function() {\n    var chkbx = function(doc) {\n      return '<input type=\"checkbox\">'+(doc ? doc._id : 'else');\n    };\n    var html = '<div><p><span><b>' +\n      Spark.setDataContext(\n        event_buf, Spark.attachEvents(\n          eventmap('click input', event_buf), Spark.list(lst, chkbx, chkbx))) +\n      '</b></span></p></div>';\n    html = Spark.setDataContext(event_buf, html);\n    html = Spark.attachEvents(eventmap('change b', 'change input', event_buf),\n                              html);\n    return html;\n  }));\n  Deps.flush();\n  test.equal(div.text().match(/\\S+/)[0], 'else');\n  // click on input\n  var doClick = function() {\n    clickElement(div.node().getElementsByTagName('input')[0]);\n    event_buf.sort(); // don't care about order\n    test.equal(event_buf, ['change b', 'change input', 'click input']);\n    event_buf.length = 0;\n  };\n  doClick();\n  // add item\n  lst.push({_id:'foo'});\n  lst.callbacks.addedBefore(lst[0]._id, lst[0], null);\n  Deps.flush();\n  test.equal(div.text().match(/\\S+/)[0], 'foo');\n  doClick();\n  // remove item, back to \"else\" case\n  lst.callbacks.removed(lst[0]._id);\n  lst.pop();\n  Deps.flush();\n  test.equal(div.text().match(/\\S+/)[0], 'else');\n  doClick();\n  // cleanup\n  div.kill();\n  Deps.flush();\n\n});\n\n\nTinytest.add(\"spark - basic landmarks\", function (test) {\n  var R = ReactiveVar(\"111\");\n  var x = [];\n  var expect = function (what) {\n    test.equal(x, what);\n    x = [];\n  };\n\n  var X = {};\n\n  var div = OnscreenDiv(Spark.render(function () {\n    return Spark.isolate(function () {\n      return R.get() +\n        Spark.createLandmark({\n          created: function () {\n            x.push(\"c\");\n            this.a = X;\n          },\n          rendered: function () {\n            x.push(\"r\", this.a);\n          },\n          destroyed: function () {\n            x.push(\"d\", this.a);\n          }\n        }, function() { return \"hi\"; });\n    });\n  }));\n\n  expect([\"c\"]);\n  Deps.flush();\n  expect([\"r\", X]);\n  Deps.flush();\n  expect([]);\n  R.set(\"222\");\n  expect([]);\n  Deps.flush();\n  expect([\"r\", X]);\n  Deps.flush();\n  expect([]);\n  div.remove();\n  expect([]);\n  Deps.flush();\n  expect([]);\n  div.kill();\n  Deps.flush();\n  expect([\"d\", X]);\n});\n\nTinytest.add(\"spark - labeled landmarks\", function (test) {\n  var R = [];\n  for (var i = 0; i < 10; i++)\n    R.push(ReactiveVar(\"\"));\n\n  var x = [];\n  var s = [];\n  var expect = function (what_x, what_s) {\n    test.equal(x, what_x);\n    test.equal(s, what_s);\n    x = [];\n    s = [];\n  };\n\n  var excludeLandmarks = [];\n  for (var i = 0; i < 6; i++)\n    excludeLandmarks.push(ReactiveVar(false));\n\n  var isolateLandmarks = ReactiveVar(false);\n  var serial = 1;\n  var testLandmark = function (id, htmlFunc) {\n    if (excludeLandmarks[id].get())\n      return \"\";\n\n    var f = function () {\n      var thisSerial = serial++;\n\n      return Spark.createLandmark({\n        created: function () {\n          x.push(\"c\", id);\n          s.push(thisSerial);\n          this.id = id;\n        },\n        rendered: function () {\n          x.push(\"r\", id);\n          s.push(thisSerial);\n          test.equal(this.id, id);\n        },\n        destroyed: function () {\n          x.push(\"d\", id);\n          s.push(thisSerial);\n          test.equal(this.id, id);\n        }\n      }, htmlFunc);\n    };\n\n    if (isolateLandmarks.get())\n      return Spark.isolate(function () { return f(); });\n    else\n      return f();\n  };\n\n  var label = Spark.labelBranch;\n\n  var dep = function (i) {\n    return R[i].get();\n  };\n\n  // this frog is pretty well boiled\n  var div = OnscreenDiv(Spark.render(function () {\n    var html = Spark.isolate(function () {\n      return (\n        dep(0) +\n          testLandmark(1, function () {return \"hi\" + dep(1); }) +\n          label(\"a\", function () {\n            return dep(2) +\n              testLandmark(2, function () { return \"hi\" + dep(3);});}) +\n          label(\"b\", function () {\n            return dep(4) +\n              testLandmark(3, function () {\n                return \"hi\" + dep(5) +                                                                     label(\"c\", function () {\n                  return dep(6) +\n                    testLandmark(4, function () {\n                      return \"hi\" + dep(7) +\n                        label(\"d\", function () {\n                          return label(\"e\", function () {\n                            return dep(8) +\n                              label(\"f\", function () {\n                                return testLandmark(\n                                  5, function () { return \"hi\" + dep(9);}\n                                );});});});});});});}));\n    });\n    return html;\n  }));\n\n  // callback order is not specced\n  expect([\"c\", 1, \"c\", 2, \"c\", 3, \"c\", 4, \"c\", 5], [1, 2, 3, 4, 5]);\n  Deps.flush();\n  expect([\"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3], [1, 2, 5, 4, 3]);\n  for (var i = 0; i < 10; i++) {\n    R[i].set(1);\n    expect([], []);\n    Deps.flush();\n    expect([\"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3],\n           [i*5 + 6, i*5 + 7, i*5 + 10, i*5 + 9, i*5 + 8]);\n  };\n\n  excludeLandmarks[2].set(true);\n  expect([], []);\n  Deps.flush();\n  expect([\"d\", 2, \"r\", 1, \"r\", 5, \"r\", 4, \"r\", 3],\n         [52, 56, 59, 58, 57]);\n\n  excludeLandmarks[2].set(false);\n  excludeLandmarks[3].set(true);\n  expect([], []);\n  Deps.flush();\n  expect([\"c\", 2, \"d\", 3, \"d\", 4, \"d\", 5, \"r\", 1, \"r\", 2],\n         [61, 57, 58, 59, 60, 61]);\n\n  excludeLandmarks[2].set(true);\n  excludeLandmarks[3].set(false);\n  expect([], []);\n  Deps.flush();\n  expect([\"c\", 3, \"c\", 4, \"c\", 5, \"d\", 2, \"r\", 1, \"r\", 5, \"r\", 4, \"r\", 3],\n         [63, 64, 65, 61, 62, 65, 64, 63]);\n\n  excludeLandmarks[2].set(false);\n  expect([], []);\n  Deps.flush();\n  expect([\"c\", 2, \"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3],\n         [67, 66, 67, 70, 69, 68]);\n\n  isolateLandmarks.set(true);\n  expect([], []);\n  Deps.flush();\n  expect([\"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3],\n         [71, 72, 75, 74, 73]);\n\n  for (var i = 0; i < 10; i++) {\n    var expected = [\n      [[\"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3], [76, 77, 80, 79, 78]],\n      [[\"r\", 1], [81]],\n      [[\"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3], [82, 83, 86, 85, 84]],\n      [[\"r\", 2], [87]],\n      [[\"r\", 1, \"r\", 2, \"r\", 5, \"r\", 4, \"r\", 3], [88, 89, 92, 91, 90]],\n      [[\"r\", 5, \"r\", 4, \"r\", 3], [95, 94, 93]],\n      [[\"r\", 5, \"r\", 4, \"r\", 3], [98, 97, 96]],\n      [[\"r\", 5, \"r\", 4, \"r\", 3], [100, 99, 96]],\n      [[\"r\", 5, \"r\", 4, \"r\", 3], [102, 101, 96]],\n      [[\"r\", 5, \"r\", 4, \"r\", 3], [103, 101, 96]]\n    ][i];\n    R[i].set(2);\n    expect([], []);\n    Deps.flush();\n    expect.apply(null, expected);\n  };\n\n  excludeLandmarks[4].set(true);\n  Deps.flush();\n  expect([\"d\", 4, \"d\", 5, \"r\", 3], [101, 103, 104]);\n\n  excludeLandmarks[4].set(false);\n  excludeLandmarks[5].set(true);\n  Deps.flush();\n  expect([\"c\", 4, \"r\", 4, \"r\", 3], [106, 106, 105]);\n\n  excludeLandmarks[5].set(false);\n  Deps.flush();\n  expect([\"c\", 5, \"r\", 5, \"r\", 4, \"r\", 3], [108, 108, 107, 105]);\n\n  div.kill();\n  Deps.flush();\n});\n\n\nTinytest.add(\"spark - preserve copies attributes\", function(test) {\n  // make sure attributes are correctly changed (i.e. copied)\n  // when preserving old nodes, either because they are labeled\n  // or because they are a parent of a labeled node.\n\n  var R1 = ReactiveVar(\"foo\");\n  var R2 = ReactiveVar(\"abcd\");\n\n  var frag = WrappedFrag(renderWithPreservation(function() {\n    return '<div puppy=\"'+R1.get()+'\"><div><div><div><input name=\"blah\" kittycat=\"'+\n      R2.get()+'\"></div></div></div></div>';\n  })).hold();\n  var node1 = frag.node().firstChild;\n  var node2 = frag.node().firstChild.getElementsByTagName(\"input\")[0];\n  test.equal(node1.nodeName, \"DIV\");\n  test.equal(node2.nodeName, \"INPUT\");\n  test.equal(node1.getAttribute(\"puppy\"), \"foo\");\n  test.equal(node2.getAttribute(\"kittycat\"), \"abcd\");\n\n  R1.set(\"bar\");\n  R2.set(\"efgh\");\n  Deps.flush();\n  test.equal(node1.getAttribute(\"puppy\"), \"bar\");\n  test.equal(node2.getAttribute(\"kittycat\"), \"efgh\");\n\n  frag.release();\n  Deps.flush();\n  test.equal(R1.numListeners(), 0);\n  test.equal(R2.numListeners(), 0);\n\n  var R;\n  R = ReactiveVar(false);\n  frag = WrappedFrag(renderWithPreservation(function() {\n    return '<input id=\"foo\" type=\"checkbox\"' + (R.get() ? ' checked=\"checked\"' : '') + '>';\n  })).hold();\n  var get_checked = function() { return !! frag.node().firstChild.checked; };\n  test.equal(get_checked(), false);\n  Deps.flush();\n  test.equal(get_checked(), false);\n  R.set(true);\n  test.equal(get_checked(), false);\n  Deps.flush();\n  test.equal(get_checked(), true);\n  R.set(false);\n  test.equal(get_checked(), true);\n  Deps.flush();\n  test.equal(get_checked(), false);\n  R.set(true);\n  Deps.flush();\n  test.equal(get_checked(), true);\n  frag.release();\n  R = ReactiveVar(true);\n  frag = WrappedFrag(renderWithPreservation(function() {\n    return '<input type=\"checkbox\"' + (R.get() ? ' checked=\"checked\"' : '') + '>';\n  })).hold();\n  test.equal(get_checked(), true);\n  Deps.flush();\n  test.equal(get_checked(), true);\n  R.set(false);\n  test.equal(get_checked(), true);\n  Deps.flush();\n  test.equal(get_checked(), false);\n  frag.release();\n\n\n  _.each([false, true], function(with_focus) {\n    R = ReactiveVar(\"apple\");\n    var div = OnscreenDiv(renderWithPreservation(function() {\n      return '<input id=\"foo\" type=\"text\" value=\"' + R.get() + '\">';\n    }));\n    var maybe_focus = function(div) {\n      if (with_focus) {\n        div.show();\n        focusElement(div.node().firstChild);\n      }\n    };\n    maybe_focus(div);\n    var get_value = function() { return div.node().firstChild.value; };\n    var set_value = function(v) { div.node().firstChild.value = v; };\n    var if_blurred = function(v, v2) {\n      return with_focus ? v2 : v; };\n    test.equal(get_value(), \"apple\");\n    Deps.flush();\n    test.equal(get_value(), \"apple\");\n    R.set(\"\");\n    test.equal(get_value(), \"apple\");\n    Deps.flush();\n    test.equal(get_value(), if_blurred(\"\", \"apple\"));\n    R.set(\"pear\");\n    test.equal(get_value(), if_blurred(\"\", \"apple\"));\n    Deps.flush();\n    test.equal(get_value(), if_blurred(\"pear\", \"apple\"));\n    set_value(\"jerry\"); // like user typing\n    R.set(\"steve\");\n    Deps.flush();\n    // should overwrite user typing if blurred\n    test.equal(get_value(), if_blurred(\"steve\", \"jerry\"));\n    div.kill();\n    R = ReactiveVar(\"\");\n    div = OnscreenDiv(renderWithPreservation(function() {\n      return '<input id=\"foo\" type=\"text\" value=\"' + R.get() + '\">';\n    }));\n    maybe_focus(div);\n    test.equal(get_value(), \"\");\n    Deps.flush();\n    test.equal(get_value(), \"\");\n    R.set(\"tom\");\n    test.equal(get_value(), \"\");\n    Deps.flush();\n    test.equal(get_value(), if_blurred(\"tom\", \"\"));\n    div.kill();\n    Deps.flush();\n  });\n});\n\nTinytest.add(\"spark - bad labels\", function(test) {\n  // make sure patching behaves gracefully even when labels violate\n  // the rules that would allow preservation of nodes identity.\n\n  var go = function(html1, html2) {\n    var R = ReactiveVar(true);\n    var frag = WrappedFrag(renderWithPreservation(function() {\n      return R.get() ? html1 : html2;\n    })).hold();\n\n    R.set(false);\n    Deps.flush();\n    test.equal(frag.html(), html2);\n    frag.release();\n  };\n\n  go('hello', 'world');\n\n  // duplicate IDs (bad developer; but should patch correctly)\n  go('<div id=\"foo\">hello</div><b id=\"foo\">world</b>',\n     '<div id=\"foo\">hi</div><b id=\"foo\">there</b>');\n  go('<div id=\"foo\"><b id=\"foo\">hello</b></div>',\n     '<div id=\"foo\"><b id=\"foo\">hi</b></div>');\n  go('<div id=\"foo\">hello</div><b id=\"foo\">world</b>',\n     '<div id=\"foo\"><b id=\"foo\">hi</b></div>');\n\n  // tag name changes\n  go('<div id=\"foo\">abcd</div>',\n     '<p id=\"foo\">efgh</p>');\n\n  // parent chain changes at all\n  go('<div><div><div><p id=\"foo\">test123</p></div></div></div>',\n     '<div><div><p id=\"foo\">test123</p></div></div>');\n  go('<div><div><div><p id=\"foo\">test123</p></div></div></div>',\n     '<div><ins><div><p id=\"foo\">test123</p></div></ins></div>');\n\n  // ambiguous names\n  go('<ul><li name=\"me\">1</li><li name=\"me\">3</li><li name=\"me\">3</li></ul>',\n     '<ul><li name=\"me\">4</li><li name=\"me\">5</li></ul>');\n});\n\n\nTinytest.add(\"spark - landmark patching\", function(test) {\n\n  var rand;\n\n  var randomNodeList = function(optParentTag, depth) {\n    var atTopLevel = ! optParentTag;\n    var len = rand.nextIntBetween(atTopLevel ? 1 : 0, 6);\n    var buf = [];\n    for(var i=0; i<len; i++)\n      buf.push(randomNode(optParentTag, depth));\n    return buf;\n  };\n\n  var randomNode = function(optParentTag, depth) {\n    var n = {};\n\n    if (rand.nextBoolean()) {\n      // text node\n      n.text = rand.nextIdentifier(2);\n    } else {\n\n      n.tagName = rand.nextChoice((function() {\n        switch (optParentTag) {\n        case \"p\": return ['b', 'i', 'u'];\n        case \"b\": return ['i', 'u'];\n        case \"i\": return ['u'];\n        case \"u\": case \"span\": return ['span'];\n        default: return ['div', 'ins', 'center', 'p'];\n        }\n      })());\n\n      if (rand.nextBoolean())\n        n.id = rand.nextIdentifier();\n      if (rand.nextBoolean())\n        n.name = rand.nextIdentifier();\n\n      if (depth === 0) {\n        n.children = [];\n      } else {\n        n.children = randomNodeList(n.tagName, depth-1);\n      }\n    }\n\n    var existence = rand.nextChoice([[true, true], [false, true], [true, false]]);\n    n.existsBefore = existence[0];\n    n.existsAfter = existence[1];\n\n    return n;\n  };\n\n  var nodeListToHtml = function(list, is_after, optBuf) {\n    var buf = (optBuf || []);\n    _.each(list, function(n) {\n      if (is_after ? n.existsAfter : n.existsBefore) {\n        if (n.text) {\n          buf.push(n.text);\n        } else {\n          buf.push('<', n.tagName);\n          if (n.id)\n            buf.push(' id=\"', n.id, '\"');\n          if (n.name)\n            buf.push(' name=\"', n.name, '\"');\n          buf.push('>');\n          nodeListToHtml(n.children, is_after, buf);\n          buf.push('</', n.tagName, '>');\n        }\n      }\n    });\n    return optBuf ? null : buf.join('');\n  };\n\n  var fillInElementIdentities = function(list, parent, is_after) {\n    var elementsInList = _.filter(\n      list,\n      function(x) {\n        return (is_after ? x.existsAfter : x.existsBefore) && x.tagName;\n      });\n    var elementsInDom = _.filter(parent.childNodes,\n                                 function(x) { return x.nodeType === 1; });\n    test.equal(elementsInList.length, elementsInDom.length);\n    for(var i=0; i<elementsInList.length; i++) {\n      elementsInList[i].node = elementsInDom[i];\n      fillInElementIdentities(elementsInList[i].children,\n                              elementsInDom[i]);\n    }\n  };\n\n  var getParentChain = function(node) {\n    var buf = [];\n    while (node) {\n      buf.push(node);\n      node = node.parentNode;\n    }\n    return buf;\n  };\n\n  var isSameElements = function(a, b) {\n    if (a.length !== b.length)\n      return false;\n    for(var i=0; i<a.length; i++) {\n      if (a[i] !== b[i])\n        return false;\n    }\n    return true;\n  };\n\n  var collectLabeledNodeData = function(list, optArray) {\n    var buf = optArray || [];\n\n    _.each(list, function(x) {\n      if (x.tagName && x.existsBefore && x.existsAfter) {\n        if (x.name || x.id) {\n          buf.push({ node: x.node, parents: getParentChain(x.node) });\n        }\n        collectLabeledNodeData(x.children, buf);\n      }\n    });\n\n    return buf;\n  };\n\n  for(var i=0; i<5; i++) {\n    // Use non-deterministic randomness so we can have a shorter fuzz\n    // test (fewer iterations).  For deterministic (fully seeded)\n    // randomness, remove the call to Random.fraction().\n    rand = new SeededRandom(\"preserved nodes \"+i+\" \"+Random.fraction());\n\n    var R = ReactiveVar(false);\n    var structure = randomNodeList(null, 6);\n    var frag = WrappedFrag(Meteor.render(function () {\n      return Spark.createLandmark({ preserve: idNameLabels }, function () {\n        return nodeListToHtml(structure, R.get());\n      });\n    })).hold();\n    test.equal(frag.html(), nodeListToHtml(structure, false) || \"<!---->\");\n    fillInElementIdentities(structure, frag.node());\n    var labeledNodes = collectLabeledNodeData(structure);\n    R.set(true);\n    Deps.flush();\n    test.equal(frag.html(), nodeListToHtml(structure, true) || \"<!---->\");\n    _.each(labeledNodes, function(x) {\n      test.isTrue(isSameElements(x.parents, getParentChain(x.node)));\n    });\n\n    frag.release();\n    Deps.flush();\n    test.equal(R.numListeners(), 0);\n  }\n\n});\n\nTinytest.add(\"spark - landmark constant\", function(test) {\n\n  var R, div;\n\n  // top-level { constant: true }\n\n  R = ReactiveVar(0);\n  var states = [];\n  div = OnscreenDiv(Meteor.render(function() {\n    R.get(); // create dependency\n    return Spark.createLandmark({\n      constant: true,\n      rendered: function() {\n        states.push(this);\n      }\n    }, function() { return '<b/><i/><u/>'; });\n  }));\n\n  var nodes = nodesToArray(div.node().childNodes);\n  test.equal(nodes.length, 3);\n  Deps.flush();\n  test.equal(states.length, 1);\n  R.set(1);\n  Deps.flush();\n  test.equal(states.length, 1); // no render callback on constant\n  var nodes2 = nodesToArray(div.node().childNodes);\n  test.equal(nodes2.length, 3);\n  test.isTrue(nodes[0] === nodes2[0]);\n  test.isTrue(nodes[1] === nodes2[1]);\n  test.isTrue(nodes[2] === nodes2[2]);\n  div.kill();\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n\n  // non-top-level\n\n  var i = 1;\n  // run test with and without matching branch label\n  _.each([false, true], function(matchLandmark) {\n    // run test with node before or after, or neither or both\n    _.each([false, true], function(nodeBefore) {\n      _.each([false, true], function(nodeAfter) {\n        var hasSpan = true;\n        var isConstant = true;\n\n        var crd = null; // [createCount, renderCount, destroyCount]\n\n        R = ReactiveVar('foo');\n        div = OnscreenDiv(Meteor.render(function() {\n          R.get(); // create unconditional dependency\n          var brnch = matchLandmark ? 'myBranch' : ('branch'+(++i));\n          return (nodeBefore ? R.get() : '') +\n            Spark.labelBranch(\n              brnch, function () {\n                return Spark.createLandmark(\n                  {\n                    constant: isConstant,\n                    created: function () {\n                      this.crd = [0,0,0];\n                      if (! crd)\n                        crd = this.crd; // capture first landmark's crd\n                      this.crd[0]++;\n                    },\n                    rendered: function () { this.crd[1]++; },\n                    destroyed: function () { this.crd[2]++; }\n                  },\n                  function() { return hasSpan ?\n                               '<span>stuff</span>' : 'blah'; });}) +\n            (nodeAfter ? R.get() : '');\n        }));\n\n        var span = div.node().getElementsByTagName('span')[0];\n        hasSpan = false;\n\n        test.equal(div.text(),\n                   (nodeBefore ? 'foo' : '')+\n                   'stuff'+\n                   (nodeAfter ? 'foo' : ''));\n\n        R.set('bar');\n        Deps.flush();\n\n        // only non-matching landmark should cause the constant\n        // chunk to be re-rendered\n        test.equal(div.text(),\n                   (nodeBefore ? 'bar' : '')+\n                   (matchLandmark ? 'stuff' : 'blah')+\n                   (nodeAfter ? 'bar' : ''));\n        // in non-matching case, first landmark is destroyed.\n        // otherwise, it is kept (and not re-rendered because\n        // it is constant)\n        test.equal(crd, matchLandmark ? [1,1,0] : [1,1,1]);\n\n        R.set('baz');\n        Deps.flush();\n\n        // should be repeatable (liveranges not damaged)\n        test.equal(div.text(),\n                   (nodeBefore ? 'baz' : '')+\n                   (matchLandmark ? 'stuff' : 'blah')+\n                   (nodeAfter ? 'baz' : ''));\n\n        isConstant = false; // no longer constant:true!\n        R.set('qux');\n        Deps.flush();\n        test.equal(div.text(),\n                   (nodeBefore ? 'qux' : '')+\n                   'blah'+\n                   (nodeAfter ? 'qux' : ''));\n\n        // turn constant back on\n        isConstant = true;\n        hasSpan = true;\n        R.set('popsicle');\n        Deps.flush();\n        // we don't get the span, instead old \"blah\" is preserved\n        test.equal(div.text(),\n                   (nodeBefore ? 'popsicle' : '')+\n                   (matchLandmark ? 'blah' : 'stuff')+\n                   (nodeAfter ? 'popsicle' : ''));\n\n        isConstant = false;\n        R.set('hi');\n        Deps.flush();\n        // now we get the span!\n        test.equal(div.text(),\n                   (nodeBefore ? 'hi' : '')+\n                   'stuff'+\n                   (nodeAfter ? 'hi' : ''));\n\n        div.kill();\n        Deps.flush();\n      });\n    });\n  });\n\n  // test that constant landmark gets rendered callback if it\n  // wasn't preserved.\n\n  var renderCount;\n\n  renderCount = 0;\n  R = ReactiveVar('div');\n  div = OnscreenDiv(Meteor.render(function () {\n    return '<' + R.get() + '>' + Spark.createLandmark(\n      {constant: true, rendered: function () { renderCount++; }},\n      function () {\n        return \"hi\";\n      }) +\n      '</' + R.get().split(' ')[0] + '>';\n  }));\n  Deps.flush();\n  test.equal(renderCount, 1);\n\n  R.set('div class=\"hamburger\"');\n  Deps.flush();\n  // constant patched around, not re-rendered!\n  test.equal(renderCount, 1);\n\n  R.set('span class=\"hamburger\"');\n  Deps.flush();\n  // can't patch parent to a different tag\n  test.equal(renderCount, 2);\n\n  R.set('span');\n  Deps.flush();\n  // can patch here, renderCount stays the same\n  test.equal(renderCount, 2);\n\n  div.kill();\n  Deps.flush();\n});\n\n_.each(['STRING', 'MONGO'], function (idGeneration) {\nTinytest.add(\"spark - leaderboard, \" + idGeneration, function(test) {\n  // use a simplified, local leaderboard to test some stuff\n\n  var players = new LocalCollection();\n  var selected_player = ReactiveVar();\n\n  var scores = OnscreenDiv(renderWithPreservation(function() {\n    var html = Spark.list(\n      players.find({}, {sort: {score: -1}}),\n      function(player) {\n        return Spark.labelBranch(player._id.valueOf(), function () {\n          return Spark.isolate(function () {\n            var style;\n            if (_.isEqual(selected_player.get(), player._id))\n              style = \"player selected\";\n            else\n              style = \"player\";\n\n            var html = '<div class=\"' + style + '\">' +\n              '<div class=\"name\">' + player.name + '</div>' +\n              '<div name=\"score\">' + player.score + '</div></div>';\n            html = Spark.setDataContext(player, html);\n            html = Spark.createLandmark(\n              {preserve: idNameLabels},\n              function() { return html; });\n            return html;\n          });\n        });\n      });\n    html = Spark.attachEvents({\n      \"click\": function () {\n        selected_player.set(this._id);\n      }\n    }, html);\n    return html;\n  }));\n  var idGen;\n  if (idGeneration === 'STRING')\n    idGen = _.bind(Random.id, Random);\n  else\n    idGen = function () { return new LocalCollection._ObjectID(); };\n\n  // back before we had scientists we had Vancian hussade players\n  var names = [\"Glinnes Hulden\", \"Shira Hulden\", \"Denzel Warhound\",\n               \"Lute Casagave\", \"Akadie\", \"Thammas, Lord Gensifer\",\n               \"Ervil Savat\", \"Duissane Trevanyi\", \"Sagmondo Bandolio\",\n               \"Rhyl Shermatz\", \"Yalden Wirp\", \"Tyran Lucho\",\n               \"Bump Candolf\", \"Wilmer Guff\", \"Carbo Gilweg\"];\n  for (var i = 0; i < names.length; i++)\n    players.insert({_id: idGen(), name: names[i], score: i*5});\n\n  var bump = function() {\n    players.update(selected_player.get(), {$inc: {score: 5}});\n  };\n\n  var findPlayerNameDiv = function(name) {\n    var divs = scores.node().getElementsByTagName('DIV');\n    return _.find(divs, function(div) {\n      return div.innerHTML === name;\n    });\n  };\n\n  Deps.flush();\n  var glinnesNameNode = findPlayerNameDiv(names[0]);\n  test.isTrue(!! glinnesNameNode);\n  var glinnesScoreNode = glinnesNameNode.nextSibling;\n  test.equal(glinnesScoreNode.getAttribute(\"name\"), \"score\");\n  clickElement(glinnesNameNode);\n  Deps.flush();\n  glinnesNameNode = findPlayerNameDiv(names[0]);\n  test.isTrue(!! glinnesNameNode);\n  test.equal(glinnesNameNode.parentNode.className, 'player selected');\n  var glinnesId = players.findOne({name: names[0]})._id;\n  test.isTrue(!! glinnesId);\n  test.equal(selected_player.get(), glinnesId);\n  test.equal(\n    canonicalizeHtml(glinnesNameNode.parentNode.innerHTML),\n    '<div class=\"name\">Glinnes Hulden</div><div name=\"score\">0</div>');\n\n  bump();\n  Deps.flush();\n\n  glinnesNameNode = findPlayerNameDiv(names[0], glinnesNameNode);\n  var glinnesScoreNode2 = glinnesNameNode.nextSibling;\n  test.equal(glinnesScoreNode2.getAttribute(\"name\"), \"score\");\n  // move and patch should leave score node the same, because it\n  // has a name attribute!\n  test.equal(glinnesScoreNode, glinnesScoreNode2);\n  test.equal(glinnesNameNode.parentNode.className, 'player selected');\n  test.equal(\n    canonicalizeHtml(glinnesNameNode.parentNode.innerHTML),\n    '<div class=\"name\">Glinnes Hulden</div><div name=\"score\">5</div>');\n\n  bump();\n  Deps.flush();\n\n  glinnesNameNode = findPlayerNameDiv(names[0], glinnesNameNode);\n  test.equal(\n    canonicalizeHtml(glinnesNameNode.parentNode.innerHTML),\n    '<div class=\"name\">Glinnes Hulden</div><div name=\"score\">10</div>');\n\n  scores.kill();\n  Deps.flush();\n  test.equal(selected_player.numListeners(), 0);\n});\n});\n\nTinytest.add(\"spark - list cursor stop\", function(test) {\n  // test Spark.list outside of render mode, on custom observable\n\n  var numHandles = 0;\n  var observable = {\n    observeChanges: function(x) {\n      x.addedBefore(\"123\", {}, null);\n      x.addedBefore(\"456\", {}, null);\n      var handle;\n      numHandles++;\n      return handle = {\n        stop: function() {\n          numHandles--;\n        }\n      };\n    }\n  };\n\n  test.equal(numHandles, 0);\n  var result = Spark.list(observable, function(doc) {\n    return \"#\"+doc._id;\n  });\n  test.equal(result, \"#123#456\");\n  Deps.flush();\n  // chunk killed because not created inside Spark.render\n  test.equal(numHandles, 0);\n\n\n  var R = ReactiveVar(1);\n  var frag = WrappedFrag(Meteor.render(function() {\n    if (R.get() > 0)\n      return Spark.list(observable, function() { return \"*\"; });\n    return \"\";\n  })).hold();\n  test.equal(numHandles, 1);\n  Deps.flush();\n  test.equal(numHandles, 1);\n  R.set(2);\n  Deps.flush();\n  test.equal(numHandles, 1);\n  R.set(-1);\n  Deps.flush();\n  test.equal(numHandles, 0);\n\n  frag.release();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - list table\", function(test) {\n  var c = new LocalCollection();\n\n  c.insert({value: \"fudge\", order: \"A\"});\n  c.insert({value: \"sundae\", order: \"B\"});\n\n  var R = ReactiveVar();\n\n  var table = WrappedFrag(Meteor.render(function() {\n    var buf = [];\n    buf.push('<table>');\n    buf.push(Spark.list(\n      c.find({}, {sort: ['order']}),\n      function(doc) {\n        return Spark.labelBranch(doc._id, function () {\n          return Spark.isolate(function () {\n            var html = \"<tr><td>\"+doc.value + (doc.reactive ? R.get() : '')+\n              \"</td></tr>\";\n            html = Spark.createLandmark(\n              {preserve: idNameLabels},\n              function() { return html; });\n            return html;\n          });\n        });\n      },\n      function() {\n        return \"<tr><td>(nothing)</td></tr>\";\n      }));\n    buf.push('</table>');\n    return buf.join('');\n  })).hold();\n\n  var lastHtml;\n\n  var shouldFlushTo = function(html) {\n    // same before flush\n    test.equal(table.html(), lastHtml);\n    Deps.flush();\n    test.equal(table.html(), html);\n    lastHtml = html;\n  };\n  var tableOf = function(/*htmls*/) {\n    if (arguments.length === 0) {\n      return '<table></table>';\n    } else {\n      return '<table><tbody><tr><td>' +\n        _.toArray(arguments).join('</td></tr><tr><td>') +\n        '</td></tr></tbody></table>';\n    }\n  };\n\n  test.equal(table.html(), lastHtml = tableOf('fudge', 'sundae'));\n\n  // switch order\n  c.update({value: \"fudge\"}, {$set: {order: \"BA\"}});\n  shouldFlushTo(tableOf('sundae', 'fudge'));\n\n  // change text\n  c.update({value: \"fudge\"}, {$set: {value: \"hello\"}});\n  c.update({value: \"sundae\"}, {$set: {value: \"world\"}});\n  shouldFlushTo(tableOf('world', 'hello'));\n\n  // remove all\n  c.remove({});\n  shouldFlushTo(tableOf('(nothing)'));\n\n  c.insert({value: \"1\", order: \"A\"});\n  c.insert({value: \"5\", order: \"B\"});\n  c.insert({value: \"3\", order: \"AB\"});\n  c.insert({value: \"7\", order: \"BB\"});\n  c.insert({value: \"2\", order: \"AA\"});\n  c.insert({value: \"4\", order: \"ABA\"});\n  c.insert({value: \"6\", order: \"BA\"});\n  c.insert({value: \"8\", order: \"BBA\"});\n  shouldFlushTo(tableOf('1', '2', '3', '4', '5', '6', '7', '8'));\n\n  // make one item newly reactive\n  R.set('*');\n  c.update({value: \"7\"}, {$set: {reactive: true}});\n  shouldFlushTo(tableOf('1', '2', '3', '4', '5', '6', '7*', '8'));\n\n  R.set('!');\n  shouldFlushTo(tableOf('1', '2', '3', '4', '5', '6', '7!', '8'));\n\n  // move it\n  c.update({value: \"7\"}, {$set: {order: \"A0\"}});\n  shouldFlushTo(tableOf('1', '7!', '2', '3', '4', '5', '6', '8'));\n\n  // still reactive?\n  R.set('?');\n  shouldFlushTo(tableOf('1', '7?', '2', '3', '4', '5', '6', '8'));\n\n  // go nuts\n  c.update({value: '1'}, {$set: {reactive: true}});\n  c.update({value: '1'}, {$set: {reactive: false}});\n  c.update({value: '2'}, {$set: {reactive: true}});\n  c.update({value: '2'}, {$set: {order: \"BBB\"}});\n  R.set(';');\n  R.set('.');\n  shouldFlushTo(tableOf('1', '7.', '3', '4', '5', '6', '8', '2.'));\n\n  for(var i=1; i<=8; i++)\n    c.update({value: String(i)},\n             {$set: {reactive: true, value: '='+String(i)}});\n  R.set('!');\n  shouldFlushTo(tableOf('=1!', '=7!', '=3!', '=4!', '=5!', '=6!', '=8!', '=2!'));\n\n  for(var i=1; i<=8; i++)\n    c.update({value: '='+String(i)},\n             {$set: {order: \"A\"+i}});\n  shouldFlushTo(tableOf('=1!', '=2!', '=3!', '=4!', '=5!', '=6!', '=7!', '=8!'));\n\n  var valueFunc = function(n) { return '<b name=\"bold\">'+n+'</b>'; };\n  for(var i=1; i<=8; i++)\n    c.update({value: '='+String(i)},\n             {$set: {value: valueFunc(i)}});\n  shouldFlushTo(tableOf.apply(\n    null,\n    _.map(_.range(1,9), function(n) { return valueFunc(n)+R.get(); })));\n\n  test.equal(table.node().firstChild.rows.length, 8);\n\n  var bolds = table.node().firstChild.getElementsByTagName('B');\n  test.equal(bolds.length, 8);\n  _.each(bolds, function(b) {\n    b.nifty = {}; // mark the nodes; non-primitive value won't appear in IE HTML\n  });\n\n  R.set('...');\n  shouldFlushTo(tableOf.apply(\n    null,\n    _.map(_.range(1,9), function(n) { return valueFunc(n)+R.get(); })));\n  var bolds2 = table.node().firstChild.getElementsByTagName('B');\n  test.equal(bolds2.length, 8);\n  // make sure patching is actually happening\n  _.each(bolds2, function(b) {\n    test.equal(!! b.nifty, true);\n  });\n\n  // change value func, and still we should be patching\n  var valueFunc2 = function(n) { return '<b name=\"bold\">'+n+'</b><i>yeah</i>'; };\n  for(var i=1; i<=8; i++)\n    c.update({value: valueFunc(i)},\n             {$set: {value: valueFunc2(i)}});\n  shouldFlushTo(tableOf.apply(\n    null,\n    _.map(_.range(1,9), function(n) { return valueFunc2(n)+R.get(); })));\n  var bolds3 = table.node().firstChild.getElementsByTagName('B');\n  test.equal(bolds3.length, 8);\n  _.each(bolds3, function(b) {\n    test.equal(!! b.nifty, true);\n  });\n\n  table.release();\n\n});\n\n\nTinytest.add(\"spark - list event data\", function(test) {\n  // this is based on a bug\n\n  var lastClicked = null;\n  var R = ReactiveVar(0);\n  var later;\n  var div = OnscreenDiv(Meteor.render(function() {\n    var html = Spark.list(\n      {\n        observeChanges: function(observer) {\n          observer.addedBefore(\"1\", {name: 'Foo'}, null);\n          observer.addedBefore(\"2\", {name: 'Bar'}, null);\n          // exercise callback path\n          later = function() {\n            observer.addedBefore(\"3\", {name: 'Baz'}, null);\n            observer.addedBefore(\"4\", {name: 'Qux'}, null);\n          };\n          return { stop: function() {} };\n        }\n      },\n      function(doc) {\n        var html = Spark.isolate(function () {\n          R.get(); // depend on R\n          return '<div>' + doc.name + '</div>';\n        });\n        html = Spark.setDataContext(doc, html);\n        return html;\n      }\n    );\n    html = Spark.attachEvents({\n      'click': function (event) {\n        lastClicked = this.name;\n        R.set(R.get() + 1); // signal all dependers on R\n      }\n    }, html);\n    return html;\n  }));\n\n  var item = function(name) {\n    return _.find(div.node().getElementsByTagName('div'), function(d) {\n      return d.innerHTML === name; });\n  };\n\n  later();\n  Deps.flush();\n  test.equal(item(\"Foo\").innerHTML, \"Foo\");\n  test.equal(item(\"Bar\").innerHTML, \"Bar\");\n  test.equal(item(\"Baz\").innerHTML, \"Baz\");\n  test.equal(item(\"Qux\").innerHTML, \"Qux\");\n\n  var doClick = function(name) {\n    clickElement(item(name));\n    test.equal(lastClicked, name);\n    Deps.flush();\n  };\n\n  doClick(\"Foo\");\n  doClick(\"Bar\");\n  doClick(\"Baz\");\n  doClick(\"Qux\");\n  doClick(\"Bar\");\n  doClick(\"Foo\");\n  doClick(\"Foo\");\n  doClick(\"Foo\");\n  doClick(\"Qux\");\n  doClick(\"Baz\");\n  doClick(\"Baz\");\n  doClick(\"Baz\");\n  doClick(\"Bar\");\n  doClick(\"Baz\");\n  doClick(\"Foo\");\n  doClick(\"Qux\");\n  doClick(\"Foo\");\n\n  div.kill();\n  Deps.flush();\n\n});\n\n\nTinytest.add(\"spark - events on preserved nodes\", function(test) {\n  var count = ReactiveVar(0);\n  var demo = OnscreenDiv(renderWithPreservation(function() {\n    var html = Spark.isolate(function () {\n      return '<div class=\"button_demo\">'+\n        '<input type=\"button\" name=\"press\" value=\"Press this button\">'+\n        '<div>The button has been pressed '+count.get()+' times.</div>'+\n        '</div>';\n    });\n    html = Spark.attachEvents({\n      'click input': function() {\n        count.set(count.get() + 1);\n      }\n    }, html);\n    return html;\n  }));\n\n  var click = function() {\n    clickElement(demo.node().getElementsByTagName('input')[0]);\n  };\n\n  test.equal(count.get(), 0);\n  for(var i=0; i<10; i++) {\n    click();\n    Deps.flush();\n    test.equal(count.get(), i+1);\n  }\n\n  demo.kill();\n  Deps.flush();\n});\n\n\nTinytest.add(\"spark - cleanup\", function(test) {\n\n  // more exhaustive clean-up testing\n  var stuff = new LocalCollection();\n\n  var add_doc = function() {\n    stuff.insert({foo:'bar'}); };\n  var clear_docs = function() {\n    stuff.remove({}); };\n  var remove_one = function() {\n    stuff.remove(stuff.findOne()._id); };\n\n  add_doc(); // start the collection with a doc\n\n  var R = ReactiveVar(\"x\");\n\n  var div = OnscreenDiv(Spark.render(function() {\n    return Spark.list(\n      stuff.find(),\n      function() {\n        return Spark.isolate(function () { return R.get()+\"1\"; });\n      },\n      function() {\n        return Spark.isolate(function () { return R.get()+\"0\"; });\n      });\n  }));\n\n  test.equal(div.text(), \"x1\");\n  Deps.flush();\n  test.equal(div.text(), \"x1\");\n  test.equal(R.numListeners(), 1);\n\n  clear_docs();\n  Deps.flush();\n  test.equal(div.text(), \"x0\");\n  test.equal(R.numListeners(), 1); // test clean-up of doc on remove\n\n  add_doc();\n  Deps.flush();\n  test.equal(div.text(), \"x1\");\n  test.equal(R.numListeners(), 1); // test clean-up of \"else\" listeners\n\n  add_doc();\n  Deps.flush();\n  test.equal(div.text(), \"x1x1\");\n  test.equal(R.numListeners(), 2);\n\n  remove_one();\n  Deps.flush();\n  test.equal(div.text(), \"x1\");\n  test.equal(R.numListeners(), 1); // test clean-up of doc with other docs\n\n  div.kill();\n  Deps.flush();\n  test.equal(R.numListeners(), 0);\n\n  //// list stopped if not materialized\n\n  var observeCount = 0;\n  var stopCount = 0;\n  var cursor = {\n    observeChanges: function (callbacks) {\n      observeCount++;\n      return {\n        stop: function () {\n          stopCount++;\n        }\n      };\n    }\n  };\n\n  div = OnscreenDiv(Spark.render(function () {\n    var html = Spark.list(cursor,\n                          function () { return ''; });\n    // don't return html\n    return 'hi';\n  }));\n  // we expect that the implementation of Spark.list observed the\n  // cursor in order to generate HTML, and then stopped it when\n  // it saw that the annotation wasn't materialized.  Other acceptable\n  // implementations of Spark.list might avoid observing the cursor\n  // altogether, resulting in [0, 0], or might defer the stopping to\n  // flush time.\n  test.equal([observeCount, stopCount], [1, 1]);\n\n  div.kill();\n  Deps.flush();\n});\n\n\nvar make_input_tester = function(render_func, events) {\n  var buf = [];\n\n  if (typeof render_func === \"string\") {\n    var render_str = render_func;\n    render_func = function() { return render_str; };\n  }\n  if (typeof events === \"string\") {\n    events = eventmap.apply(null, _.toArray(arguments).slice(1));\n  }\n\n  var R = ReactiveVar(0);\n  var div = OnscreenDiv(\n    renderWithPreservation(function() {\n      R.get(); // create dependency\n      var html = render_func();\n      html = Spark.attachEvents(events, html);\n      html = Spark.setDataContext(buf, html);\n      return html;\n    }));\n  div.show(true);\n\n  var getbuf = function() {\n    var ret = buf.slice();\n    buf.length = 0;\n    return ret;\n  };\n\n  var self;\n  return self = {\n    focus: function(optCallback) {\n      focusElement(self.inputNode());\n\n      if (optCallback)\n        Meteor.defer(function() { optCallback(getbuf()); });\n      else\n        return getbuf();\n    },\n    blur: function(optCallback) {\n      blurElement(self.inputNode());\n\n      if (optCallback)\n        Meteor.defer(function() { optCallback(getbuf()); });\n      else\n        return getbuf();\n    },\n    click: function() {\n      clickElement(self.inputNode());\n      return getbuf();\n    },\n    kill: function() {\n      // clean up\n      div.kill();\n      Deps.flush();\n    },\n    inputNode: function() {\n      return div.node().getElementsByTagName(\"input\")[0];\n    },\n    redraw: function() {\n      R.set(R.get() + 1);\n      Deps.flush();\n    }\n  };\n};\n\n// Note:  These tests MAY FAIL if the browser window doesn't have focus\n// (isn't frontmost) in some browsers, particularly Firefox.\ntestAsyncMulti(\"spark - focus/blur events\",\n  (function() {\n\n    var textLevel1 = '<input type=\"text\" />';\n    var textLevel2 = '<span id=\"spanOfMurder\"><input type=\"text\" /></span>';\n\n    var focus_test = function(render_func, events, expected_results) {\n      return function(test, expect) {\n        var tester = make_input_tester(render_func, events);\n        var callback = expect(expected_results);\n        tester.focus(function(buf) {\n          tester.kill();\n          callback(buf);\n        });\n      };\n    };\n\n    var blur_test = function(render_func, events, expected_results) {\n      return function(test, expect) {\n        var tester = make_input_tester(render_func, events);\n        var callback = expect(expected_results);\n        tester.focus();\n        tester.blur(function(buf) {\n          tester.kill();\n          callback(buf);\n        });\n      };\n    };\n\n    return [\n\n      // focus on top-level input\n      focus_test(textLevel1, 'focus input', ['focus input']),\n\n      // focus on second-level input\n      // issue #108\n      focus_test(textLevel2, 'focus input', ['focus input']),\n\n      // focusin\n      focus_test(textLevel1, 'focusin input', ['focusin input']),\n      focus_test(textLevel2, 'focusin input', ['focusin input']),\n\n      // focusin bubbles\n      focus_test(textLevel2, 'focusin span', ['focusin span']),\n\n      // focus doesn't bubble\n      focus_test(textLevel2, 'focus span', []),\n\n      // blur works, doesn't bubble\n      blur_test(textLevel1, 'blur input', ['blur input']),\n      blur_test(textLevel2, 'blur input', ['blur input']),\n      blur_test(textLevel2, 'blur span', []),\n\n      // focusout works, bubbles\n      blur_test(textLevel1, 'focusout input', ['focusout input']),\n      blur_test(textLevel2, 'focusout input', ['focusout input']),\n      blur_test(textLevel2, 'focusout span', ['focusout span'])\n    ];\n  })());\n\n\nTinytest.add(\"spark - change events\", function(test) {\n\n  var checkboxLevel1 = '<input type=\"checkbox\" />';\n  var checkboxLevel2 = '<span id=\"spanOfMurder\">'+\n    '<input type=\"checkbox\" id=\"checkboxy\" /></span>';\n\n\n  // on top-level\n  var checkbox1 = make_input_tester(checkboxLevel1, 'change input');\n  test.equal(checkbox1.click(), ['change input']);\n  checkbox1.kill();\n\n  // on second-level (should bubble)\n  var checkbox2 = make_input_tester(checkboxLevel2,\n                                    'change input', 'change span');\n  test.equal(checkbox2.click(), ['change input', 'change span']);\n  test.equal(checkbox2.click(), ['change input', 'change span']);\n  checkbox2.redraw();\n  test.equal(checkbox2.click(), ['change input', 'change span']);\n  checkbox2.kill();\n\n  checkbox2 = make_input_tester(checkboxLevel2, 'change input');\n  test.equal(checkbox2.focus(), []);\n  test.equal(checkbox2.click(), ['change input']);\n  test.equal(checkbox2.blur(), []);\n  test.equal(checkbox2.click(), ['change input']);\n  checkbox2.kill();\n\n  var checkbox2 = make_input_tester(\n    checkboxLevel2,\n    'change input', 'change span', 'change div');\n  test.equal(checkbox2.click(), ['change input', 'change span']);\n  checkbox2.kill();\n\n});\n\n\ntestAsyncMulti(\n  \"spark - submit events\",\n  (function() {\n    var hitlist = [];\n    var killLater = function(thing) {\n      hitlist.push(thing);\n    };\n\n    var LIVEUI_TEST_RESPONDER = \"/spark_test_responder\";\n    var IFRAME_URL_1 = LIVEUI_TEST_RESPONDER + \"/\";\n    var IFRAME_URL_2 = \"about:blank\"; // most cross-browser-compatible\n    if (window.opera) // opera doesn't like 'about:blank' form target\n      IFRAME_URL_2 = LIVEUI_TEST_RESPONDER+\"/blank\";\n\n    return [\n      function(test, expect) {\n\n        // Submit events can be canceled with preventDefault, which prevents the\n        // browser's native form submission behavior.  This behavior takes some\n        // work to ensure cross-browser, so we want to test it.  To detect\n        // a form submission, we target the form at an iframe.  Iframe security\n        // makes this tricky.  What we do is load a page from the server that\n        // calls us back on 'load' and 'unload'.  We wait for 'load', set up the\n        // test, and then see if we get an 'unload' (due to the form submission\n        // going through) or not.\n        //\n        // This is quite a tricky implementation.\n\n        var withIframe = function(onReady1, onReady2) {\n          var frameName = \"submitframe\"+String(Random.fraction()).slice(2);\n          var iframeDiv = OnscreenDiv(\n            Meteor.render(function() {\n              return '<iframe name=\"'+frameName+'\" '+\n                'src=\"'+IFRAME_URL_1+'\"></iframe>';\n            }));\n          var iframe = iframeDiv.node().firstChild;\n\n          iframe.loadFunc = function() {\n            onReady1(frameName, iframe, iframeDiv);\n            onReady2(frameName, iframe, iframeDiv);\n          };\n          iframe.unloadFunc = function() {\n            iframe.DID_CHANGE_PAGE = true;\n          };\n        };\n        var expectCheckLater = function(options) {\n          var check = expect(function(iframe, iframeDiv) {\n            if (options.shouldSubmit)\n              test.isTrue(iframe.DID_CHANGE_PAGE);\n            else\n              test.isFalse(iframe.DID_CHANGE_PAGE);\n\n            // must do this inside expect() so it happens in time\n            killLater(iframeDiv);\n          });\n          var checkLater = function(frameName, iframe, iframeDiv) {\n            Meteor.setTimeout(function() {\n              check(iframe, iframeDiv);\n            }, 500); // wait for frame to unload\n          };\n          return checkLater;\n        };\n        var buttonFormHtml = function(frameName) {\n          return '<div style=\"height:0;overflow:hidden\">'+\n            '<form action=\"'+IFRAME_URL_2+'\" target=\"'+\n            frameName+'\">'+\n            '<span><input type=\"submit\"></span>'+\n            '</form></div>';\n        };\n\n        // test that form submission by click fires event,\n        // and also actually submits\n        withIframe(function(frameName, iframe) {\n          var form = make_input_tester(\n            buttonFormHtml(frameName), 'submit form');\n          test.equal(form.click(), ['submit form']);\n          killLater(form);\n        }, expectCheckLater({shouldSubmit:true}));\n\n        // submit bubbles up\n        withIframe(function(frameName, iframe) {\n          var form = make_input_tester(\n            buttonFormHtml(frameName), 'submit form', 'submit div');\n          test.equal(form.click(), ['submit form', 'submit div']);\n          killLater(form);\n        }, expectCheckLater({shouldSubmit:true}));\n\n        // preventDefault works, still bubbles\n        withIframe(function(frameName, iframe) {\n          var form = make_input_tester(\n            buttonFormHtml(frameName), {\n              'submit form': function(evt) {\n                test.equal(evt.type, 'submit');\n                test.equal(evt.target.nodeName, 'FORM');\n                this.push('submit form');\n                evt.preventDefault();\n              },\n              'submit div': function(evt) {\n                test.equal(evt.type, 'submit');\n                test.equal(evt.target.nodeName, 'FORM');\n                this.push('submit div');\n              },\n              'submit a': function(evt) {\n                this.push('submit a');\n              }\n            }\n          );\n          test.equal(form.click(), ['submit form', 'submit div']);\n          killLater(form);\n        }, expectCheckLater({shouldSubmit:false}));\n\n      },\n      function(test, expect) {\n        _.each(hitlist, function(thing) {\n          thing.kill();\n        });\n        Deps.flush();\n      }\n    ];\n  })());\n\n\nTinytest.add(\"spark - controls - radio\", function(test) {\n  var R = ReactiveVar(\"\");\n  var R2 = ReactiveVar(\"\");\n  var change_buf = [];\n  var div = OnscreenDiv(renderWithPreservation(function() {\n    // Re-render when R2 is changed, even though it doesn't affect HTML.\n    R2.get();\n\n    var buf = [];\n    buf.push(\"Band: \");\n    _.each([\"AM\", \"FM\", \"XM\"], function(band) {\n      var checked = (R.get() === band) ? 'checked=\"checked\"' : '';\n      buf.push('<input type=\"radio\" name=\"bands\" '+\n               'value=\"'+band+'\" '+checked+'/>');\n    });\n    buf.push(R.get());\n    var html = buf.join('');\n\n    html = Spark.attachEvents({\n      'change input': function(event) {\n        // IE 7 is known to fire change events on all\n        // the radio buttons with checked=false, as if\n        // each button were deselected before selecting\n        // the new one.  (Meteor doesn't normalize this\n        // behavior.)\n        // However, browsers are consistent if we are\n        // getting a checked=true notification.\n        var btn = event.target;\n        if (btn.checked) {\n          var band = btn.value;\n          change_buf.push(band);\n          R.set(band);\n        }\n      }\n    }, html);\n    return html;\n  }));\n\n  Deps.flush();\n\n  // get the three buttons; they should be considered 'labeled'\n  // by the patcher and not change identities!\n  var btns = nodesToArray(div.node().getElementsByTagName(\"INPUT\"));\n\n  test.equal(_.pluck(btns, 'checked'), [false, false, false]);\n  test.equal(div.text(), \"Band: \");\n\n  clickElement(btns[0]);\n  test.equal(change_buf, ['AM']);\n  change_buf.length = 0;\n  Deps.flush();\n  test.equal(_.pluck(btns, 'checked'), [true, false, false]);\n  test.equal(div.text(), \"Band: AM\");\n\n  R2.set(\"change\");\n  Deps.flush();\n  test.length(change_buf, 0);\n  test.equal(_.pluck(btns, 'checked'), [true, false, false]);\n  test.equal(div.text(), \"Band: AM\");\n\n  clickElement(btns[1]);\n  test.equal(change_buf, ['FM']);\n  change_buf.length = 0;\n  Deps.flush();\n  test.equal(_.pluck(btns, 'checked'), [false, true, false]);\n  test.equal(div.text(), \"Band: FM\");\n\n  clickElement(btns[2]);\n  test.equal(change_buf, ['XM']);\n  change_buf.length = 0;\n  Deps.flush();\n  test.equal(_.pluck(btns, 'checked'), [false, false, true]);\n  test.equal(div.text(), \"Band: XM\");\n\n  clickElement(btns[1]);\n  test.equal(change_buf, ['FM']);\n  change_buf.length = 0;\n  Deps.flush();\n  test.equal(_.pluck(btns, 'checked'), [false, true, false]);\n  test.equal(div.text(), \"Band: FM\");\n\n  div.kill();\n});\n\nTinytest.add(\"spark - controls - checkbox\", function(test) {\n  var labels = [\"Foo\", \"Bar\", \"Baz\"];\n  var Rs = {};\n  _.each(labels, function (label) {\n    Rs[label] = ReactiveVar(false);\n  });\n  var changeBuf = [];\n  var div = OnscreenDiv(renderWithPreservation(function() {\n    var buf = [];\n    _.each(labels, function (label) {\n      var checked = Rs[label].get() ? 'checked=\"checked\"' : '';\n      buf.push('<input type=\"checkbox\" name=\"checky\" '+\n               'value=\"'+label+'\" '+checked+'/>');\n    });\n    return buf.join('');\n  }));\n\n  Deps.flush();\n\n  // get the three boxes; they should be considered 'labeled' by the patcher and\n  // not change identities!\n  var boxes = nodesToArray(div.node().getElementsByTagName(\"INPUT\"));\n\n  test.equal(_.pluck(boxes, 'checked'), [false, false, false]);\n\n  // Re-render with first one checked.\n  Rs.Foo.set(true);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [true, false, false]);\n\n  // Re-render with first one unchecked again.\n  Rs.Foo.set(false);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [false, false, false]);\n\n  // User clicks the second one.\n  clickElement(boxes[1]);\n  test.equal(_.pluck(boxes, 'checked'), [false, true, false]);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [false, true, false]);\n\n  // Re-render with third one checked. Second one should stay checked because\n  // it's a user update!\n  Rs.Baz.set(true);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [false, true, true]);\n\n  // User turns second and third off.\n  clickElement(boxes[1]);\n  clickElement(boxes[2]);\n  test.equal(_.pluck(boxes, 'checked'), [false, false, false]);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [false, false, false]);\n\n  // Re-render with first one checked. Third should stay off because it's a user\n  // update!\n  Rs.Foo.set(true);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [true, false, false]);\n\n  // Re-render with first one unchecked. Third should still stay off.\n  Rs.Foo.set(false);\n  Deps.flush();\n  test.equal(_.pluck(boxes, 'checked'), [false, false, false]);\n\n  div.kill();\n});\n\n_.each(['textarea', 'text', 'password', 'submit', 'button',\n        'reset', 'select', 'hidden'], function (type) {\n  Tinytest.add(\"spark - controls - \" + type, function(test) {\n    var R = ReactiveVar({x:\"test\"});\n    var R2 = ReactiveVar(\"\");\n    var div = OnscreenDiv(renderWithPreservation(function() {\n      // Re-render when R2 is changed, even though it doesn't affect HTML.\n      R2.get();\n      if (type === 'textarea') {\n        return '<textarea id=\"someId\">This is a ' + R.get().x + '</textarea>';\n      } else if (type === 'select') {\n        var options = ['This is a test', 'This is a fridge',\n                       'This is a frog', 'foobar', 'This is a photograph',\n                       'This is a monkey', 'This is a donkey'];\n        return '<select id=\"someId\">' + _.map(options, function (o) {\n          var maybeSel = ('This is a ' + R.get().x) === o ? 'selected' : '';\n          return '<option ' + maybeSel + '>' + o + '</option>';\n        }).join('') + '</select>';\n      } else {\n        return '<input type=\"' + type + '\" id=\"someId\" value=\"This is a ' +\n          R.get().x + '\">';\n      }\n    }));\n    div.show(true);\n    var canFocus = (type !== 'hidden');\n\n    var input = div.node().firstChild;\n    if (type === 'textarea' || type === 'select') {\n      test.equal(input.nodeName, type.toUpperCase());\n    } else {\n      test.equal(input.nodeName, 'INPUT');\n      test.equal(input.type, type);\n    }\n    test.equal(DomUtils.getElementValue(input), \"This is a test\");\n    test.equal(input._sparkOriginalRenderedValue, [\"This is a test\"]);\n\n    // value updates reactively\n    R.set({x:\"fridge\"});\n    Deps.flush();\n    test.equal(DomUtils.getElementValue(input), \"This is a fridge\");\n    test.equal(input._sparkOriginalRenderedValue, [\"This is a fridge\"]);\n\n    if (canFocus) {\n      // ...unless focused\n      focusElement(input);\n      R.set({x:\"frog\"});\n      Deps.flush();\n      test.equal(DomUtils.getElementValue(input), \"This is a fridge\");\n      test.equal(input._sparkOriginalRenderedValue, [\"This is a fridge\"]);\n\n      // blurring and re-setting works\n      blurElement(input);\n      Deps.flush();\n      test.equal(DomUtils.getElementValue(input), \"This is a fridge\");\n      test.equal(input._sparkOriginalRenderedValue, [\"This is a fridge\"]);\n    }\n    R.set({x:\"frog\"});\n    Deps.flush();\n    test.equal(DomUtils.getElementValue(input), \"This is a frog\");\n    test.equal(input._sparkOriginalRenderedValue, [\"This is a frog\"]);\n\n    // Setting a value (similar to user typing) should prevent value from being\n    // reverted if the div is re-rendered but the rendered value (ie, R) does\n    // not change.\n    DomUtils.setElementValue(input, \"foobar\");\n    R2.set(\"change\");\n    Deps.flush();\n    test.equal(DomUtils.getElementValue(input), \"foobar\");\n    test.equal(input._sparkOriginalRenderedValue, [\"This is a frog\"]);\n\n    // ... but if the actual rendered value changes, that should take effect.\n    R.set({x:\"photograph\"});\n    Deps.flush();\n    test.equal(DomUtils.getElementValue(input), \"This is a photograph\");\n    test.equal(input._sparkOriginalRenderedValue, [\"This is a photograph\"]);\n\n    // If the rendered value and user value change in the same way (eg, the user\n    // changed it and then invoked a menthod that set the database value based\n    // on what they changed), make sure that the _sparkOriginalRenderedValue\n    // gets updated too.\n    DomUtils.setElementValue(input, \"This is a monkey\");\n    R.set({x:\"monkey\"});\n    Deps.flush();\n    test.equal(DomUtils.getElementValue(input), \"This is a monkey\");\n    test.equal(input._sparkOriginalRenderedValue, [\"This is a monkey\"]);\n\n    if (canFocus) {\n      // The same as the previous test... except make sure that it still works\n      // if the input is focused. ie, imagine that the user edited the field and\n      // hit enter with the field still focused, updating the database to match\n      // the field and keeping the field focused.\n      DomUtils.setElementValue(input, \"This is a donkey\");\n      focusElement(input);\n      R.set({x:\"donkey\"});\n      Deps.flush();\n      test.equal(DomUtils.getElementValue(input), \"This is a donkey\");\n      test.equal(input._sparkOriginalRenderedValue, [\"This is a donkey\"]);\n    }\n\n    div.kill();\n  });\n});\n\nTinytest.add(\"spark - oldschool landmark matching\", function(test) {\n\n  // basic created / onscreen / offscreen callback flow\n  // (ported from old chunk-matching API)\n\n  var buf;\n  var counts;\n\n  var testCallbacks = function(theNum /*, extend opts*/) {\n    return _.extend.apply(_, [{\n      created: function() {\n        this.num = String(theNum);\n        var howManyBefore = counts[this.num] || 0;\n        counts[this.num] = howManyBefore + 1;\n        for(var i=0;i<howManyBefore;i++)\n          this.num += \"*\"; // add stars\n        buf.push(\"c\"+this.num);\n      },\n      rendered: function(start, end, range) {\n        buf.push(\"r\"+this.num);\n      },\n      destroyed: function() {\n        buf.push(\"d\"+this.num);\n      }\n    }].concat(_.toArray(arguments).slice(1)));\n  };\n\n  buf = [];\n  counts = {};\n  var R = ReactiveVar(\"A\");\n  var div = OnscreenDiv(Meteor.render(function() {\n    var html = Spark.createLandmark(testCallbacks(0), function () {\n      return String(R.get());\n    });\n    return html;\n  }, testCallbacks(0)));\n\n  test.equal(buf, [\"c0\"]);\n\n  test.equal(div.html(), \"A\");\n  Deps.flush();\n  test.equal(buf, [\"c0\", \"r0\"]);\n  test.equal(div.html(), \"A\");\n\n  R.set(\"B\");\n  Deps.flush();\n  test.equal(buf, [\"c0\", \"r0\", \"r0\"]);\n  test.equal(div.html(), \"B\");\n\n\n  div.kill();\n  Deps.flush();\n  test.equal(buf, [\"c0\", \"r0\", \"r0\", \"d0\"]);\n\n  // with a branch\n\n  buf = [];\n  counts = {};\n  R = ReactiveVar(\"A\");\n  div = OnscreenDiv(Meteor.render(function() {\n    R.get();\n    return Spark.createLandmark(testCallbacks(0), function () {\n      var html = Spark.labelBranch(\"foo\", function () {\n        return Spark.createLandmark(testCallbacks(1),\n                                    function () { return \"HI\"; });\n      });\n      return \"<div>\" + html + \"</div>\";\n    });\n  }));\n\n  test.equal(buf, [\"c0\", \"c1\"]);\n  Deps.flush();\n  // what order of chunks {0,1} is preferable??\n  // should be consistent but I'm not sure what makes most sense.\n  test.equal(buf, \"c0,c1,r1,r0\".split(','));\n  buf.length = 0;\n\n  R.set(\"B\");\n  Deps.flush();\n  test.equal(buf, \"r1,r0\".split(','));\n  buf.length = 0;\n\n  div.kill();\n  Deps.flush();\n  buf.sort();\n  test.equal(buf, \"d0,d1\".split(','));\n});\n\n\nTinytest.add(\"spark - oldschool branch keys\", function(test) {\n\n  var R, div;\n\n  // Re-rendered Meteor.render keeps same landmark state\n\n  var objs = [];\n  R = ReactiveVar(\"foo\");\n  div = OnscreenDiv(Meteor.render(function() {\n    return Spark.createLandmark({\n      rendered: function () { objs.push(true); }\n    }, function () { return R.get(); });\n  }));\n\n  Deps.flush();\n  R.set(\"bar\");\n  Deps.flush();\n  R.set(\"baz\");\n  Deps.flush();\n\n  test.equal(objs.length, 3);\n  test.isTrue(objs[0] === objs[1]);\n  test.isTrue(objs[1] === objs[2]);\n\n  div.kill();\n  Deps.flush();\n\n  // track chunk matching / re-rendering in detail\n\n  var buf;\n  var counts;\n\n  var testCallbacks = function(theNum /*, extend opts*/) {\n    return _.extend.apply(_, [{\n      created: function() {\n        this.num = String(theNum);\n        var howManyBefore = counts[this.num] || 0;\n        counts[this.num] = howManyBefore + 1;\n        for(var i=0;i<howManyBefore;i++)\n          this.num += \"*\"; // add stars\n        buf.push(\"c\"+this.num);\n      },\n      rendered: function(start, end, range) {\n        buf.push(\"on\"+this.num);\n      },\n      destroyed: function() {\n        buf.push(\"off\"+this.num);\n      }\n    }].concat(_.toArray(arguments).slice(1)));\n  };\n\n  var counter = 1;\n  var chunk = function(contents, num, branch) {\n    if (branch === null)\n      branch = \"unique_branch_\" + (counter++);\n\n    return Spark.labelBranch(branch, function () {\n      return Spark.createLandmark(\n        testCallbacks(num),\n        function () {\n          if (typeof contents === \"string\")\n            return contents;\n          else if (_.isArray(contents))\n            return _.map(contents, function(x) {\n              if (typeof x === 'string')\n                return x;\n              return chunk(x[0], x[1], x[2]);\n            }).join('');\n          else\n            return contents();\n        });\n    });\n  };\n\n  ///// Chunk 1 contains 2,3,4, all should be matched\n\n  buf = [];\n  counts = {};\n\n  R = ReactiveVar(\"foo\");\n  div = OnscreenDiv(Meteor.render(function() {\n    if (R.get() === 'nothing')\n      return \"no chunk!\";\n    else\n      return chunk([['<span>apple</span>', 2, 'x'],\n                    ['<span>banana</span>', 3, 'y'],\n                    ['<span>kiwi</span>', 4, 'z']\n                   ], 1, 'fruit');\n  }));\n\n  Deps.flush();\n  buf.sort();\n  test.equal(buf, ['c1', 'c2', 'c3', 'c4', 'on1', 'on2', 'on3', 'on4']);\n  buf.length = 0;\n\n  R.set(\"bar\");\n  Deps.flush();\n  buf.sort();\n  test.equal(buf, ['on1', 'on2', 'on3', 'on4']);\n  buf.length = 0;\n\n  R.set(\"nothing\");\n  Deps.flush();\n  buf.sort();\n  test.equal(buf, ['off1', 'off2', 'off3', 'off4']);\n  buf.length = 0;\n\n  div.kill();\n  Deps.flush();\n\n  ///// Chunk 3 has no branch key, should be recreated\n\n  buf = [];\n  counts = {};\n\n  R = ReactiveVar(\"foo\");\n  div = OnscreenDiv(Meteor.render(function() {\n    if (R.get() === 'nothing')\n      return \"no chunk!\";\n    else\n      return chunk([['<span>apple</span>', 2, 'x'],\n                    ['<span>banana</span>', 3, null],\n                    ['<span>kiwi</span>', 4, 'z']\n                   ], 1, 'fruit');\n  }));\n\n  Deps.flush();\n  buf.sort();\n  test.equal(buf, ['c1', 'c2', 'c3', 'c4', 'on1', 'on2', 'on3', 'on4']);\n  buf.length = 0;\n\n  R.set(\"bar\");\n  Deps.flush();\n  buf.sort();\n  test.equal(buf, ['c3*', 'off3', 'on1', 'on2', 'on3*', 'on4']);\n  buf.length = 0;\n\n  div.kill();\n  Deps.flush();\n  buf.sort();\n  // killing the div should have given us offscreen calls for 1,2,3*,4\n  test.equal(buf, ['off1', 'off2', 'off3*', 'off4']);\n  buf.length = 0;\n\n\n  // XXX test intermediate unkeyed chunks;\n  // duplicate branch keys; different order\n});\n\nTinytest.add(\"spark - isolate inside landmark\", function (test) {\n\n  // test that preservation maps from all landmarks are honored when\n  // an isolate is re-rendered, even the landmarks that are outside\n  // the isolate and therefore not involved in the re-render.\n\n  var R = ReactiveVar(1);\n  var d = OnscreenDiv(Spark.render(function () {\n    return Spark.createLandmark(\n      { preserve: ['.foo'] },\n      function () {\n        return Spark.isolate(function () {\n          return '<hr class=\"foo\"/>' + R.get();\n        });\n      });\n  }));\n\n  var foo1 = d.node().firstChild;\n  test.equal(d.node().firstChild.nextSibling.nodeValue, '1');\n  R.set(2);\n  Deps.flush();\n  var foo2 = d.node().firstChild;\n  test.equal(d.node().firstChild.nextSibling.nodeValue, '2');\n  test.isTrue(foo1 === foo2);\n  d.kill();\n  Deps.flush();\n\n  // test that selectors in a landmark preservation map are resolved\n  // relative to the landmark, not relative to the re-rendered\n  // fragment.  the selector may refer to nodes that are outside the\n  // re-rendered fragment, and the selector will still match.\n\n  R = ReactiveVar(1);\n  d = OnscreenDiv(Spark.render(function () {\n    return Spark.createLandmark(\n      { preserve: ['div .foo'] },\n      function () {\n        return \"<div>\"+Spark.isolate(function () {\n          return '<hr class=\"foo\"/>' + R.get();\n        })+\"</div>\";\n      });\n  }));\n\n  var foo1 = DomUtils.find(d.node(), '.foo');\n  test.equal(foo1.nodeName, 'HR');\n  test.equal(foo1.nextSibling.nodeValue, '1');\n  R.set(2);\n  Deps.flush();\n  var foo2 = DomUtils.find(d.node(), '.foo');\n  test.equal(foo2.nodeName, 'HR');\n  test.equal(foo2.nextSibling.nodeValue, '2');\n  test.isTrue(foo1 === foo2);\n  d.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - nested onscreen processing\", function (test) {\n  var cursor = {\n    observeChanges: function () { return { stop: function () {} }; }\n  };\n\n  var x = [];\n  var d = OnscreenDiv(Spark.render(function () {\n    return Spark.list(cursor, function () {}, function () {\n      return Spark.list(cursor, function () {}, function () {\n        return Spark.list(cursor, function () {}, function () {\n          return Spark.createLandmark({\n            created: function () { x.push('c'); },\n            rendered: function () { x.push('r'); },\n            destroyed: function () { x.push('d'); }\n          }, function () { return \"hi\"; });\n        });\n      });\n    });\n  }));\n\n  Deps.flush();\n  test.equal(x.join(''), 'cr');\n  x = [];\n  d.kill();\n  Deps.flush();\n  test.equal(x.join(''), 'd');\n});\n\nTinytest.add(\"spark - current landmark\", function (test) {\n  var R = ReactiveVar(1);\n  var callbacks = 0;\n  var d = OnscreenDiv(Meteor.render(function () {\n    var html = Spark.createLandmark({\n      created: function () {\n        this.a = 1;\n        this.renderCount = 0;\n        test.isFalse('b' in this);\n        callbacks++;\n      },\n      rendered: function () {\n        test.equal(this.a, 9);\n        test.equal(this.b, 2);\n        if (this.renderCount === 0)\n          test.isFalse('c' in this);\n        else\n          test.isTrue('c' in this);\n        this.renderCount++;\n        callbacks++;\n      },\n      destroyed: function () {\n        test.equal(this.a, 9);\n        test.equal(this.b, 2);\n        test.equal(this.c, 3);\n        callbacks++;\n      }\n    }, function (lm) {\n      var html = '<span>hi</span>';\n\n      if (R.get() === 1) {\n        test.equal(callbacks, 1);\n        test.equal(lm.a, 1);\n        lm.a = 9;\n        lm.b = 2;\n        test.isFalse('c' in lm);\n        test.equal(callbacks, 1);\n        lm = null;\n      }\n\n      if (R.get() === 2) {\n        test.equal(callbacks, 2);\n        test.equal(lm.a, 9);\n        test.equal(lm.b, 2);\n        test.equal(lm.c, 3);\n        test.equal(lm.renderCount, 1);\n      }\n\n      return html;\n    });\n\n\n    if (R.get() >= 3) {\n      html += Spark.labelBranch('branch', function () {\n        var html = Spark.createLandmark({\n          created: function () {\n            this.outer = true;\n          },\n          rendered: function () {\n            this.renderCount = (this.renderCount || 0) + 1;\n          }\n        }, function (lm) {\n          var html = '<span>outer</span>';\n          test.isTrue(lm.outer);\n          test.equal(R.get() - 3, lm.renderCount || 0);\n          html += Spark.labelBranch(\"a\", function () {\n            var html = Spark.createLandmark({\n              created: function () {\n                this.innerA = true;\n              },\n              rendered: function () {\n                this.renderCount = (this.renderCount || 0) + 1;\n              }\n            }, function (lm) {\n              var html = '<span>innerA</span>';\n              test.isTrue(lm.innerA);\n              return html;\n            });\n            return html;\n          });\n          return html;\n        });\n\n        if (R.get() === 3 || R.get() >= 5) {\n          html += Spark.labelBranch(\"b\", function () {\n            var html = Spark.createLandmark({\n              created: function () {\n                this.innerB = true;\n              },\n              rendered: function () {\n                this.renderCount = (this.renderCount || 0) + 1;\n              }\n            }, function (lm) {\n              var html = '<span>innerB</span>';\n              test.isTrue(lm.innerB);\n              test.equal(R.get() === 3 ? 0 : R.get() - 5,\n                         lm.renderCount || 0);\n              return html;\n            });\n            return html;\n          });\n        }\n        return html;\n      });\n    }\n    return html;\n  }));\n\n  var findOuter = function () {\n    return d.node().firstChild.nextSibling;\n  };\n\n  var findInnerA = function () {\n    return findOuter().nextSibling;\n  };\n\n  var findInnerB = function () {\n    return findInnerA().nextSibling;\n  };\n\n  test.equal(callbacks, 1);\n  Deps.flush();\n  test.equal(callbacks, 2);\n  test.equal(null, SparkTest.getEnclosingLandmark(d.node()));\n  var enc = SparkTest.getEnclosingLandmark(d.node().firstChild);\n  test.equal(enc.a, 9);\n  test.equal(enc.b, 2);\n  test.isFalse('c' in enc);\n  enc.c = 3;\n  Deps.flush();\n  test.equal(callbacks, 2);\n\n  R.set(2)\n  Deps.flush();\n  test.equal(callbacks, 3);\n\n  R.set(3)\n  Deps.flush();\n  test.equal(callbacks, 4);\n\n  test.isTrue(SparkTest.getEnclosingLandmark(findOuter()).outer);\n  test.isTrue(SparkTest.getEnclosingLandmark(findInnerA()).innerA);\n  test.isTrue(SparkTest.getEnclosingLandmark(findInnerB()).innerB);\n  test.equal(1, SparkTest.getEnclosingLandmark(findOuter()).renderCount);\n  test.equal(1, SparkTest.getEnclosingLandmark(findInnerA()).renderCount);\n  test.equal(1, SparkTest.getEnclosingLandmark(findInnerB()).renderCount);\n\n  R.set(4)\n  Deps.flush();\n  test.equal(callbacks, 5);\n  test.equal(2, SparkTest.getEnclosingLandmark(findOuter()).renderCount);\n  test.equal(2, SparkTest.getEnclosingLandmark(findInnerA()).renderCount);\n\n  R.set(5)\n  Deps.flush();\n  test.equal(callbacks, 6);\n  test.equal(3, SparkTest.getEnclosingLandmark(findOuter()).renderCount);\n  test.equal(3, SparkTest.getEnclosingLandmark(findInnerA()).renderCount);\n  test.equal(1, SparkTest.getEnclosingLandmark(findInnerB()).renderCount);\n\n  R.set(6)\n  Deps.flush();\n  test.equal(callbacks, 7);\n  test.equal(4, SparkTest.getEnclosingLandmark(findOuter()).renderCount);\n  test.equal(4, SparkTest.getEnclosingLandmark(findInnerA()).renderCount);\n  test.equal(2, SparkTest.getEnclosingLandmark(findInnerB()).renderCount);\n\n  d.kill();\n  Deps.flush();\n  test.equal(callbacks, 8);\n\n  Deps.flush();\n  test.equal(callbacks, 8);\n});\n\nTinytest.add(\"spark - find/findAll on landmark\", function (test) {\n  var l1, l2;\n  var R = ReactiveVar(1);\n\n  var d = OnscreenDiv(Spark.render(function () {\n    return \"<div id=1>k</div><div id=2>\" +\n      Spark.labelBranch(\"a\", function () {\n        return Spark.createLandmark({\n          created: function () {\n            test.instanceOf(this, Spark.Landmark);\n            if (l1)\n              test.equal(l1, this);\n            l1 = this;\n          }\n        }, function () {\n          return \"<span class='a' id=3>a\" +\n            Spark.labelBranch(\"b\", function () {\n              return Spark.isolate(\n                function () {\n                  R.get();\n                  return Spark.createLandmark(\n                    {\n                      created: function () {\n                        test.instanceOf(this, Spark.Landmark);\n                        if (l2)\n                          test.equal(l2, this);\n                        l2 = this;\n                      }\n                    }, function () {\n                      return \"<span class='b' id=4>b4</span>\" +\n                        \"<span class='b' id=6>b6</span>\";\n                    });\n                });\n            }) + \"</span>\";\n        });\n      }) + \"<span class='c' id=5>c</span></div>\";\n  }));\n\n  var ids = function (nodes) {\n    if (!(nodes instanceof Array))\n      nodes = nodes ? [nodes] : [];\n    return _.pluck(nodes, 'id').join('');\n  };\n\n  var check = function (all) {\n    var f = all ? 'findAll' : 'find';\n\n    test.equal(ids(l1[f]('.kitten')), '');\n    test.equal(ids(l2[f]('.kitten')), '');\n\n    test.equal(ids(l1[f]('.a')), '3');\n    test.equal(ids(l2[f]('.a')), '');\n\n    test.equal(ids(l1[f]('.b')), all ? '46' : '4');\n    test.equal(ids(l2[f]('.b')), all ? '46' : '4');\n\n    test.equal(ids(l1[f]('.c')), '');\n    test.equal(ids(l2[f]('.c')), '');\n\n    test.equal(ids(l1[f]('.a .b')), all ? '46' : '4');\n    test.equal(ids(l2[f]('.a .b')), '');\n  };\n\n  check(false);\n  check(true);\n  R.set(2);\n  Deps.flush();\n  check(false);\n  check(true);\n\n  d.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - landmark clean-up\", function (test) {\n\n  var crd;\n  var makeCrd = function () {\n    var crd = [0,0,0];\n    crd.callbacks = {\n      created: function () { crd[0]++; },\n      rendered: function () { crd[1]++; },\n      destroyed: function () { crd[2]++; }\n    };\n    return crd;\n  };\n\n  // not inside render\n  crd = makeCrd();\n  Spark.createLandmark(crd.callbacks, function () { return 'hi'; });\n  test.equal(crd, [1,0,1]);\n\n  // landmark never materialized\n  crd = makeCrd();\n  Spark.render(function() {\n    var html =\n          Spark.createLandmark(crd.callbacks, function () { return 'hi'; });\n    return '';\n  });\n  test.equal(crd, [1,0,1]);\n  Deps.flush();\n  test.equal(crd, [1,0,1]);\n\n  // two landmarks, only one materialized at a time.\n  // one replaces the other\n  var crd1 = makeCrd();\n  var crd2 = makeCrd();\n  var R = ReactiveVar(1);\n  var div = OnscreenDiv(Meteor.render(function() {\n    return (R.get() === 1 ?\n            Spark.createLandmark(crd1.callbacks, function() { return 'hi'; }) :\n            Spark.createLandmark(crd2.callbacks, function() { return 'hi'; }));\n  }));\n  test.equal(crd1, [1,0,0]); // created\n  test.equal(crd2, [0,0,0]);\n  Deps.flush();\n  test.equal(crd1, [1,1,0]); // rendered\n  test.equal(crd2, [0,0,0]);\n  R.set(2);\n  Deps.flush();\n  test.equal(crd1, [1,1,0]); // not destroyed (callback replaced)\n  test.equal(crd2, [0,1,0]); // matched\n\n  div.kill();\n  Deps.flush();\n  test.equal(crd1, [1,1,0]);\n  test.equal(crd2, [0,1,1]); // destroyed\n});\n\nTinytest.add(\"spark - bubbling render\", function (test) {\n  var makeCrd = function () {\n    var crd = [0,0,0];\n    crd.callbacks = {\n      created: function () { crd[0]++; },\n      rendered: function () { crd[1]++; },\n      destroyed: function () { crd[2]++; }\n    };\n    return crd;\n  };\n\n  var crd1 = makeCrd();\n  var crd2 = makeCrd();\n\n  var R = ReactiveVar('foo');\n  var div = OnscreenDiv(Spark.render(function () {\n    return Spark.createLandmark(crd1.callbacks, function () {\n      return Spark.labelBranch('fred', function () {\n        return Spark.createLandmark(crd2.callbacks, function () {\n          return Spark.isolate(function () {\n            return R.get();\n          });\n        });\n      });\n    });\n  }));\n\n  Deps.flush();\n  test.equal(div.html(), 'foo');\n  test.equal(crd1, [1,1,0]);\n  test.equal(crd2, [1,1,0]);\n\n  R.set('bar');\n  Deps.flush();\n  test.equal(div.html(), 'bar');\n  test.equal(crd1, [1,2,0]);\n  test.equal(crd2, [1,2,0]);\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - landmark arg\", function (test) {\n  var div = OnscreenDiv(Spark.render(function () {\n    return Spark.createLandmark({\n      created: function () {\n        test.isFalse(this.hasDom());\n      },\n      rendered: function () {\n        var landmark = this;\n        landmark.firstNode().innerHTML = 'Greetings';\n        landmark.lastNode().innerHTML = 'Line';\n        landmark.find('i').innerHTML =\n          (landmark.findAll('b').length)+\"-bold\";\n        test.isTrue(landmark.hasDom());\n      },\n      destroyed: function () {\n        test.isFalse(this.hasDom());\n      }\n    }, function () {\n      return Spark.attachEvents({\n        'click': function (event, landmark) {\n          landmark.firstNode().innerHTML = 'Hello';\n          landmark.lastNode().innerHTML = 'World';\n          landmark.find('i').innerHTML =\n            (landmark.findAll('*').length)+\"-element\";\n        }\n      }, '<b>Foo</b> <i>Bar</i> <u>Baz</u>');\n    });\n  }));\n\n  test.equal(div.text(), \"Foo Bar Baz\");\n  Deps.flush();\n  test.equal(div.text(), \"Greetings 1-bold Line\");\n  clickElement(DomUtils.find(div.node(), 'i'));\n  test.equal(div.text(), \"Hello 3-element World\");\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - landmark preserve\", function (test) {\n  var R = ReactiveVar(\"foo\");\n\n  var lmhr = function () {\n    return Spark.createLandmark({preserve:['hr']}, function () {\n      return '<hr/>';\n    });\n  };\n\n  var div = OnscreenDiv(Meteor.render(function () {\n    return \"<div><span>\" + R.get() + \"</span>\" +\n      Spark.labelBranch('A', lmhr) + Spark.labelBranch('B', lmhr) +\n      \"</div>\";\n  }));\n\n  test.equal(div.html(), '<div><span>foo</span><hr><hr></div>');\n  var hrs1 = DomUtils.findAll(div.node(), 'hr');\n  R.set(\"bar\");\n  Deps.flush();\n  test.equal(div.html(), '<div><span>bar</span><hr><hr></div>');\n  var hrs2 = DomUtils.findAll(div.node(), 'hr');\n\n  test.isTrue(hrs1[0] === hrs2[0]);\n  test.isTrue(hrs1[1] === hrs2[1]);\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - branch annotation is optional\", function (test) {\n  // test that labelBranch works on HTML that isn't element-balanced\n  // and doesn't fail by trying to emit an annotation when it contains\n  // no landmarks.\n\n  var R = ReactiveVar(\"foo\");\n\n  var Rget = function () { return R.get(); };\n  var cnst = function (c) { return function () { return c; }; };\n  var lmhr = function () {\n    return Spark.createLandmark({preserve:['hr']}, function () {\n      return '<hr/>';\n    });\n  };\n\n  var div = OnscreenDiv(Meteor.render(function () {\n    return '<div class=\"' + Spark.labelBranch('A', Rget) + '\">' +\n      Spark.labelBranch('B', cnst('</div><div>')) +\n      Spark.labelBranch('C', lmhr) + Spark.labelBranch('D', lmhr) +\n      '</div>';\n  }));\n\n  test.equal(div.html(), '<div class=\"foo\"></div><div><hr><hr></div>');\n  var div1 = div.node().firstChild;\n  var hrs1 = DomUtils.findAll(div.node(), 'hr');\n  R.set(\"bar\");\n  Deps.flush();\n  test.equal(div.html(), '<div class=\"bar\"></div><div><hr><hr></div>');\n  var div2 = div.node().firstChild;\n  var hrs2 = DomUtils.findAll(div.node(), 'hr');\n\n  test.isFalse(div1 === div2);\n  test.isTrue(hrs1[0] === hrs2[0]);\n  test.isTrue(hrs1[1] === hrs2[1]);\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - unique label\", function (test) {\n  var buf = [];\n  var bufstr = function () {\n    buf.sort();\n    var str = buf.join('');\n    buf.length = 0;\n    return str;\n  };\n\n  var ublm = function () {\n    return Spark.labelBranch(Spark.UNIQUE_LABEL, function () {\n      return Spark.createLandmark({created: function () { buf.push('c'); },\n                                   rendered: function () { buf.push('r'); },\n                                   destroyed: function () { buf.push('d'); }},\n                                  function () { return 'x'; });\n    });\n  };\n\n  var R = ReactiveVar(\"foo\");\n\n  var div = OnscreenDiv(Meteor.render(function () {\n    return ublm() + ublm() + ublm() + R.get();\n  }));\n  Deps.flush();\n  test.equal(bufstr(), 'cccrrr');\n  R.set('bar');\n  Deps.flush();\n  test.equal(bufstr(), 'cccdddrrr');\n\n  div.kill();\n  Deps.flush();\n  test.equal(bufstr(), 'ddd');\n\n});\n\nTinytest.add(\"spark - list update\", function (test) {\n  var R = ReactiveVar('foo');\n\n  var lst = [];\n  lst.callbacks = [];\n  lst.observeChanges = function(callbacks) {\n    lst.callbacks.push(callbacks);\n    _.each(lst, function(x) {\n      callbacks.addedBefore(x._id, x, null);\n    });\n    return {\n      stop: function() {\n        lst.callbacks = _.without(lst.callbacks, callbacks);\n      }\n    };\n  };\n  lst.another = function () {\n    var i = lst.length;\n    lst.push({_id:'item'+i});\n    _.each(lst.callbacks, function (callbacks) {\n      callbacks.addedBefore(lst[i]._id, lst[i], null);\n    });\n  };\n  var div = OnscreenDiv(Meteor.render(function() {\n    return R.get() + Spark.list(lst, function () {\n      return '<hr>';\n    });\n  }));\n\n  lst.another();\n  Deps.flush();\n  test.equal(div.html(), \"foo<hr>\");\n\n  lst.another();\n  R.set('bar');\n  Deps.flush();\n  test.equal(div.html(), \"bar<hr><hr>\");\n\n  R.set('baz');\n  lst.another();\n  Deps.flush();\n  test.equal(div.html(), \"baz<hr><hr><hr>\");\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - callback context\", function (test) {\n  // Test that context in template callbacks is null.\n\n  var cxs = [];\n  var buf = [];\n\n  var R = ReactiveVar(\"foo\");\n  var getCx = function () { return Deps.currentComputation; };\n  var callbackFunc = function (ltr) {\n    return function () {\n      buf.push(ltr);\n      cxs.push(getCx());\n    };\n  };\n  var div = OnscreenDiv(Meteor.render(function () {\n    var cx = getCx();\n    test.isTrue(cx); // sanity check for getCx\n    var makeLandmark = function () {\n      return Spark.createLandmark({created: callbackFunc('c'),\n                                   rendered: callbackFunc('r'),\n                                   destroyed: callbackFunc('d')},\n                                  function () {\n                                    return '<span>'+R.get()+'</span>';\n                                  });\n    };\n    if (R.get() === 'foo')\n      var unused = makeLandmark(); // will cause created/destroyed\n    var html = Spark.labelBranch(\"foo\", makeLandmark);\n    test.isTrue(getCx() === cx); // test that context was restored\n    return html;\n  }));\n  Deps.flush();\n  R.set('bar');\n  Deps.flush();\n  div.kill();\n  Deps.flush();\n\n  test.equal(buf.join(''), 'ccdrrd');\n  test.equal(cxs.length, 6);\n  test.isFalse(cxs[0]);\n  test.isFalse(cxs[1]);\n  test.isFalse(cxs[2]);\n  test.isFalse(cxs[3]);\n  test.isFalse(cxs[4]);\n  test.isFalse(cxs[5]);\n\n});\n\nTinytest.add(\"spark - legacy preserve names\", function (test) {\n  var R = ReactiveVar(\"foo\");\n  var R2 = ReactiveVar(\"apple\");\n\n  var div = OnscreenDiv(renderWithPreservation(function () {\n    R.get(); // create dependency\n    return ('<div id=\"aaa\"><div><input name=\"field\"></div></div>' +\n            '<div id=\"bbb\"><div><input name=\"field\"></div></div>' +\n            '<div id=\"ccc\"><div>' + Spark.isolate(function () {\n              R2.get();\n              return '<input name=\"field\">'; }) + '</div></div>' +\n            '<input type=\"text\">');\n  }));\n\n\n  var inputs1 = nodesToArray(div.node().getElementsByTagName('input'));\n  R.set('bar');\n  Deps.flush();\n  var inputs2 = nodesToArray(div.node().getElementsByTagName('input'));\n  test.isTrue(inputs1[0] === inputs2[0]);\n  test.isTrue(inputs1[1] === inputs2[1]);\n  test.isTrue(inputs1[2] === inputs2[2]);\n  test.isTrue(inputs1[3] !== inputs2[3]);\n\n  R2.set('banana');\n  Deps.flush();\n  var inputs3 = nodesToArray(div.node().getElementsByTagName('input'));\n  test.isTrue(inputs1[2] === inputs3[2]);\n\n  div.kill();\n  Deps.flush();\n});\n\nTinytest.add(\"spark - update defunct range\", function (test) {\n  // Test that Spark doesn't freak out if it tries to update\n  // a LiveRange on nodes that have been taken out of the document.\n  //\n  // See https://github.com/meteor/meteor/issues/392.\n\n  var R = ReactiveVar(\"foo\");\n\n  var div = OnscreenDiv(Spark.render(function () {\n    return \"<p>\" + Spark.isolate(function() {\n      return R.get();\n    }) + \"</p>\";\n  }));\n\n  test.equal(div.html(), \"<p>foo</p>\");\n  R.set(\"bar\");\n  Deps.flush();\n  test.equal(R.numListeners(), 1);\n  test.equal(div.html(), \"<p>bar</p>\");\n  test.equal(div.node().firstChild.nodeName, \"P\");\n  div.node().firstChild.innerHTML = '';\n  R.set(\"baz\");\n  Deps.flush(); // should throw no errors\n  // will be 1 if our isolate func was run.\n  test.equal(R.numListeners(), 0);\n\n  /////\n\n  R = ReactiveVar(\"foo\");\n\n  div = OnscreenDiv(Spark.render(function () {\n    return \"<p>\" + Spark.setDataContext(\n      {},\n      \"<span>\" + Spark.isolate(function() {\n        return R.get();\n      }) + \"</span>\") + \"</p>\";\n  }));\n\n  test.equal(div.html(), \"<p><span>foo</span></p>\");\n  R.set(\"bar\");\n  Deps.flush();\n  test.equal(R.numListeners(), 1);\n  test.equal(div.html(), \"<p><span>bar</span></p>\");\n  test.equal(div.node().firstChild.nodeName, \"P\");\n  div.node().firstChild.innerHTML = '';\n  R.set(\"baz\");\n  Deps.flush(); // should throw no errors\n  // will be 1 if our isolate func was run.\n  test.equal(R.numListeners(), 0);\n\n});\n","Tinytest.add(\"spark - patch - basic\", function(test) {\n\n  var Patcher = SparkTest.Patcher;\n\n  var div = function(html) {\n    var n = document.createElement(\"DIV\");\n    n.innerHTML = html;\n    return n;\n  };\n  var tag = function(node, tagName, which) {\n    return node.getElementsByTagName(tagName)[which || 0];\n  };\n  var assert_html = function(actual, expected) {\n    actual = (typeof actual === \"string\" ? actual : actual.innerHTML);\n    expected = (typeof expected === \"string\" ? expected : expected.innerHTML);\n    test.equal(actual.toLowerCase(), expected.toLowerCase());\n  };\n\n  var x,y,p,ret;\n\n  x = div(\"<b><i>foo</i><u>bar</u></b>\");\n  y = div(\"<b><u>qux</u><s>baz</s></b>\");\n  p = new Patcher(x, y);\n  ret = p.match(tag(x, 'u'), tag(y, 'u'));\n  test.isTrue(ret);\n  assert_html(x, \"<b><u>bar</u></b>\");\n  ret = p.finish();\n  test.isTrue(ret);\n  assert_html(x, \"<b><u>bar</u><s>baz</s></b>\");\n\n  x = div(\"<b><i>foo</i><u>bar</u></b>\");\n  y = div(\"<b><u>qux</u><s>baz</s></b>\");\n  p = new Patcher(x, y);\n  ret = p.finish();\n  test.isTrue(ret);\n  assert_html(x, \"<b><u>qux</u><s>baz</s></b>\");\n\n  x = div(\"<b><i><u>foo</u></i></b><b><i><u><s>bar</s></u></i></b>\");\n  y = div(\n    \"1<b>2<i>3<u>foo</u>4</i>5</b>6<b>7<i>8<u>9<s>bar</s>10</u>11</i>12</b>13\");\n  p = new Patcher(x, y);\n  ret = p.match(tag(x, 'u'), tag(y, 'u'));\n  test.isTrue(ret);\n  assert_html(x, \"1<b>2<i>3<u>foo</u></i></b><b><i><u><s>bar</s></u></i></b>\");\n  ret = p.match(tag(x, 's'), tag(y, 's'));\n  test.isTrue(ret);\n  assert_html(\n    x,\n    \"1<b>2<i>3<u>foo</u>4</i>5</b>6<b>7<i>8<u>9<s>bar</s></u></i></b>\");\n  ret = p.finish();\n  test.isTrue(ret);\n  assert_html(\n    x,\n    \"1<b>2<i>3<u>foo</u>4</i>5</b>6<b>7<i>8<u>9<s>bar</s>10</u>11</i>12</b>13\");\n\n  // mismatched parents, detection and recovery\n\n  x = div(\"<b><i>foo</i><u>bar</u></b>\");\n  y = div(\"<b><i>foo</i></b><b><u>bar</u></b>\");\n  p = new Patcher(x,y);\n  ret = p.match(tag(x, 'i'), tag(y, 'i'));\n  test.isTrue(ret);\n  assert_html(x, \"<b><i>foo</i><u>bar</u></b>\");\n  ret = p.match(tag(x, 'u'), tag(y, 'u'));\n  test.isFalse(ret);\n  assert_html(x, \"<b><i>foo</i><u>bar</u></b>\");\n  ret = p.finish();\n  test.isTrue(ret);\n  assert_html(x,\"<b><i>foo</i></b><b><u>bar</u></b>\");\n\n  x = div(\"<b><i>foo</i></b><b><u>bar</u></b>\");\n  y = div(\"<b><i>foo</i><u>bar</u></b>\");\n  p = new Patcher(x,y);\n  ret = p.match(tag(x, 'i'), tag(y, 'i'));\n  test.isTrue(ret);\n  assert_html(x, \"<b><i>foo</i></b><b><u>bar</u></b>\");\n  ret = p.match(tag(x, 'u'), tag(y, 'u'));\n  test.isFalse(ret);\n  assert_html(x, \"<b><i>foo</i><u>bar</u></b><b><u>bar</u></b>\");\n  ret = p.finish();\n  test.isTrue(ret);\n  assert_html(x, \"<b><i>foo</i><u>bar</u></b>\");\n\n  // mismatched tag name, detection and recovery\n  x = div(\"<b><i>foo</i><u>bar</u></b>\");\n  y = div(\"<i><u>bar</u><s>baz</s></i>\");\n  p = new Patcher(x, y);\n  ret = p.match(tag(x, 'u'), tag(y, 'u'));\n  test.isFalse(ret);\n  ret = p.finish();\n  test.isTrue(ret);\n  assert_html(x, \"<i><u>bar</u><s>baz</s></i>\");\n\n  var t = \"_foo\";\n  var liverange = function(start, end, inner) {\n    return new LiveRange(t, start, end, inner);\n  };\n\n  var rangeTest = function(extras) {\n    var aaa = extras[0], zzz = extras[1];\n    x = div(aaa+\"<b><i>foo</i><u>bar</u></b>\"+zzz);\n    y = div(\"<b><u>bar</u><s>baz</s></b>\");\n    var rng = liverange(tag(y, 'u'));\n    var tgt = liverange(tag(x, 'b'));\n    p = new Patcher(tgt.containerNode(), y,\n                    tgt.firstNode().previousSibling,\n                    tgt.lastNode().nextSibling);\n    var copyCallback = function(tgt, src) {\n      LiveRange.transplantTag(t, tgt, src);\n    };\n    ret = p.match(tag(x, 'u'), tag(y, 'u'), copyCallback);\n    test.isTrue(ret);\n    assert_html(x, aaa+\"<b><u>bar</u></b>\"+zzz);\n    ret = p.finish();\n    test.isTrue(ret);\n    assert_html(x, aaa+\"<b><u>bar</u><s>baz</s></b>\"+zzz);\n    test.equal(rng.firstNode(), tag(x, 'u'));\n  };\n\n  _.each([[\"aaa\",\"zzz\"], [\"\",\"\"], [\"aaa\",\"\"], [\"\",\"zzz\"]], rangeTest);\n});\n\nTinytest.add(\"spark - patch - copyAttributes\", function(test) {\n\n  var attrTester = function(tagName, initial) {\n    var node;\n    var allAttrNames = {};\n    var lastAttrs;\n    var self = {\n      copy: function(kv) {\n        var buf = [];\n        buf.push('<', tagName);\n        _.each(kv, function(v,k) {\n          allAttrNames[k] = true;\n          buf.push(' ', k);\n          if (v !== 'NO_VALUE')\n            buf.push('=\"', v, '\"');\n        });\n        buf.push('></', tagName, '>');\n        var nodeHtml = buf.join('');\n        var frag = DomUtils.htmlToFragment(nodeHtml);\n        var n = frag.firstChild;\n        n._sparkOriginalRenderedChecked = [n.checked];\n        if (! node) {\n          node = n;\n        } else {\n          SparkTest.Patcher._copyAttributes(node, n);\n        }\n        lastAttrs = {};\n        _.each(allAttrNames, function(v,k) {\n          lastAttrs[k] = false;\n        });\n        _.each(kv, function(v,k) {\n          if (k === \"style\") {\n            lastAttrs[k] = n.style.cssText;\n          } else {\n            lastAttrs[k] = String(v);\n          }\n        });\n        return self;\n      },\n      check: function() {\n        _.each(lastAttrs, function(v,k) {\n          var actualAttr;\n          var expectedAttr = v || \"\";\n          if (k === \"style\") {\n            actualAttr = node.style.cssText;\n          } else if (k === \"class\") {\n            actualAttr = node.className;\n          } else if (k === \"checked\") {\n            actualAttr = String(node.getAttribute(k) || \"\");\n            if (expectedAttr === \"NO_VALUE\")\n              expectedAttr = \"checked\";\n            if (actualAttr === \"true\")\n              actualAttr = \"checked\"; // save IE's butt\n          } else {\n            actualAttr = String(node.getAttribute(k) || \"\");\n          }\n          test.equal(actualAttr, expectedAttr, k);\n        });\n      },\n      node: function() { return node; }\n    };\n    if (initial)\n      self.copy(initial);\n    return self;\n  };\n\n  var a = attrTester('div',\n                     {id:'foo', 'class':'bar',\n                      style:'border:1px solid blue;', name:'baz'});\n  a.check();\n  test.equal(a.node().style.borderLeftColor, \"blue\");\n\n  a.copy({id: \"foo\", style:'border:1px solid red'});\n  a.check();\n  test.equal(a.node().style.borderLeftColor, \"red\");\n\n  a.copy({id: \"foo\", 'class':'ha'});\n  a.check();\n  test.equal(a.node().style.borderColor, \"\");\n  test.equal(a.node().className, \"ha\");\n\n  var obj = {};\n  a.node().nifty = obj;\n  a.copy({id: \"foo\", 'class':'ha hee'});\n  a.check();\n  test.equal(a.node().nifty, obj, 'nifty'); // test object property preservation\n\n\n  var c = attrTester('input', {type:'checkbox', name:'foo', checked:'checked'});\n  c.check();\n  test.equal(c.node().checked, true);\n  c.copy({type:'checkbox', name:'foo'});\n  c.check();\n  test.equal(c.node().checked, false);\n  c.copy({type:'checkbox', name:'foo', checked:'checked'});\n  c.check();\n  test.equal(c.node().checked, true);\n  c.copy({type:'checkbox', name:'foo'});\n  c.check();\n  test.equal(c.node().checked, false);\n\n  var d = attrTester('input', {type:'checkbox', name:'foo'});\n  test.equal(c.node().checked, false);\n  c.copy({type:'checkbox', name:'foo', checked:'checked'});\n  c.check();\n  test.equal(c.node().checked, true);\n  c.copy({type:'checkbox', name:'foo'});\n  c.check();\n  test.equal(c.node().checked, false);\n  c.copy({type:'checkbox', name:'foo', checked:'checked'});\n  c.check();\n  test.equal(c.node().checked, true);\n  c.copy({type:'checkbox', name:'foo'});\n  c.check();\n  test.equal(c.node().checked, false);\n  c.copy({type:'checkbox', name:'foo', checked:'NO_VALUE'});\n  c.check();\n  test.equal(c.node().checked, true);\n\n  c.copy({type:'checkbox', name:'bar'});\n  test.expect_fail(); // changing \"name\" on a form control won't take in IE\n  test.equal(c.node().getAttribute(\"name\"), 'bar');\n\n  c.copy({type:'radio', name:'foo'});\n  test.expect_fail(); // changing \"type\" on a form control won't take in IE\n  test.equal(c.node().getAttribute(\"type\"), 'radio');\n\n\n});\n"]}